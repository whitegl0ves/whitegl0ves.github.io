{"posts":[{"title":"写在前面","text":"博客前言 还在修改配置中，有点乱，见谅 与其说这是博客，更像是笔记，因为之前在很多不同的平台，用不同工具记录了很多笔记，每次看起来太麻烦了，最后还是决定写成文章形式会更方便自己，也更方便别人 博客会持续更新，由于是将之前笔记放上来，可能会有的地方显示错乱，会尽量修改好再发布 项目代码一直是针对工作上的内容，demo 可能会比较少，所以一般会搜别人的放上来，后面会逐渐改为自己的，形成完整的学习笔记 有的实现步骤写了，但是项目代码可能会晚点放过来，顺序比较乱还要整理 如果我个人感觉这个技术可能落后了，或者使用的人太少了，亦或是我自己不想学的话，这个分类板块的内容就不会再更新 思维导图，md，文档，代码，各种形式的都有，笔记量也比较大，所以整理起来很费时间，有的会先放自己的笔记，有的会先放当时学习的文章，后面不会解释了，到最后肯定会全部替代为自己的笔记内容，因为文章本身利于阅读，但不能像工具书那样方便查找使用，会有很多冗余的话 一直持续更新到把我的笔记全部放上来，这篇前言才会删除","link":"/2023/06/05/readme/"},{"title":"JsBridge","text":"webview 和 h5 通信原理 Native-&gt;Web调用 直接拼接 js 字串，传给 js 就能动态执行，或者传参，js 拿到后根据对应参数执行相对应的方法 1234567String jsCode = String.format(&quot;window.showWebDialog('%s')&quot;, text);webView.evaluateJavascript(jsCode, new ValueCallback&lt;String&gt;() { @Override public void onReceiveValue(String value) { //拿到返回值 }}); Web-&gt;Native web 传值给 native，并调用 native 里实现的方法 实现原理： web 用 iframe.src 发起请求，安卓用 shouldOverrideUrlLoading 方法拦截 调用 Native 加载 WebView 后，web 发送的所有请求都会经过 WebView 组件，所以 Native 可以重写 WebView 里的方法，从而拦截 web 发起的请求，对请求的 url 格式进行解析即可 安卓端注入全局 js 对象 123456789101112131415161718192021webView.addJavascriptInterface(new NativeBridge(this), &quot;NativeBridge&quot;);class NativeBridge { private Context ctx; NativeBridge(Context ctx) { this.ctx = ctx; } // 增加JS调用接口 @JavascriptInterface public void showNativeDialog(int callbackID) { // 需要注入在Web执行的JS代码 String jsCode = String.format(&quot;window.JSSDK.receiveMessage(%s, '%s')&quot;, callbackID, value); // 在UI线程中执行 mainActivity.runOnUiThread(new Runnable() { @Override public void run() { mainActivity.webView.evaluateJavascript(jsCode, null); } }); }} web 端直接调用 123456789101112window.JSSDK = { window.NativeBridge.showNativeDialog(callbackID);//提前准备个存方法的数据集合，可以根据该集合获取指定方法// 接收Native端传来的callbackId receiveMessage(callbackId, value) { if (callbackMap[callbackId]) { // 根据ID匹配callback，并执行 callbackMap[callbackId](value); } }} function f(){console.log(a)let a = 1}()console.log(a) function f() { console.log(a) var a = 1}()console.log(a) function f() { console.log(a) a = 1}()console.log(a) var a, b(function () { console.log(a); // err console.log(b); // err var a = (b = 3); console.log(a); // 3 console.log(b); // 3})()console.log(a); // 3console.log(b); // 3 var a = 10var obj = { a: 20, say: () =&gt; { console.log(this.a) }}obj.say() //20 var anotherObj = { a: 30 } obj.say.apply(anotherObj) //30 var F = function() {};Object.prototype.a = function() { console.log(‘a’);};Function.prototype.b = function() { console.log(‘b’);}var f = new F();F.a(); // function() { console.log(‘a’);};F.b(); // bf.a(); // function() { console.log(‘a’);};f.b(); // function() { console.log(‘b’);} var F = function() {};Object.prototype.a = function() { console.log(‘a’);};Function.prototype.b = function() { console.log(‘b’);}var f = new F();F.a();F.b();f.a();f.b(); const promise = new Promise((resolve, reject) =&gt; { console.log(1); console.log(2);});promise.then(() =&gt; { console.log(3);});console.log(4);// 1243","link":"/2022/10/05/android/JsBridge/"},{"title":"lint","text":"工程化中怎么进行代码校验 代码规范是前端工程化落地的基石，在其中扮演着监督者的角色，它主要用于约束团队成员的编码规范与编码风格。应用代码规范有三点好处。 强制规范团队编码规范可让新旧成员编码习惯一样 增加项目代码的可维护性与可接入性，新成员能快速适应项目的架构与需求 保障项目整体质量，可减少无用代码、重复代码、错误代码和漏洞代码的产生几率 这一切的实现都离不开代码校验工具中代码格式化的功能。众所周知，基本所有编辑器都会配置代码校验工具(以下简称Lint)检测代码中的错误或漏洞，根据提供的修复方案格式化出正确代码，让代码更严谨。 背景：一次部署全局运行Lint其实就是编辑器中运行的一个脚本进程，将代码解析为抽象语法树，遍历抽象语法树并通过预设规则做一些判断与改动，再将新的抽象语法树转换为正确代码。整个校验过程都跟抽象语法树相关，babel源码或eslint源码可以了解其工作原理。 Lint应该做到 一次部署全局运行。 代码规范很适合使用一次部署全局运行这样的方式处理。若使用该方案，能将所有项目的stylelint/eslint/tslint/prettier相关依赖与配置文件全部删除，使项目结构变得超级简洁。 Tslint官方已宣布废弃tslint，改用eslint代替其所有校验功能 eslint部分配置与prettier部分配置存在冲突且互相影响，为了保障格式化性能就放弃接入prettier 所以VSCode只需安装Stylelint与Eslint两个插件。为了方便理解，统一以下名词。 以下提到的Stylelint与Eslint都为VSCode插件 以下提到的stylelint与eslint都为Npm模块 方案：部署 VSCode 的代码格式化整体配置相比单独为项目接入stylelint与eslint更简单。 安装依赖尽量将依赖更新到最新版本。 12# stylelint及其依赖npm i stylelint stylelint-config-standard stylelint-order postcss-html postcss-scss postcss-less 12# eslint及其依赖npm i @babel/core @babel/eslint-parser @babel/preset-react eslint eslint-config-standard eslint-plugin-html eslint-plugin-import eslint-plugin-n eslint-plugin-promise eslint-plugin-react eslint-plugin-react-hooks eslint-plugin-vue vue-eslint-parser 12# typescript-eslint及其依赖npm i -D @typescript-eslint/eslint-plugin @typescript-eslint/parser typescript eslint-config-standard-with-typescript 安装完毕需配置多份文件，CSS 类型有html/css/scss/less/vue文件，JS 类型有html/js/ts/jsx/tsx/vue文件。查看插件文档，Stylelint的配置文件可同时校验html/css/scss/less/vue文件，Eslint需配置不同文件分别校验html/js/ts/jsx/tsx/vue文件。两个插件可在settings.json中通过指定字段覆盖默认配置。 1settings.json是VSCode的配置文件，用户可通过插件暴露的字段自定义编辑器功能。 因为配置文件太多不好管理，我将这些配置文件整合起来，封装为@yangzw/bruce-std。这样就能跳过上述的依赖安装，执行以下命令安装@yangzw/bruce-std。 1npm i -g @yangzw/bruce-std @yangzw/bruce-std包括以下文件夹。 demo 文件夹 demo：随便捣鼓几个示例用于测试格式化代码 stylelint 文件夹 stylelintrc.js：校验html/css/scss/less/vue文件 eslint 文件夹 ：校验html/js/jsx/vue文件 eslintrc.js：校验html/js文件 eslintrc.react.js：校验html/jsx文件 eslintrc.vue.js：校验html/vue文件 tslint 文件夹 ：校验html/ts/tsx/vue文件(tslint已弃用，使用eslint代替) tsconfig.json：配置TypeScript tslintrc.js：校验html/ts文件 tslintrc.react.js：校验html/tsx文件 tslintrc.vue.js：校验html/vue文件 配置文件中的rules可根据自身编码规范与编码风格适当调整，在此不深入讲述了。推荐使用@yangzw/bruce-std默认规则，若校验规则不喜欢可自行调整。 配置Stylelint可查看Stylelint 规则 配置Eslint可查看Eslint 规则 配置TypeScriptEslint可查看TypeScriptEslint 规则 配置VueEslint可查看VueEslint 规则 配置插件到了配置插件这一步，其实操作不复杂，直接把过程罗列出来，跟着我一步一步完成。 打开VSCode 选择左边工具栏的插件，搜索并安装Stylelint与Eslint，安装完毕重启VSCode 选择文件 → 首选项 → 设置，设置中可选用户或工作区 用户 ：配置生效后会作用于全局项目(若很多项目都是单一的React应用或Vue应用推荐使用全局配置) 工作区 ：配置生效后只会作用于当前打开项目 点击设置右上角中间图标打开设置(json)，打开的对应文件是settings.json 加入以下内容并重启VSCode：为了保障每次改动都能正常格式化代码，必须重启VSCode 1234567891011121314151617181920{ // 默认自定义配置 &quot;css.validate&quot;: false, &quot;less.validate&quot;: false, &quot;scss.validate&quot;: false, &quot;editor.codeActionsOnSave&quot;: { &quot;source.fixAll.eslint&quot;: true, &quot;source.fixAll.stylelint&quot;: true }, // 扩展自定义配置 &quot;eslint.nodePath&quot;: &quot;path/@yangzw/bruce-std/node_modules&quot;, &quot;eslint.options&quot;: { &quot;overrideConfigFile&quot;: &quot;path/@yangzw/bruce-std/eslint/eslintrc.js&quot; // 可变❗ }, &quot;stylelint.configBasedir&quot;: &quot;path/@yangzw/bruce-std&quot;, &quot;stylelint.configFile&quot;: &quot;path/@yangzw/bruce-std/stylelint/stylelintrc.js&quot;, &quot;stylelint.customSyntax&quot;: &quot;postcss-scss&quot;, // 可变❗ &quot;stylelint.stylelintPath&quot;: &quot;path/@yangzw/bruce-std/node_modules/stylelint&quot;, &quot;stylelint.validate&quot;: [&quot;html&quot;, &quot;css&quot;, &quot;scss&quot;, &quot;less&quot;, &quot;vue&quot;]} 上述配置的path为@yangzw/bruce-std模块所在的 Npm 根目录 ，可执行npm config get prefix获取Npm 根目录并替换path。 执行npm config get prefix获取 Npm 根目录 ，例如是E:/Node/prefix/node_modules 将上述配置的path替换为E:/Node/prefix/node_modules 请保持 VSCode 及其所有插件都为最新版本 ，防止因为版本问题导致Stylelint与Eslint失效。 选择配置首先配置Stylelint。校验不同类型代码需实时修改stylelint.customSyntax的值。 CSS/SCSS ：postcss-scss CSS/LESS ：postcss-less HTML/VUE ：postcss-html 其次配置Eslint。校验不同类型代码需实时修改eslint.options.overrideConfigFile的值。 JS ：path/@yangzw/bruce-std/eslint/eslintrc.js React ：path/@yangzw/bruce-std/eslint/eslintrc.react.js Vue ：path/@yangzw/bruce-std/eslint/eslintrc.vue.js TS ：path/@yangzw/bruce-std/tslint/tslintrc.js React TS ：path/@yangzw/bruce-std/tslint/tslintrc.react.js Vue TS ：path/@yangzw/bruce-std/tslint/tslintrc.vue.js 以上述路径E:/Node/prefix/node_modules为例。在默认情况下，Eslint只能校验普通JS。若校验其他JS类型需将eslint.options.overrideConfigFile的path改成以下路径。 React ：E:/Node/prefix/node_modules/@yangzw/bruce-std/eslint/eslintrc.react.js Vue ：E:/Node/prefix/node_modules/@yangzw/bruce-std/eslint/eslintrc.vue.js TS ：E:/Node/prefix/node_modules/@yangzw/bruce-std/tslint/tslintrc.js React TS ：E:/Node/prefix/node_modules/@yangzw/bruce-std/tslint/tslintrc.react.js Vue TS ：E:/Node/prefix/node_modules/@yangzw/bruce-std/tslint/tslintrc.vue.js 示例：一键修复并格式化代码上述步骤操作完毕就可愉快地敲代码了。每次保存文件可自动格式化CSS代码与JS代码，该功能不仅将代码根据规范整理与排序，甚至尽可能根据修复方案格式化出正确的代码。 这样就无需为每个项目配置Lint，将所有项目的stylelint/eslint/tslint/prettier相关依赖与配置文件全部删除，使项目结构变得超级简洁。值得注意，若项目太复杂或太老旧，就不要折腾了，要保持对旧代码的敬畏之心！ html/css/scss/less/vue 文件 html/js/ts/jsx/tsx/vue 文件 答疑：VSCode 细节问题更新 eslint 到 v6+就会失效很多同学反映eslint v6+在VSCode中失效，最高使用版本只能控制在v5.16.0。其实这本身就是配置问题，跟版本无关。@yangzw/bruce-std的eslint使用v8，只要配置正确就能正常使用。 上述安装行为使用了Npm，那settings.json的eslint.packageManager必须配置为npm(小写)，但最新版本Eslint已默认此项，所以无需配置。若执行yarn global add @yangzw/bruce-std，那必须在settings.json中加入以下内容。 123{ &quot;eslint.packageManager&quot;: &quot;yarn&quot;} 首次安装 Eslint 并执行上述配置就会失效首次安装Eslint可能会在js/ts/jsx/tsx/vue文件的控制台中看到以下警告。 1Eslint is disabled since its execution has not been approved or denied yet. Use the light bulb menu to open the approval dialog. 该警告说明Eslint被禁用。虽然配置中无明确的禁用字段，但还是被禁用了。移步到VSCode右下角的工具栏会看到禁用图标+ESLINT的标红按钮，单击它就会弹出一个弹框，选择Allow Everywhere就能启用Eslint的校验功能了。 为何不考虑使用 Prettier首先Eslint是保障JS类型代码的质量工具，该工具必须配置。其次Vscode现在可基于Eslint格式化出正确的代码。既然一个编辑器已内置了格式化代码的功能，为何还要额外引入一个Prettier？ 使用过Eslint与Prettier的同学都知道，两者的标准配置存在冲突状态，那修改Eslint与Prettier哪个配置？反正都得改，改完还得确认。 若基于Eslint使用Vscode内置的格式化功能，那只需专注eslint配置，完全无必要花时间维护Eslint与Prettier的冲突配置啊！ 这些事情仁者见仁智者见智，相信很多同学使用了本方案会喜欢更纯净的eslint配置，而不是Eslint与Prettier合并还要修改冲突这样的配置。 总结若准备接手一个离职同事的代码，而他的代码完全是想写就写无任何规范可言，此刻的你是哪种心情？接着如何解决？ 后续遇到的工程化问题也可借鉴本章思路，将一些具备全局特征的配置分离出来统一管理，利用模块化的特性分离部分构建代码以减少项目结构的复杂度，使得项目更具条理性。 有些同学可能一时适应不了Lint带来的强制性操作会在编辑器中关闭项目所有校验功能，这种自私行为会带来很严重的后果。 若上传无任何校验痕迹的代码块，当其他成员将该代码块更新合并到原有代码后，因为编辑器一直配置着Lint，导致被拉下来的代码块立即报错甚至产生冲突。 不仅让其他成员花费更多时间解决这些额外问题，还浪费了团队的精力。若团队无任何规范可随意编码，若已认可团队规范就请努力遵守，不给团队带来麻烦。 本章内容到此为止，希望能对你有所启发，欢迎你把自己的学习心得打到评论区！","link":"/2023/02/05/engineering/1.%E4%BB%A3%E7%A0%81lint%E6%A0%A1%E9%AA%8C/"},{"title":"仓库管理","text":"仓库管理 当一个仓库规模逐渐升级并拆分为多个模块时，使用Monorepo的方式管理仓库再也适合不过了。这些模块通常在同一仓库中依赖其他不同模块, 同时不同模块间还会互相依赖, 那管理与组织这些依赖显然很重要。 为了解决这些依赖关系，lerna就此诞生。lerna是一种Monorepo解决方案，用于管理包括多个子包的仓库，可优化使用Git与Npm管理多包仓库的工作流程。日常开发可在主仓库中管理多个模块，结合其他工具解决多个子包互相依赖的问题。本章将带领你 基于 Yarn 与 Lerna 搭建多包仓库基建模板 ，将那些仓库内容出现关联的模块统一使用Monorepo的方式管理起来，降低日常开发的沟通难度，提升仓库管理的便利性。 背景：Monorepo 仓库带来的收益lerna诞生于babel的仓库管理模式中，因为babel实在是太多模块了，甚至多到不可管理，就这样促使了lerna的诞生。像平时使用的angular、react、vue、jest等，其仓库都使用lerna管理。 打开它们的仓库，无一例外都是以下目录结构。 1234567891011project├─ lib1│ ├─ src│ └─ package.json├─ lib2│ ├─ src│ └─ package.json├─ lib3│ ├─ src│ └─ package.json└─ package.json 使用基于Monorepo的lerna管理仓库，能为仓库带来更好的收益。 节省存储空间 若一个仓库中多个子包都依赖react与react-dom，在为每个子包安装依赖时会在各自的node_modules文件夹中产生大量冗余的Npm模块。 若使用lerna，会将相同版本的Npm模块提升到仓库根目录中的node_modules文件夹，以降低模块沉积。 解决依赖升级 若一个仓库中多个子包都依赖某一个或多个其他子包X，当X升级版本时需将它们发布到Npm公有仓库，再更新依赖X的子包的依赖，才能将改动的代码应用起来。 若使用lerna，则会直接跳过将X发布到Npm公有仓库的流程，子包可在本地环境直接link到X。 共用同一仓库 若一个仓库中多个子包都因为需求更新而发版，那将引起一堆重复操作，导致每个子包都要走一次提交流程。 若使用lerna，则解决了这些子包的工作流程，就可放心将它们存放到同一仓库中管理了。 其实lerna的最终目标还是围绕着统一工作流程与分割通用代码，毕竟当仓库内容出现关联时，无任何一种调试方式比源码放在一起更高效，而lerna就是解决源码放在一起带来的副作用，使用Monorepo的方式解决这些问题，使多包仓库管理起来更高效。 虽然lerna管理仓库会导致仓库的存储空间变得更大，但其带来的优势也是常见方案不能企及的。 1仓库管理的工作流程包括但不限于构建、测试、打包、发布、部署等流程。 方案：基于 Yarn 与 Lerna 搭建多包仓库基建模板在使用lerna前，一个Multirepo仓库的组织形式可能是这样的。 在使用lerna后，Multirepo仓库就会变成Menorepo仓库，其组织形式就会变成这样。 通过上图基本可判断出使用lerna前后的差异。lerna显式地改变项目结构，把多个子包合并为一个仓库，然后使用packages文件夹存放每个子包，以使用一个仓库管理多个子包。另外还可用lerna提供的命令轻松管理Menorepo仓库，掌握以下命令就能操作lerna。 命令 功能 描述 lerna init 初始项目 lerna boostrap 安装依赖 自动解决子包间的依赖关系 子包内部互相依赖会使用软链接处理 lerna clean 卸载依赖 只能卸载每个子包的node_modules 不能卸载根目录的node_modules lerna create 新增子包 在packages文件夹中创建由lerna管理的子包 lerna add 安装模块 为所有子包安装模块 可通过--scope=pkg安装指定子包模块 | `lerna run","link":"/2023/02/05/engineering/2.%E5%A4%9A%E5%8C%85%E4%BB%93%E5%BA%93/"},{"title":"自动化","text":"怎样使流程自动化 近年来，DevOps在前端领域逐渐火起来，其最大特性是自动化，终极目标就是解放双手。DevOps是一组过程、方法和系统的统称，是Development开发与Operations运维的简写，用于促进技术开发、运营策划和质量保障三个部门间的沟通、协作和整合。 目前而言，DevOps是一种重视软件开发人员与运维技术人员间沟通合作的文化、运动或惯例。透过自动化软件交付与架构变更的流程，使构建、测试、打包、发布和部署变得更快捷、频繁和可靠。它的出现是因为软件行业日益清晰地认识到：为了按时交付软件产品与服务，开发与运维的工作必须紧密合作。整个工作流程都是趋向半自动化，甚至是全自动化。 说到DevOps就必须关联上CI/CD。DevOps与CI/CD紧密相关，是理论与实践的结合，DevOps要实现人员一体化，就必须要借助CI/CD自动化整个流程。说到这，CI/CD是什么？ 持续集成 持续集成又称Continuous Integration，简称CI，指多名开发者在开发不同代码时可频繁地将代码合且互相不影响工作。 持续部署 持续部署又称Continuous Deployment，简称CD，指基于某种工具或平台实现代码自动化的构建、测试、打包、发布和部署。持续部署在某种程度上代表一个开发团队的更新迭代速率。 持续交付 持续交付又称Continuous Delivery，简称CD，指在持续部署的基础上将产品交付到线上环境以实现交付高质量的产品。持续交付是产品价值的一种交付，是产品价值的一种盈利实现。 一个完整的CI/CD包括一个CI与两个CD。通过CI/CD流水线，软件研发可实现从构建、测试、打包、发布和部署甚至整个工程都在流水线中向前推进。一旦将软件研发实施流水线，就可将其部分工作流程或全部工作流程自动化，以加快开发流程并减少错误。简而言之，CI/CD提供的流水线操作使企业更轻松地应对软件的自动快速持续交付。 通过一章内容将整个CI/CD流水线讲述完毕是很不实际的事情，因此本章将基于前面十几章积累下来的示例做一个最终的CI操作，剩下的CI/CD内容将在后续掘金课程《从0到1落地前端架构设计》中接着讲述。本章将带领你 基于 Github 提供的持续集成服务部署一个静态站点 ，熟悉Github Actions与Github Pages的搭配使用，编写配置文件实现提交代码时执行CI操作。 背景：哪些基建流程需部署 CI回想下，经过一段时间的学习，已完成了个人服务器，类库模块、多包仓库、私有仓库和文档站点的搭建与部署。以下将逐一分析，看看哪些基建需部署CI。 个人服务器作为承载CI流水线的底层支持：必须部署 类库模块开发完毕最终会发布到Npm公有仓库或Npm私有仓库，其发布过程可考虑使用CI：考虑部署 多包仓库与类库模块的情况相似，其发布过程可考虑使用CI：考虑部署 私有仓库开发完毕基本不会发生很大变动，它只是作为一个中继托管仓库：无需部署 文档站点在类库模块或多包仓库的版本发生迭代后，必定会更新网站内容：必须部署 考虑到类库模块与多包仓库的发布操作的准确性与安全性必须要有稳定的保障，手动发布可能更稳妥，因此也不考虑部署CI了。 第 5 章选购的服务器只有1核2G，部署CI/CD需搭建Gitlab，但参照Gitlab官方对服务器硬件要求是必须在2核2G以上。我尝试在1核2G的服务器上搭建Gitlab，运行起来不是内存爆掉就是进程崩溃，因此不建议不符合要求的服务器强行搭建Gitlab。若选购的服务器满足条件，可参照掘金课程《从零到一实现一套CI/CD流程》自行搭建。若选购的服务器不满足条件，也无需担心，可选择Github提供的免费持续集成服务Github Actions代替。 当类库模块或多包仓库的版本发生迭代后，就会更新这些版本对应功能的文档内容。更新完毕提交到Github仓库，会触发Webhooks，通过Github Actions监听指定的Webhooks就能触发提前编写好的脚本。 为了让文档站点实现国内外访问分流，国内访问指向服务器部署的CDN，国外访问指向Github部署的Github Pages。该方案的实现，当然是使用Nginx判断了。Github Pages是Github提供的免费静态站点服务。 概念：Github Actions 是什么Github Actions是基于Github的持续集成服务。其提供一台虚拟服务器实例，在该实例中允许通过自定义Actions执行一个或多个命令，以自动地操作代码、构建代码、测试代码、打包代码、发布代码、部署代码、登录远程服务器等。 自定义Actions如何编写？Github官方的Marketplace收集了大量官方与第三方Actions，开发者可自由使用里面的Actions，也可提交自己的Actions。不过Marketplace提供的第三方Actions几乎能满足日常使用，因此挑选与组合里面的Actions就足够了。 概念术语 一个完整的Actions由以下部分组成。 workflow ：工作流程，一个完整且单独运行的持续集成服务 job ：任务，一个或多个job组成一个workflow，一次持续集成服务的运行可完成一个或多个任务 step ：步骤，一个或多个step组成一个job，一个任务的运行由一个或多个步骤根据顺序完成 action ：动作，一个或多个action组成一个step，一个步骤的运行由一个或多个动作根据顺序执行 配置文件 Github Actions的配置文件是workflow文件，必须存放到.gihub/workflows目录中并以&lt;name&gt;.yml的形式命名。 workflow文件可创建多个，文件名称可根据集成服务的功能任意命名，但后续必须使用.yml。当提交代码到Github仓库后，只要发现.gihub/workflows/&lt;name&gt;.yml文件，就会自动挨个文件执行，直至处理完毕所有集成服务。 以下列举一些配置文件的常见字段。 name表示工作名称，若不设置默认为workflow文件的文件名称。若手动完成一个工作流程，会根据顺序执行checkout检出、build构建和deploy部署，因此将工作名称合并简称为CBD。 1name: CBD # 动作名称 on表示触发事件，上述提到的Webhooks可定义一个或多个Webhooks，通常是push与pull_request。Webhooks要指定操作的分支，通常是master或main。 1234on: # 触发条件：在push到main分支后 push: branches: - main jobs表示任务列表，使用对象表示，对象属性表示任务名称，会在Actions的执行时显示。 name ：任务名称 runs-on ：虚拟机环境，可选ubuntu-latest/windows-latest/macos-latest needs ：执行任务的依赖顺序 steps ：执行步骤，每个任务可将需执行的内容划分为不同步骤 name：步骤名称 uses：官方与第三方Actions with：Actions的入参 run：执行命令 env：环境变量 12345678910111213141516jobs: # 任务 cbd: # 任务ID name: doc cbd # 任务名称 runs-on: ubuntu-latest # 虚拟机环境 steps: # 执行步骤 # 拉取代码 - name: Checkout uses: actions/checkout@v2 # 打包文件 - name: Build run: yarn &amp;&amp; yarn run deploy env: AUTHOR: JowayYoung AGE: 29 SEX: male - ... 方案：基于 Github 提供的持续集成服务部署一个静态站点若使用手动部署文档站点，首先检出代码，再执行yarn安装依赖，再执行yarn run deploy生成静态文件，再将文件提交到gh_pages分支上，最后通过Github Pages自动生成静态站点。 了解Github Actions后，接着将基于上述步骤通过Github Actions逐步实现可国内外访问分流的文档站点。 Github Token 与 Actions Secret首先创建 Github Token 。打开Github 设置，点击Developer settings，再点击Personal access tokens，再点击Generate new token。 在Note中输入备注信息，例如GA_TOKEN。在Select scopes中选择repo与workflow。 确定无误后点击Generate token，生成一个Github Token。 不要刷新网页，立即点击复制按钮把该token复制并保存下来，因为刷新网页或重新进入网页，该token会消失，只剩下token名称。 最后创建 Actions Secret 。打开项目仓库地址，点击Settings，再点击Secrets的Actions，再点击New repository secret。 在Name中输入秘钥名称，例如GITHUB_TOKEN。在Value中粘贴上述创建的GA_TOKEN的内容。 确定无误后点击Add secret，生成一个Actions Secret。 在配置文件中可通过{{ secrets.xyz }}的形式读取，xyz为在Name中输入的秘钥名称。 gh-pages 分支Github仓库创建gh-pages分支后会自动部署Github Pages上, 所以利用该特性把生成的静态文件提交到gh-pages分支上就可通过Github Pages自动生成静态站点。 当然该操作无需手动，因为有相关第三方Actions可完成，后续编写配置文件会讲述。为了让Github Pages生效，还需在当前仓库配置。 打开项目仓库地址，点击Settings，再点击Pages，再点击Branch，选择gh-pages。会有root与docs两个文件夹可选，若把文档站点的静态文件放到docs文件夹，则选择docs，否则全部情况选择root。 点击Save，就会通过Github Pages自动生成静态站点了。站点的链接结构为以下形式。 1https://&lt;username&gt;.github.io/&lt;project&gt; 最终bruce的静态站点是jowayyoung.github.io/bruce。 配置文件根据手动部署的流程编写一份Github Actions配置文件。在根目录中创建.github/workflow目录，进入目录创建cbd.yml文件，加入以下内容。 12345678910111213141516171819202122232425262728name: CBDon: push: branches: - mainjobs: cbd: name: doc cbd runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 - name: Build run: yarn &amp;&amp; yarn run deploy - name: DeployGP uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./dist - name: DeployECS - uses: easingthemes/ssh-deploy@v2 - env: ARGS: &quot;-avz --delete&quot; SSH_PRIVATE_KEY: ${{ secrets.ECS_PRIVATE_KEY }} REMOTE_HOST: ${{ secrets.ECS_SERVER_HOST }} REMOTE_USER: ${{ secrets.ECS_REMOTE_USER }} SOURCE: &quot;dist&quot; TARGET: &quot;/www/static/doc/bruce&quot; 整个CI操作只有一个任务cbd，cbd由以下步骤组成。 Checkout ：检出代码，使仓库代码保持最新的状态 Build ：打包文件，先执行yarn安装依赖，再执行yarn run deploy打包文件 DeployGP ：部署文件到Github Pages DeployECS ：部署文件到阿里云的ECS云服务器 checkout是一个官方Actions，用于自动检出最新代码。 actions-gh-pages是一个第三方Actions，用于自动部署代码到Github Pages。入参使用with配置，可查看配置列表。 第 21 章开发的文档站点，执行yarn run deploy会生成一个dist文件夹，该文件夹存放着整个站点的静态文件，所以publish_dir设置为./dist。 ssh-deploy是一个第三方Actions，用于自动部署代码到服务器。入参使用env配置，可查看配置列表。 SSH_PRIVATE_KEY ：SSH 秘钥，登录服务器后可执行ssh-keygen -m PEM -t rsa -b 4096生成 REMOTE_HOST ：服务器主机 REMOTE_USER ：服务器用户 上述三个入参都可通过上述创建Actions Secret的方式生成。 SSH_PRIVATE_KEY指向secrets.ECS_PRIVATE_KEY REMOTE_HOST指向secrets.ECS_SERVER_HOST REMOTE_USER指向secrets.ECS_REMOTE_USER 到此全部步骤完成，每次将代码提交到仓库，就会自动触发cbd.yml配置的CI操作自动执行。打开项目仓库地址，点击Actions，就能看到全部Workflows，点击CBD，就能看到每次提交代码后自动执行的CI操作了。 总结上述操作将手动部署流程转换为自动部署流程，还可尝试接入其他Actions操作其他工作流程，当然这些还是交给你主动去探讨。本章完毕就代表本课程已全部讲述完毕，终章就会与你一起总结本课程以及我对前端工程化的一些感悟与想法。 本章内容到此为止，希望能对你有所启发，欢迎你把自己的学习心得打到评论区！","link":"/2023/02/05/engineering/3.%E6%B5%81%E7%A8%8B%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"title":"Fragment","text":"Fragment 为了提高组件结构灵活性，需要实现 Fragment，具体来说，需要区分几种情况： Fragment 包裹其他组件12345678&lt;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/&gt;// 对应DOM&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt; 这种情况的 JSX 转换结果 123jsxs(Fragment, { children: [jsx(&quot;div&quot;, {}), jsx(&quot;div&quot;, {})],}); type 为 Fragment 的 ReactElement，对单一节点的 Diff 需要考虑 Fragment 的情况。 Fragment 与其他组件同级12345678910111213141516&lt;ul&gt; &lt;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;/&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;// 对应DOM&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt; 这种情况的 JSX 转换结果 1234567891011121314151617181920jsxs(&quot;ul&quot;, { children: [ jsxs(Fragment, { children: [ jsx(&quot;li&quot;, { children: &quot;1&quot;, }), jsx(&quot;li&quot;, { children: &quot;2&quot;, }), ], }), jsx(&quot;li&quot;, { children: &quot;3&quot;, }), jsx(&quot;li&quot;, { children: &quot;4&quot;, }), ],}); children 为数组类型，则进入 reconcileChildrenArray 方法，数组中的某一项为 Fragment，所以需要增加 type 为 Fragment 的 ReactElement 的判断，同时 beginWork 中需要增加 Fragment 类型的判断。 数组形式的 Fragment123456789101112131415// arr = [&lt;li&gt;c&lt;/li&gt;, &lt;li&gt;d&lt;/li&gt;]&lt;ul&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt; {arr}&lt;/ul&gt;// 对应DOM&lt;ul&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt; &lt;li&gt;c&lt;/li&gt; &lt;li&gt;d&lt;/li&gt;&lt;/ul&gt; 这种情况的 JSX 转换结果 1234567891011jsxs(&quot;ul&quot;, { children: [ jsx(&quot;li&quot;, { children: &quot;a&quot;, }), jsx(&quot;li&quot;, { children: &quot;b&quot;, }), arr, ],}); children 为数组类型，则进入 reconcileChildrenArray 方法，数组中的某一项为数组，所以需要增加reconcileChildrenArray 中数组类型的判断。 child reconcile 图解 注 workTag 里 Fragment 是 Fiber 节点的 tag 属性（FiberNode.tag）REACT_FRAGMENT_TYPE 是 ReactElement 的 type 属性（element.type） Fragment 对 ChildDeletion 的影响之前 ChildDeletion 删除 DOM 的逻辑： 找到子树的根 Host 节点 找到子树对应的父级 Host 节点 从父级 Host 节点中删除子树根 Host 节点 比如考虑删除 p 节点的情况： 123&lt;div&gt; &lt;p&gt;xxx&lt;/p&gt;&lt;/div&gt; 现在考虑删除 Fragment 后，子树的根 Host 节点可能存在多个： 123456&lt;div&gt; &lt;&gt; &lt;p&gt;xxx&lt;/p&gt; &lt;p&gt;yyy&lt;/p&gt; &lt;/&gt;&lt;/div&gt; 对 React 的影响React 包需要导出 Fragment，用于 JSX 转换引入 Fragment 类型 纠错当嵌套数组类型 JSX（比如这个Demo时，实现的源码中 updateFromMap 方法中如下代码没有考虑传入的 element 可能为数组形式： 1const keyToUse = element.key !== null ? element.key : index; 导致 element 为数组形式时 keyToUse 为 undefined，进而导致 Fragment 不能复用，造成 bug。 为了解决这个问题，这种情况下可以使用 index 作为 key，修改如下： 12345678910function getElementKeyToUse(element: any, index?: number): Key { if ( Array.isArray(element) || typeof element === &quot;string&quot; || typeof element === &quot;number&quot; ) { return index; } return element.key !== null ? element.key : index;} 详见 fix: fragment array 没有 key","link":"/2023/03/05/react/Fragment/"},{"title":"jests测试调试","text":"jest 使用 jest 调试实现代码包括三部分内容： 实现第一个测试工具 test-utils 实现测试环境 实现 ReactElement 用例 与测试相关的代码都来自 React 仓库，可以先把 React 仓库下载下来： 1git clone git@github.com:facebook/react.git 实现 test-utils这是用于测试的工具集，来源自ReactTestUtils.js，特点是：使用 ReactDOM 作为宿主环境 当需要测试与 ReactDOM 无关或者其他宿主环境的时候，就需要其他的测试工具 实现测试环境1pnpm i -D -w jest jest-config jest-environment-jsdom jest 测试框架主题 jest-config jest 相关的一些默认配置 jest-environment-jsdom 跑 js 代码默认的宿主环境(dom) 配置文件 ./scripts/jest/jest.config.js 1234567891011121314const { defaults } = require(&quot;jest-config&quot;);module.exports = { ...defaults, rootDir: process.cwd(), modulePathIgnorePatterns: [&quot;&lt;rootDir&gt;/.history&quot;], moduleDirectories: [ // 对于 React ReactDOM &quot;dist/node_modules&quot;, // 对于第三方依赖 ...defaults.moduleDirectories, ], testEnvironment: &quot;jsdom&quot;,}; 实现 ReactElement 用例来源自ReactElement-test.js 为 jest 增加 JSX 解析能力，安装 Babel： 1pnpm i -D -w @babel/core @babel/preset-env @babel/plugin-transform-react-jsx 新增 babel.config.js： 1234module.exports = { presets: [&quot;@babel/preset-env&quot;], plugins: [[&quot;@babel/plugin-transform-react-jsx&quot;, { throwIfNamespace: false }]],};","link":"/2023/03/05/react/jest%E6%B5%8B%E8%AF%95%E8%B0%83%E8%AF%95/"},{"title":"diff算法","text":"diff 算法 在之前只实现了单节点的 diff 算法，这里需要实现多节点的 diff 算法 对于 reconcileSingleElement 的改动当前支持的情况： A1 -&gt; B1A1 -&gt; A2 需要支持的情况： ABC -&gt; A 单/多节点是指``更新后是单/多节点` 更细致的，需要区分 4 种情况： key 相同，type 相同 == 复用当前节点 例如：A1 B2 C3 -&gt; A1 key 相同，type 不同 == 不存在任何复用的可能性 例如：A1 B2 C3 -&gt; B1 key 不同，type 相同 == 当前节点不能复用 key 不同，type 不同 == 当前节点不能复用 对于 reconcileSingleTextNode 的改动类似 reconcileSingleElement 对于同级多节点 Diff 的支持单节点需要支持的情况： 插入 Placement 删除 ChildDeletion 多节点需要支持的情况： 插入 Placement 删除 ChildDeletion 移动 Placement 整体流程分为 4 步 将 current 中所有同级 fiber 保存在 Map 中 遍历 newChild 数组，对于每个遍历到的 element，存在两种情况： 在 Map 中存在对应 current fiber，且可以复用 在 Map 中不存在对应 current fiber，或不能复用 判断是插入还是移动 最后 Map 中剩下的都标记删除 步骤 2 —— 是否复用详解首先，根据 key 从 Map 中获取 current fiber，如果不存在 current fiber，则没有复用的可能。 接下来，分情况讨论： element 是 HostText，current fiber 是么？ element 是其他 ReactElement，current fiber 是么？ TODO element 是数组或 Fragment，current fiber 是么？ 1234567891011121314&lt;ul&gt; &lt;li/&gt; &lt;li/&gt; {[&lt;li/&gt;, &lt;li/&gt;]}&lt;/ul&gt;&lt;ul&gt; &lt;li/&gt; &lt;li/&gt; &lt;&gt; &lt;li/&gt; &lt;li/&gt; &lt;/&gt;&lt;/ul&gt; 步骤 3 —— 插入/移动判断详解移动具体是指向右移动 移动的判断依据：element 的 index 与element 对应 current fiber的 index 的比较 A1 B2 C3 -&gt; B2 C3 A1 012_012 当遍历 element 时，当前遍历到的 element一定是所有已遍历的 element中最靠右那个。 所以只需要记录最后一个可复用 fiber在 current 中的 index（lastPlacedIndex），在接下来的遍历中： 如果接下来遍历到的可复用fiber的 index &lt; lastPlacedIndex，则标记 Placement 否则，不标记 移动操作的执行Placement 同时对应： 移动 插入 对于插入操作，之前对应的 DOM 方法是 parentNode.appendChild，现在为了实现移动操作，需要支持 parentNode.insertBefore parentNode.insertBefore 需要找到目标兄弟Host节点，要考虑 2 个因素 可能并不是目标 fiber 的直接兄弟节点 1234567891011// 情况1&lt;A/&gt;&lt;B/&gt;function B() { return &lt;div/&gt;;}// 情况2&lt;App/&gt;&lt;div/&gt;function App() { return &lt;A/&gt;;} 不稳定(自身携带副作用)的 Host 节点不能作为目标兄弟Host节点 不足 不支持数组与 Fragment 12345678910&lt;&gt; &lt;div/&gt; &lt;div/&gt;&lt;/&gt;&lt;ul&gt; &lt;li/&gt; &lt;li/&gt; {[&lt;li/&gt;, &lt;li/&gt;]}&lt;/ul&gt; 可能有未考虑到的边界情况 总结","link":"/2023/03/05/react/diff%E7%AE%97%E6%B3%95/"},{"title":"vite调试代码","text":"代码调试 配置选用 vite 调试代码而不用 webpack 有两点 在开发阶段编译速度快于 webpack vite 插件体系跟 rollup 兼容 vite 强制预编译 根目录下创建 vite 项目： 1pnpm create vite 将 vite.config.js 文件加入 scripts 下 12345678910111213141516171819202122232425262728293031323334import { defineConfig } from &quot;vite&quot;;import react from &quot;@vitejs/plugin-react&quot;;import replace from &quot;@rollup/plugin-replace&quot;;import { resolvePkgPath } from &quot;../rollup/utils&quot;;import path from &quot;path&quot;;export default defineConfig({ plugins: [ react(), replace({ __DEV__: true, preventAssignment: true, }), ], resolve: { alias: [ { find: &quot;react&quot;, replacement: resolvePkgPath(&quot;react&quot;), }, { find: &quot;react-dom&quot;, replacement: resolvePkgPath(&quot;react-dom&quot;), }, { find: &quot;hostConfig&quot;, replacement: path.resolve( resolvePkgPath(&quot;react-dom&quot;), &quot;./src/hostConfig.ts&quot; ), }, ], },}); vite 项目所需启动依赖放入 monorepo 项目依赖中 12345678&quot;devDependencies&quot;: { ..., &quot;typescript&quot;: &quot;^4.9.5&quot;, &quot;@types/react&quot;: &quot;^18.0.28&quot;, &quot;@types/react-dom&quot;: &quot;^18.0.11&quot;, &quot;@vitejs/plugin-react&quot;: &quot;^3.1.0&quot;, &quot;vite&quot;: &quot;^4.2.0&quot;} 配置启动脚本 1&quot;demo&quot;: &quot;vite serve demos/test --config scripts/vite/vite.config.js --force&quot; –force 保证每次执行 demo 都是预编译，不然第一次执行成功后，会将依赖包缓存 TIP如果 vite 热更新失效，可能是因为 书写的React组件不符合规范，可以引入 eslint-plugin-react-refresh插件检查不符合规范的地方。","link":"/2023/03/05/react/vite%E8%B0%83%E8%AF%95%E4%BB%A3%E7%A0%81/"},{"title":"update","text":"update 流程 update 流程与 mount 流程的区别 对于 beginWork： 需要处理 ChildDeletion 的情况 需要处理节点移动的情况（abc -&gt; bca） 对于 completeWork： 需要处理 HostText 内容更新的情况 需要处理 HostComponent 属性变化的情况 对于 commitWork： 对于 ChildDeletion，需要遍历被删除的子树 对于 Update，需要更新文本内容 对于 useState： 实现相对于 mountState 的 updateState beginWork 流程这里仅处理单一节点，所以省去了「节点移动」的情况。需要处理： singleElement singleTextNode 处理流程为： 比较是否可以复用 current fiber a.比较 key，如果 key 不同，不能复用 b.比较 type，如果 type 不同，不能复用 c.如果 key 与 type 都相同，则可复用 不能复用，则创建新的（同 mount 流程），可以复用则复用旧的 注意：对于同一个 fiberNode，即使反复更新，current、wip 这两个 fiberNode 会重复使用 completeWork 流程主要处理标记Update的情况 commitWork 流程对于标记 ChildDeletion 的子树，由于子树中： 对于 FC，需要处理 useEffect unmout 执行、解绑 ref 对于 HostComponent，需要解绑 ref 对于子树的根 HostComponent，需要移除 DOM 所以需要实现遍历ChildDeletion子树的流程 对于 useState需要实现： 针对 update 时的 dispatcher 实现对标 mountWorkInProgresHook 的 updateWorkInProgresHook 实现 updateState 中计算新state的逻辑 其中 updateWorkInProgresHook 的实现需要考虑的问题： hook 数据从哪来？ 交互阶段触发的更新 1&lt;div onClick={() =&gt; update(1)}&gt;&lt;/div&gt; render 阶段触发的更新（TODO） 123456function App() { const [num, update] = useState(0); // 触发更新 update(100); return &lt;div&gt;{num}&lt;/div&gt;;} 总结","link":"/2023/03/05/react/%E5%88%9D%E6%8E%A2update%E6%B5%81%E7%A8%8B/"},{"title":"实现Reconciler架构","text":"实现 react 的 reconciler reconciler 是 React 核心逻辑所在的模块，中文名叫协调器。协调（reconcile）就是 diff 算法的意思。是react 得以运行的核心包(综合协调 react-dom, react, scheduler 各包之间的调用与配合)，管理 react应用状态的输入和结果的输出，将输入信号最终转换成输出信号传递给渲染器。 reconciler 有什么用jQuery 工作原理（过程驱动）： 前端框架结构与工作原理（状态驱动）： 有上述两种工作原理的对比，能得知，框架的原理是通过运行时核心模块，通过输入的内容去调用宿主环境的 API 而以 react 框架为例流程则是： 消费 JSX 没有编译优化 开放通用 API 供不同环境使用 消费 JSX选择核心模块操作的数据结构由前面实现的 JSX 方法可知，JSX 方法的返回结果是一个 ReactElement 元素，但是它作为核心模块操作的数据结构存在一些问题： 无法表达节点之间的关系（ReactElement - ReactElement） 字段有限，不好拓展（比如：无法表达状态） 所以，需要一种新的数据结构，他的特点： 介于 ReactElement 与真实 UI 节点之间 能够表达节点之间的关系 方便拓展（不仅作为数据存储单元，也能作为工作单元） 这就是 FiberNode（虚拟 DOM 在 React 中的实现） reconciler 的工作方式对于同一个节点，通过节点的 FiberNode 跟接点对应的 ReactElement 进行比较，并根据比较的结果生成不同标记（插入、删除、移动…），对应不同宿主环境 API 的执行，然后递归处理子节点 比如，挂载： 1234567// React Element &lt;div&gt;&lt;/div&gt;jsx(&quot;div&quot;);// 对应fiberNodenull;// 生成子fiberNode// 对应标记Placement; 将更新为： 1234567// React Element &lt;p&gt;&lt;/p&gt;jsx(&quot;p&quot;)// 对应fiberNodeFiberNode {type: 'div'}// 生成子fiberNode// 对应标记Deletion Placement 当所有 ReactElement 比较完后，会生成一棵 fiberNode 树，一共会存在两棵 fiberNode 树： current：与视图中真实 UI 对应的 fiberNode 树 workInProgress：触发更新后，正在 reconciler 中计算的 fiberNode 树 双缓冲技术介绍 JSX 消费的顺序DFS 深度优先遍历与 BFS 广度优先遍历详解 以 DFS（深度优先遍历）的顺序遍历 ReactElement，这意味着： 如果有子节点，遍历子节点 如果没有子节点，遍历兄弟节点 例子： 1234&lt;Card&gt; &lt;h3&gt;你好&lt;/h3&gt; &lt;p&gt;Tiny-React&lt;/p&gt;&lt;/Card&gt; 这是个递归的过程，存在递、归两个阶段： 递：对应 beginWork 归：对应 completeWork","link":"/2023/03/05/react/%E5%AE%9E%E7%8E%B0Reconciler%E6%9E%B6%E6%9E%84/"},{"title":"实现JSX","text":"实现 react 的 JSX 解析 React 项目结构： react（宿主环境无关的公用方法） react-reconciler（协调器的实现，宿主环境无关） 各种宿主环境的包 shared（公用辅助方法，宿主环境无关） JSX 属于 react 包 在 packages 目录下创建 react 文件夹，进入文件夹目录 初始化 package.json 在 package.json 中 main 字段描述的是项目入口文件，对应的是 CommonJS 规范，由于打包规范选择的是 rollup，rollup 对应的是 ESM 规范，所以将 main 字段改为 module JSX 转换是什么JSX 转换 playground 在上述图中，左边输入一段 JSX 代码 经过 babel 编译转换成 右侧 React.createElement/_jsx 方法的调用，这个从左侧到右侧转变的过程叫做 JSX 的转换 为什么两种模式下转换后的结果不一样呢？ 可以理解为在 react 17 版本之前，转换结果为 React.createElement，在 17 版本之后转换的结果为 _jsx 12345678import { jsx as _jsx } from &quot;react/jsx-runtime&quot;;/*#__PURE__*/ _jsx(&quot;div&quot;, { children: &quot;123&quot;,});// 或/*#__PURE__*/ React.createElement(&quot;div&quot;, null, &quot;123&quot;); 包括两部分： 编译时 运行时 jsx 方法或 React.createElement 方法的实现（包括 dev、prod 两个环境） 编译时由 babel 编译实现，实现运行时，工作量包括： 实现 jsx 方法 实现打包流程 实现调试打包结果的环境 实现 JSX 方法 jsxDEV 方法（dev 环境） jsx 方法（prod 环境） React.createElement 方法 实现 JSX 打包流程对应上述两 3 方法，打包对应文件： react/jsx-dev-runtime.js（dev 环境） react/jsx-rumtime.js（prod 环境） React 打包流程中需要安装的 rollup plugin 与 node 包： 1pnpm i -D -w rimraf rollup-plugin-generate-package-json rollup-plugin-typescript2 @rollup/plugin-commonjs rimraf 每次打包前删除文件（dist mac os 可以直接使用 rm -rf） rollup-plugin-generate-package-json 打包目录下自动生成 package.json 文件 rollup-plugin-typescript2 打包过程中解析源码中的 typescript 语法 @rollup/plugin-commonjs 解析 commanjs 规范","link":"/2023/03/05/react/%E5%AE%9E%E7%8E%B0JSX/"},{"title":"实现hook架构","text":"实现 hook 架构 架构难点 hook 脱离 FC 上下文，仅仅是普通函数，如何让他拥有感知上下文环境的能力？ hook 怎么知道当前是 mount 还是 update？ 针对问题 1，比如如下情况： 123456function App() { useEffect(() =&gt; { // 执行useState时怎么知道处在useEffect上下文？ useState(0); });} 针对上述两个难点，解决方案 在不同上下文中调用的hook不是同一个函数 不过要知道程序处于那种上下文中只有 reconciler 包中才能知道，但是使用 hooks 函数的时候，都是从 react 包中导入，所以这里还需要再内部实现一个 reconciler - react 包的一个数据共享层，大致如下图 实现「内部数据共享层」时的注意事项 以浏览器举例，Reconciler + hostConfig = ReactDOM 增加「内部数据共享层」，意味着 Reconciler 与 React 产生关联，进而意味着 ReactDOM 与 React 产生关联。 如果两个包「产生关联」，在打包时需要考虑：「两者的代码是打包在一起还是分开？」 如果打包在一起，意味着打包后的 ReactDOM 中会包含 React 的代码，那么 ReactDOM 中会包含一个「内部数据共享层」，React 中也会包含一个「内部数据共享层」，这两者不是同一个「内部数据共享层」。 只想两者共享数据，所以不希望 ReactDOM 中会包含 React 的代码。 需要再 rollup 打包配置文件中进行配置： 1234567// script/rollup/react-dom.config.jsconst { peerDependencies } = getPackageJSON('react-dom');{ ..., external: [...Object.keys(peerDependencies)],} hook 如何知道自身数据保存在哪？ 1234function App() { // 执行useState为什么能返回正确的num？ const [num] = useState(0);} 答案：「可以记录当前正在 render 的 FC 对应 fiberNode，在 fiberNode 中保存 hook 数据」 实现 Hooks 的数据结构fiberNode 中可用的字段： memoizedState updateQueue 对于 FC 对应的 fiberNode，存在两层数据： fiberNode.memoizedState 对应 Hooks 链表 链表中每个 hook 对应自身的数据 实现 useState包括 2 方面工作： 实现 mount 时 useState 的实现 实现 dispatch 方法，并接入现有更新流程内","link":"/2023/03/05/react/%E5%AE%9E%E7%8E%B0hook%E6%9E%B6%E6%9E%84/"},{"title":"noop-renderer","text":"noop-renderer 到目前为止实现的模块： 核心模块：Reconciler 公用方法：React 浏览器宿主环境：ReactDOM 当前项目的问题：测试用例太单薄，无法照顾到项目的边界情况，但内容有限，无法覆盖所有用例 解决办法：构建成熟的 React 测试环境，实现测试工具，按需跑通用例 为了测试 Reconciler，需要构建宿主环境无关的渲染器，这就是 react-noop-renderer 以下是使用 noop-renderer 的一个用例 packages/react-reconciler/src/ tests /ReactEffectOrdering-test.js： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * Copyright (c) Facebook, Inc. and its affiliates. * * This source code is licensed under the MIT license found in the * LICENSE file in the root directory of this source tree. * * @emails react-core * @jest-environment node *//* eslint-disable no-func-assign */&quot;use strict&quot;;let React;let ReactNoop;let Scheduler;let act;let useEffect;describe(&quot;ReactHooksWithNoopRenderer&quot;, () =&gt; { beforeEach(() =&gt; { jest.resetModules(); jest.useFakeTimers(); React = require(&quot;react&quot;); act = require(&quot;jest-react&quot;).act; Scheduler = require(&quot;scheduler&quot;); ReactNoop = require(&quot;react-noop-renderer&quot;); useEffect = React.useEffect; }); test(&quot;passive unmounts on deletion are fired in parent -&gt; child order&quot;, async () =&gt; { const root = ReactNoop.createRoot(); function Parent() { useEffect(() =&gt; { return () =&gt; Scheduler.unstable_yieldValue(&quot;Unmount parent&quot;); }); return &lt;Child /&gt;; } function Child() { useEffect(() =&gt; { return () =&gt; Scheduler.unstable_yieldValue(&quot;Unmount child&quot;); }); return &quot;Child&quot;; } await act(async () =&gt; { root.render(&lt;Parent /&gt;); }); expect(root).toMatchRenderedOutput(&quot;Child&quot;); await act(async () =&gt; { root.render(null); }); expect(Scheduler).toHaveYielded([&quot;Unmount parent&quot;, &quot;Unmount child&quot;]); });}); Noop-Renderer 的实现包括两部分： hostConfig 工厂函数（类似 ReactDOM） 在 ReactDOM 宿主环境的原生节点是 DOM 节点，在 Noop-Renderer 宿主环境包括三类节点： Instance（HostComponent） 1234567const instance = { id: instanceCounter++, type: type, children: [], parent: -1, props,}; TextInstance（HostText） 12345const textInstance = { text: content, id: instanceCounter++, parent: -1,}; Container（HostRoot） 1234const container = { rootID: idCounter++, children: [],}; 对于如下组件： 123456789101112function App() { return ( &lt;&gt; &lt;Child /&gt; &lt;div&gt;hello world&lt;/div&gt; &lt;/&gt; );}function Child() { return &quot;Child&quot;;} 经由 Noop-Renderer 渲染后得到的树状结构如下（对标 DOM 树）： 12345678910111213141516171819202122232425{ &quot;rootID&quot;: 0, &quot;children&quot;: [ { &quot;text&quot;: &quot;Child&quot;, &quot;id&quot;: 0, &quot;parent&quot;: 0 }, { &quot;id&quot;: 2, &quot;type&quot;: &quot;div&quot;, &quot;children&quot;: [ { &quot;text&quot;: &quot;hello world&quot;, &quot;id&quot;: 1, &quot;parent&quot;: 2 } ], &quot;parent&quot;: 0, &quot;props&quot;: { &quot;children&quot;: &quot;hello world&quot; } } ]} 除此以外，还需实现以ReactElement的形式导出树状结构 完善 Reconciler 测试环境需要思考的问题：如何在并发环境测试运行结果？比如： 如何控制异步执行的时间？使用 mock timer 如何记录并发情况下预期的执行顺序？ 完善并发测试环境安装并发的测试上下文环境： 1pnpm i -D -w jest-react 安装 matchers： reactTestMatchers.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546'use strict';const JestReact = require('jest-react');const SchedulerMatchers = require('./schedulerTestMatchers');function captureAssertion(fn) { // Trick to use a Jest matcher inside another Jest matcher. `fn` contains an // assertion; if it throws, we capture the error and return it, so the stack // trace presented to the user points to the original assertion in the // test file. try { fn(); } catch (error) { return { pass: false, message: () =&gt; error.message }; } return { pass: true };}function assertYieldsWereCleared(Scheduler) { const actualYields = Scheduler.unstable_clearYields(); if (actualYields.length !== 0) { throw new Error( 'Log of yielded values is not empty. ' + 'Call expect(Scheduler).toHaveYielded(...) first.' ); }}function toMatchRenderedOutput(ReactNoop, expectedJSX) { if (typeof ReactNoop.getChildrenAsJSX === 'function') { const Scheduler = ReactNoop._Scheduler; assertYieldsWereCleared(Scheduler); return captureAssertion(() =&gt; { expect(ReactNoop.getChildrenAsJSX()).toEqual(expectedJSX); }); } return JestReact.unstable_toMatchRenderedOutput(ReactNoop, expectedJSX);}module.exports = { ...SchedulerMatchers, toMatchRenderedOutput}; schedulerTestMatchers.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293'use strict';function captureAssertion(fn) { // Trick to use a Jest matcher inside another Jest matcher. `fn` contains an // assertion; if it throws, we capture the error and return it, so the stack // trace presented to the user points to the original assertion in the // test file. try { fn(); } catch (error) { return { pass: false, message: () =&gt; error.message }; } return { pass: true };}function assertYieldsWereCleared(Scheduler) { const actualYields = Scheduler.unstable_clearYields(); if (actualYields.length !== 0) { throw new Error( 'Log of yielded values is not empty. ' + 'Call expect(Scheduler).toHaveYielded(...) first.' ); }}function toFlushAndYield(Scheduler, expectedYields) { assertYieldsWereCleared(Scheduler); Scheduler.unstable_flushAllWithoutAsserting(); const actualYields = Scheduler.unstable_clearYields(); return captureAssertion(() =&gt; { expect(actualYields).toEqual(expectedYields); });}function toFlushAndYieldThrough(Scheduler, expectedYields) { assertYieldsWereCleared(Scheduler); Scheduler.unstable_flushNumberOfYields(expectedYields.length); const actualYields = Scheduler.unstable_clearYields(); return captureAssertion(() =&gt; { expect(actualYields).toEqual(expectedYields); });}function toFlushUntilNextPaint(Scheduler, expectedYields) { assertYieldsWereCleared(Scheduler); Scheduler.unstable_flushUntilNextPaint(); const actualYields = Scheduler.unstable_clearYields(); return captureAssertion(() =&gt; { expect(actualYields).toEqual(expectedYields); });}function toFlushWithoutYielding(Scheduler) { return toFlushAndYield(Scheduler, []);}function toFlushExpired(Scheduler, expectedYields) { assertYieldsWereCleared(Scheduler); Scheduler.unstable_flushExpired(); const actualYields = Scheduler.unstable_clearYields(); return captureAssertion(() =&gt; { expect(actualYields).toEqual(expectedYields); });}function toHaveYielded(Scheduler, expectedYields) { return captureAssertion(() =&gt; { const actualYields = Scheduler.unstable_clearYields(); expect(actualYields).toEqual(expectedYields); });}function toFlushAndThrow(Scheduler, ...rest) { assertYieldsWereCleared(Scheduler); return captureAssertion(() =&gt; { expect(() =&gt; { Scheduler.unstable_flushAllWithoutAsserting(); }).toThrow(...rest); });}module.exports = { toFlushAndYield, toFlushAndYieldThrough, toFlushUntilNextPaint, toFlushWithoutYielding, toFlushExpired, toHaveYielded, toFlushAndThrow}; 更新 jest 配置： 12345678910111213141516const { defaults } = require(&quot;jest-config&quot;);module.exports = { ...defaults, modulePathIgnorePatterns: [&quot;&lt;rootDir&gt;/.history&quot;], moduleDirectories: [...defaults.moduleDirectories, &quot;dist/node_modules&quot;], testEnvironment: &quot;jsdom&quot;, moduleNameMapper: { &quot;^scheduler$&quot;: &quot;&lt;rootDir&gt;/node_modules/scheduler/unstable_mock.js&quot;, }, fakeTimers: { enableGlobally: true, legacyFakeTimers: true, }, setupFilesAfterEnv: [&quot;./scripts/jest/setupJest.js&quot;],}; 当前测试做的准备 针对 ReactDOM 宿主环境：ReactTestUtils 针对 Reconciler 的测试：React-Noop-Renderer 针对并发环境的测试：jest-react、Scheduler、React-Noop-Renderer 配合使用","link":"/2023/03/05/react/%E5%AE%9E%E7%8E%B0noop-renderer/"},{"title":"useEffect","text":"useEffect 实现 useEffect 需要考虑的： effect 数据结构 effect 的工作流程如何接入现有流程 effect 数据结构什么是 effect？ 12345678910111213function App() { useEffect(() =&gt; { // create return () =&gt; { // destroy }; }, [xxx, yyy]); useLayoutEffect(() =&gt; {}); useEffect(() =&gt; {}, []); // ...} 数据结构需要考虑： 不同 effect 可以共用同一个机制 useEffect useLayoutEffect useInsertionEffect 需要能保存依赖 需要能保存 create 回调 需要能保存 destroy 回调 需要能够区分是否需要触发 create 回调 mount 时 依赖变化时 1234567const effect = { tag, create, destroy, deps, next,}; 注意区分新增的 3 个 flag： 对于 fiber，新增 PassiveEffect，代表当前fiber本次更新存在副作用 对于 effect hook，Passive 代表useEffect对应effect 对于 effect hook，HookHasEffect 代表当前effect本次更新存在副作用 为了方便使用，最好和其他 effect 连接成链表 render 时重置 effect 链表 数据结构图总结 effect 工作流程 调度副作用调度需要使用Scheduler（调度器），调度器也属于React 项目下的模块 12pnpm i -w schedulerpnpm i -D -w @types/scheduler 收集回调回调包括两类： create 回调 destroy 回调 在线 Demo 12345678910111213141516171819202122232425262728function App() { const [num, updateNum] = useState(0); useEffect(() =&gt; { console.log(&quot;App mount&quot;); }, []); useEffect(() =&gt; { console.log(&quot;num change create&quot;, num); return () =&gt; { console.log(&quot;num change destroy&quot;, num); }; }, [num]); return ( &lt;div onClick={() =&gt; updateNum(num + 1)}&gt; {num === 0 ? &lt;Child /&gt; : &quot;noop&quot;} &lt;/div&gt; );}function Child() { useEffect(() =&gt; { console.log(&quot;Child mount&quot;); return () =&gt; console.log(&quot;Child unmount&quot;); }, []); return &quot;i am child&quot;;} 这意味着需要收集两类回调： unmount 时执行的 destroy 回调 update 时执行的 create 回调 执行副作用本次更新的任何 create 回调都必须在所有上一次更新的 destroy 回调执行完后再执行。 整体执行流程包括： 遍历 effect 首先触发所有 unmount effect，且对于某个 fiber，如果触发了 unmount destroy，本次更新不会再触发 update create 触发所有上次更新的 destroy 触发所有这次更新的 create mount、update 时的区别 mount 时：一定标记 PassiveEffect update 时：deps 变化时标记 PassiveEffect 总结","link":"/2023/03/05/react/%E5%AE%9E%E7%8E%B0useEffect/"},{"title":"事件系统","text":"实现 react 事件系统 事件系统本质上植根于浏览器事件模型，所以他隶属于 ReactDOM，在实现时要做到对 Reconciler 0 侵入。 实现事件系统需要考虑： 模拟实现浏览器事件捕获、冒泡流程 实现合成事件对象 方便后续扩展(不同事件，不同优先级) 实现 ReactDOM 与 Reconciler 对接将事件回调保存在 DOM 中，通过以下两个时机对接： 创建 DOM 时 更新属性时 模拟实现浏览器事件流程","link":"/2023/03/05/react/%E5%AE%9E%E7%8E%B0%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"title":"同步调度流程","text":"同步调度流程 更新到底是同步还是异步？ 1234567class App extends React.Component { onClick() { this.setState({ a: 1 }); console.log(this.state.a); } // ...省略其他代码} 当前的现状： 从触发更新到 render，再到 commit 都是同步的 多次触发更新会重复多次更新流程 可以改进的地方：多次触发更新，只进行一次更新流程 Batched Updates（批处理）：多次触发更新，只进行一次更新流程 将多次更新合并为一次，理念上有点类似防抖、节流，需要考虑合并的时机是： 宏任务？ 微任务？ 用三款框架实现 Batched Updates，打印结果不同： React Vue3 Svelte 结论：React 批处理的时机既有宏任务，也有微任务（Vue3 和 Svelte 都是微任务） 新增调度阶段既然要多次触发更新，只进行一次更新流程，意味着要将更新合并，所以在： render 阶段 commit 阶段 的基础上增加schedule阶段（调度阶段） 对 update 的调整多次触发更新，只进行一次更新流程中多次触发更新意味着对于同一个 fiber，会创建多个 update： 123456const onClick = () =&gt; { // 创建3个update updateCount((count) =&gt; count + 1); updateCount((count) =&gt; count + 1); updateCount((count) =&gt; count + 1);}; 多次触发更新，只进行一次更新流程，意味着要达成 3 个目标： 需要实现一套优先级机制，每个更新都拥有优先级 需要能够合并一个宏任务/微任务中触发的所有更新 需要一套算法，用于决定哪个优先级优先进入 render 阶段 实现 Lane 模型采用二进制位表示 Lane 可以更方便的表示不同 Lane 的集合 Lane 模型包括： lane（二进制位，代表 update 优先级） lanes（二进制位，代表 lane 的集合） lane 的产生对于不同情况触发的更新，产生 lane。为后续不同事件产生不同优先级更新做准备。 如何知道哪些 lane 被消费，还剩哪些 lane 没被消费？ 对 FiberRootNode 的改造： 需要增加如下字段： 代表所有未被消费的 lane 的集合 （pendingLanes） 代表本次更新消费的 lane （finishedLane） 大致流程图如下： 实现调度阶段 实现某些判断机制，选出一个 lane 实现类似防抖、节流的效果，合并宏/微任务中触发的更新 大致流程图： render 阶段的改造processUpdateQueue 方法消费 update 时需要考虑： lane 的因素 update 现在是一条链表，需要遍历 commit 阶段的改造移除本次更新被消费的lane 总结","link":"/2023/03/05/react/%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B/"},{"title":"并发更新","text":"并发更新 要实现并发更新，需要做的改动包括： Lane 模型增加更多优先级 交互与优先级对应 调度阶段引入 Scheduler，新增调度策略逻辑 render 阶段可中断 根据 update 计算 state 的算法需要修改 扩展交互(优先级)不同交互对应不同优先级，可以根据触发更新的上下文环境赋予不同优先级，比如： 点击事件需要同步处理 滚动事件优先级再低点 useEffect create 回调中触发更新的优先级 首屏渲染的优先级 … 不同的优先级影响不同的 Update 从而影响更新（渲染） 不过现在掌握与优先级相关的信息包括： Scheduler 的 5 种优先级 React 中的 Lane 模型 也就是说，运行流程在 React 时，使用的是 Lane 模型，运行流程在 Scheduler 时，使用的是优先级。所以需要实现两者的转换： lanesToSchedulerPriority schedulerPriorityToLane 扩展调度阶段主要是在同步更新（微任务调度）的基础上扩展并发更新（Scheduler 调度），主要包括： 将并发原理中的调度策略移到项目中 render 阶段变为可中断 梳理两种典型场景： 时间切片 高优先级更新打断低优先级更新 扩展 state 计算机制上文提到不同的 lane 影响不同的 Update 从而影响更新，而每个 Update 又会计算生成 state 所以，Update 计算 state 这一环节就会做一下事情： 高优先级任务打断低优先级任务时，跳过优先级不够的 Update 保存跳过的 Update 跳过 update 需要考虑的问题比较优先级是否足够 =&gt; 位运算 &amp; 计算 renderLane 和 LupdateLane 如何同时兼顾 update 的连续性与 update 的优先级 ？ 12345678910111213141516171819// u0{ action: num =&gt; num + 1, lane: DefaultLane}// u1{ action: 3, lane: SyncLane}// u2{ action: num =&gt; num + 10, lane: DefaultLane}// state = 0; updateLane = DefaultLane// 只考虑优先级情况下的结果：11// 只考虑连续性情况下的结果：13 新增 baseState、baseQueue 字段来兼顾 update 的连续性与 update 的优先级 baseState 是本次更新参与计算的初始 state，memoizedState 是上次更新计算的最终 state 如果本次更新没有 update 被跳过，则下次更新开始时 baseState === memoizedState 如果本次更新有 update 被跳过，则本次更新计算出的 memoizedState 为考虑优先级情况下计算的结果，baseState 为 最后一个没被跳过的 update 计算后的结果 ，下次更新开始时 baseState !== memoizedState 本次更新被跳过的 update 及其后面的所有 update 都会被保存在 baseQueue 中参与下次 state 计算 本次更新 参与计算但保存在 baseQueue 中的 update ，优先级会降低到 NoLane 12345678910111213141516171819202122232425262728293031323334353637383940// u0{ action: num =&gt; num + 1, lane: DefaultLane}// u1{ action: 3, lane: SyncLane}// u2{ action: num =&gt; num + 10, lane: DefaultLane}/** 第一次render* baseState = 0; memoizedState = 0;* baseQueue = null; updateLane = DefaultLane;* 第一次render 第一次计算* baseState = 1; memoizedState = 1;* baseQueue = null;* 第一次render 第二次计算* baseState = 1; memoizedState = 1;* baseQueue = u1;* 第一次render 第三次计算* baseState = 1; memoizedState = 11;* baseQueue = u1 -&gt; u2(NoLane);*//** 第二次render* baseState = 1; memoizedState = 11;* baseQueue = u1 -&gt; u2(NoLane); updateLane = SyncLane* 第二次render 第一次计算* baseState = 3; memoizedState = 3;* 第二次render 第二次计算* baseState = 13; memoizedState = 13;*/ 所以： react 分多次计算，每次计算都可以兼顾优先级，总体计算兼顾连续性 中间可能会产生不符合预期的中间状态（只兼顾优先级） react 只能保证结果状态兼顾连续性和优先级","link":"/2023/03/05/react/%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E6%9B%B4%E6%96%B0/"},{"title":"并发更新原理","text":"并发更新原理 当前的实现是如何驱动的？ 交互触发更新（createUpdate） 调度阶段微任务调度（ensureRootIsScheduled 方法） 微任务调度结束，进入 render 阶段 render 阶段结束，进入 commit 阶段 commit 阶段结束，调度阶段微任务调度（ensureRootIsScheduled 方法） 整体是个大的微任务循环，循环的驱动力是微任务调度模块 同步示例 示例在两种情况下会造成阻塞： work.count 数量太多 单个 work.count 工作量太大 并发更新的理论基础并发更新的基础是时间切片,将可能会出现掉帧的长宏任务，切成不会影响页面渲染短的宏任务 在线示例 改造示例如果想在宏任务中完成任务调度，本质上是个大的宏任务循环，循环的驱动力是 Scheduler 理论基础参考《React 设计原理》 在微任务调度中，没有优先级的概念，对于 Scheduler 存在 5 种优先级： ImmediatePriority（同步优先级） UserBlockingPriority（点击事件等） NormalPriority（正常优先级 ） LowPriority（低优先级） IdlePriority（空闲时优先级） 需要考虑的情况： 工作过程仅有一个 work 如果仅有一个 work，Scheduler 有个优化路径：如果调度的回调函数的返回值是函数，则会继续调度返回的函数 工作过程中产生相同优先级的 work 如果优先级相同，则不需要开启新的调度 工作过程中产生更高/低优先级的 work 把握一个原则：每次选出的都是优先级最高的 work","link":"/2023/03/05/react/%E5%B9%B6%E5%8F%91%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86/"},{"title":"项目初始化","text":"源码构建的开始 项目结构Multi-repo 和 Mono-repo 该如何选择？ Multi-repo 每个库有自己独立的仓库，逻辑清晰，相对应的，协同管理会更繁琐。 Mono-repo 可以很方便的协同管理不同独立的库的生命周期，相对应的，会有更高的操作复杂度。 参考资料：现代前端工程为什么越来越离不开 Monorepo? Mono-repo 技术选型 简单工具 npm workspace yarn workspace pnpm workspace 专业工具 nx bit turborepo rush.js lerna 选用 pnpm 相比其他打包工具的优势： 依赖安装快 更规范（处理幽灵依赖问题） 参考资料：pnpm 是凭什么对 npm 和 yarn 降维打击的？ pnpm 初始化12npm install -g pnpmpnpm init 根目录下创建 pnpm-workspace.yaml 文件 初始化 pnpm-workspace.yaml 定义开发规范代码规范检查与修复代码规范：eslint 安装 12// Mono-repo 的项目代码工具需要安装在根目录下 -w 就是意思就是安转载根目录下pnpm i eslint -D -w 初始化 1npx eslint --init 新建 .eslintrc.json 配置如下： 12345678910111213141516171819202122232425{ &quot;env&quot;: { &quot;browser&quot;: true, &quot;es2021&quot;: true, &quot;node&quot;: true }, &quot;extends&quot;: [ &quot;eslint:recommended&quot;, &quot;plugin:@typescript-eslint/recommended&quot;, &quot;prettier&quot;, &quot;plugin:prettier/recommended&quot; ], &quot;parser&quot;: &quot;@typescript-eslint/parser&quot;, &quot;parserOptions&quot;: { &quot;ecmaVersion&quot;: &quot;latest&quot;, &quot;sourceType&quot;: &quot;module&quot; }, &quot;plugins&quot;: [&quot;@typescript-eslint&quot;, &quot;prettier&quot;], &quot;rules&quot;: { &quot;prettier/prettier&quot;: &quot;error&quot;, &quot;no-case-declarations&quot;: &quot;off&quot;, &quot;no-constant-condition&quot;: &quot;off&quot;, &quot;@typescript-eslint/ban-ts-comment&quot;: &quot;off&quot; }} 安装 ts 的 eslint 插件： 1pnpm i -D -w @typescript-eslint/eslint-plugin 代码风格：prettier 安装： 1pnpm i prettier -D -w 新建 .prettierrc.json 配置文件，添加配置： 123456789{ &quot;printWidth&quot;: 80, &quot;tabWidth&quot;: 2, &quot;useTabs&quot;: true, &quot;singleQuote&quot;: true, &quot;semi&quot;: true, &quot;trailingComma&quot;: &quot;none&quot;, &quot;bracketSpacing&quot;: true} prettier 可能会与 eslint 规则冲突，所以需要将 prettier 集成到 eslint 中，其中： eslint-config-prettier：覆盖 ESLint 本身的规则配置 eslint-plugin-prettier：用 Prettier 来接管修复代码即 eslint –fix 1pnpm i eslint-config-prettier eslint-plugin-prettier -D -w 为 lint 增加对应的执行脚本，并验证效果： 1&quot;lint&quot;: &quot;eslint --ext .js .ts,.jsx,.tsx --fix --quiet ./packages&quot; 验证成功后，安装 prettier 与 eslint 的 VSCode 插件，并在 setting 中设置为保存后自动执行。 commit 规范检查安装 husky，用于拦截 commit 命令： 1pnpm i husky -D -w 初始化 husky： 1npx husky install 将刚才实现的格式化命令 pnpm lint 纳入 commit 时 husky 将执行的脚本： 1npx husky add .husky/pre-commit &quot;pnpm lint&quot; 注 pnpm lint 会对代码全量检查，当项目复杂后执行速度可能比较慢，届时可以考虑使用 lint-staged (opens new window)，实现只对暂存区代码进行检查 通过 commitlint 对 git 提交信息进行检查，首先安装必要的库： 1pnpm i commitlint @commitlint/cli @commitlint/config-conventional -D -w 新建配置文件 .commitlintrc.js ： 123module.exports = { extends: [&quot;@commitlint/config-conventional&quot;],}; 集成到 husky 中： 1npx husky add .husky/commit-msg &quot;npx --no-install commitlint -e $HUSKY_GIT_PARAMS&quot; conventional 规范集意义： 12// 提交的类型: 摘要信息&lt;type&gt;: &lt;subject&gt; 常用的 type 值包括如下: feat: 添加新功能 fix: 修复 Bug chore: 一些不影响功能的更改 docs: 专指文档的修改 perf: 性能方面的优化 refactor: 代码重构 test: 添加一些测试代码等等 配置 tsconfig.json ： 123456789101112131415161718192021{ &quot;compileOnSave&quot;: true, &quot;compilerOptions&quot;: { &quot;target&quot;: &quot;ESNext&quot;, &quot;useDefineForClassFields&quot;: true, &quot;module&quot;: &quot;ESNext&quot;, &quot;lib&quot;: [&quot;ESNext&quot;, &quot;DOM&quot;], &quot;moduleResolution&quot;: &quot;Node&quot;, &quot;strict&quot;: true, &quot;sourceMap&quot;: true, &quot;resolveJsonModule&quot;: true, &quot;isolatedModules&quot;: true, &quot;esModuleInterop&quot;: true, &quot;noEmit&quot;: true, &quot;noUnusedLocals&quot;: true, &quot;noUnusedParameters&quot;: true, &quot;noImplicitReturns&quot;: false, &quot;skipLibCheck&quot;: true, &quot;baseUrl&quot;: &quot;./packages&quot; }} 选择打包工具比较不同打包工具的区别 参考资料：Overview | Tooling.Report (opens new window) 要开发的项目的特点： 是库，而不是业务项目 希望工具尽可能简洁、打包产物可读性高 原生支持 ESM 所以选择 rollup，安装： 1pnpm i -D -w rollup 根目录新建 script 文件用于存放项目所有脚本文件，在新建 rollup 文件存放对应 rollup 代码","link":"/2023/03/05/react/%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"title":"状态更新机制","text":"状态更新机制 在 React 中，常见的触发更新的方式有： ReactDOM.createRoot().render（或老版的 ReactDOM.render ） this.setState useState 的 dispatch 方法 希望实现一套统一的更新机制（将上述更新方式接入同一套机制中），他的特点是： 兼容上述触发更新的方式 方便后续扩展（优先级机制…） 实现状态更新机制更新机制的组成部分 代表更新的数据结构 —— Update 消费 update 的数据结构 —— UpdateQueue 他们的关系如下图： 接入状态更新机制更新分为 mount 和 update 两种，需要实现 ReactDOM.createRoot().render 第一次 mount 时调用的 API，并将 API 接入上述更新机制中 需要考虑的事情： 更新可能发生于任意组件，而更新流程是从根节点递归的 需要一个统一的根节点保存通用信息 初探 mount 流程更新流程的目的： 生成 wip fiberNode 树 标记副作用 flags 更新流程的步骤： 递：beginWork 归：completeWork beginWork对于如下结构的 reactElement： 123&lt;a&gt; &lt;b /&gt;&lt;/a&gt; 当进入 A 的 beginWork 时，通过对比 B current fiberNode 与 B reactElement，生成 B 对应 wip fiberNode。 在此过程中最多会标记 2 类与结构变化相关的 flags： Placement 12插入： a -&gt; ab移动： abc -&gt; bca ChildDeletion 1删除： ul&gt;li*3 -&gt; ul&gt;li*1 beginWork 不包含与「属性变化」相关的 flag：Update 1&lt;img title=&quot;鸡&quot; /&gt; -&gt; &lt;img title=&quot;你太美&quot; /&gt; 实现与 Host 相关节点的 beginWork首先，为开发环境增加DEV标识，方便 Dev 包打印更多信息： 1pnpm i -d -w @rollup/plugin-replace HostRoot =&gt; 计算状态最新值 创建子 fiberNode HostComponent =&gt; 创建子 fiberNode HostTest =&gt; 因为无子节点 无需处理 beginWork 性能优化策略考虑如下结构的 reactElement： 1234&lt;div&gt; &lt;p&gt;练习时长&lt;/p&gt; &lt;span&gt;两年半&lt;/span&gt;&lt;/div&gt; 理论上 mount 流程完毕后包含的 flags： 两年半 Placement span Placement 练习时长 Placement p Placement div Placement 相比于执行 5 次 Placment，可以构建好「离屏 DOM 树」后，对 div 执行 1 次 Placement 操作 completeWork需要解决的问题： 对于 Host 类型 fiberNode：构建离屏 DOM 树 标记 Update flag（TODO） completeWork 性能优化策略flags 分布在不同 fiberNode 中，如何快速找到他们？ 答案：利用 completeWork 向上遍历（归）的流程，将子 fiberNode 的 flags 冒泡到父 fiberNode commit 阶段回顾上面可知道 react 内部有 3 个阶段 schedule 阶段 render 阶段（beginWork completeWork） commit 阶段（commitWork） 而 commit 阶段的还有 3 个子阶段 beforeMutation 阶段 mutation 阶段 layout 阶段 当前 commit 阶段要执行的任务： fiber 树的切换 执行 Placement 对应操作（暂时实现）","link":"/2023/03/05/react/%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6/"},{"title":"关于react","text":"简单对比 react、vue，并理解 react 框架原理概括1.React 是库 (library) 还是框架 (framework) ? 2.Vue 号称是 构建用户界面的渐进式框架，怎么理解渐进式？ 不管是 React 还是 Vue，他们的核心都是 构建UI的库，由以下两部门组成 基于状态的声明式渲染 组件化的层次结构 随着应用复杂程度的提升，需要对不同的需求进行扩展，也有了不同的解决方案，如 状态管理的难度升级 =&gt; Redux Pinia Vuex 简单页面升级为 SPA（Single Page Application）=&gt; React-Router Vue-Router 提高首屏渲染速度、满足 SEO =&gt; SSR（Server Side Render） 除上面提到的功能外，还有许多功能是 React 与 Vue 本身不包括的，比如构建支持、数据流方案、文档工具等。 所以，React 与 Vue 本身仅仅是库，而不是框架 可以称 “包含库本身以及附加功能” 的解决方案称为框架，例如 UmiJS 是一款基于 React，内置路由、构建、部署等功能的前端框架 Next.js 是一款基于 React,支持 SSR、SSG（Static Site Generation，静态页面构建）的服务端框架 AngularJS 是一款内置多种功能的前端框架 总结： React 与 Vue 本身仅仅是库，而不是框架 Vue 的 “渐进式” 是指 “可以按照需求渐进地引入附加功能”，而不是像 AngularJS 一样开箱即用 初识前端框架几乎所有现代前端框架的实现原理都可以用一下公式替代 UI = f (state) state 代表 当前视图状态 f 代表 框架内部运行机制 UI 代表 宿主环境的视图 描述 UIJSXReact 团队认为 “UI 本质上与逻辑存在耦合的部分” 例如 在 UI 上绑定事件 在状态变化后改变 UI 的样式或结构 由于前端工程师使用 ES 编写逻辑，因此同样可以使用 ES 描述 UI，即可使用 UI 与逻辑配合更密切。至于最终方案设计为 类XML 的 ES 语法糖，则是因为前端工程师更熟悉 HTML。 高灵活性意味着 JSX 需要牺牲 潜在的编译时优化空间 模版语言在原有 HTML 语法的基础上添加了自定义语法。 比如 Vue 的 v-if、v-show、v-for，{{}} 等。 本质是通过扩展 HTML 元素属性实现各种逻辑，这么做的好处是合法的 HTML 语法，可以直接在浏览器中正常直接显示 ”未替换的原始模版页面“。 总结 JSX 的出发点使用 ES 描述逻辑，就扩展 ES 语法，使它能够描述 UI，即 ”从逻辑出发扩展逻辑，描述 UI“ 模版语法 的出发点使用 HTML 描述 UI，那就扩展 HTML,使它能够描述逻辑，即 ”从 UI 出发,扩展 UI，描述逻辑“ 如何组织 UI 与逻辑为了实现 UI 与逻辑的关注点分离，需要一种存放 UI 与逻辑的松散耦合单元，这就是组件 关于组件有两个很重要的问题需要解释 组件如何组织逻辑与 UI 如何在组件之间传输数据 这里借助初中数学知识 “自变量与因变量”,如 2x + 1 = y x 的变化会导致 y 的变化，其中 x 被称为自变量，y 被称为因变量 定义自变量可以用 useState hooks =&gt; const [number, setNumber] = useState(0) 而在前端框架中，因变量又有两种类型： 无副作用因变量 =&gt; useMemo(() =&gt; 2x, [x]) (对应处理逻辑) 有副作用因变量 =&gt; useEffect(() =&gt; { document.title = x.value }, [x] ) (对应处理逻辑) 那么可以得出组件内部工作流程如下图： 综上所述，组件通过三种方式组织逻辑与 UI 逻辑中的自变量变化，导致 UI 变化 逻辑中的自变量变化，导致 ”无副作用因变量“ 变化，导致 UI 变化 逻辑中的自变量变化，导致 ”有副作用的因变量“ 变化， 导致 UI 变化 如何在组件之间传输数据 React.createContext =&gt; context / context.provider useContext props store（Redux、Mobx、Pinia） 前端框架的分类依据由上述的出的公式 UI = *f*(state) 可以知道，state（自变量）,是通过直接或者间接（因变量）的方式改变 UI，而这里的 UI 仅仅是 ”对实际宿主环境 UI 的描述“，并不是实际宿主环境 UI。 比如 1const header = &lt;h1&gt;Hello World&lt;/h1&gt;; 上述代码只是对 ”对宿主环境 UI 的描述“，通过框架处理后，在宿主环境（比如浏览器）中显示的 H1 样式的 Hello World 才是 ”真实的 UI“ 所以公式可以拆解为一下两步： 根据自变量（state）变化计算出 UI 变化 根据 UI 变化执行具体的宿主环境 API （比如浏览器 DOM API） 对于步骤 2，不同的前端框架的实现基本一致，差异性主要体现在步骤 1 上，所以前端框架主要需要关注 “自变量与 x 的对应关系”。 随着 x 抽象层级不同不断下降，”自变量到 UI 变化“ 的路径越多，就意味着前端框架在运行时消耗在寻找 ”自变量与 UI 的对应关系“ 上的时间越少 根据 ”与自变量建立对应关系的抽象层级“ 作为其分类依据，前端框架可以分为以下三类 应用级框架 =&gt; React 组件级框架 =&gt; Vue 元素级框架 =&gt; Solid React 中的自变量与因变量 useState useReducer useContext useMemo =&gt; 采用缓存的方式 =&gt; 无副作用因变量 useCallback =&gt; 采用缓存的方式 =&gt; 无副作用因变量 =&gt; 缓存值为函数形式 useEffect =&gt; 有副作用因变量 useRef =&gt; 让 UI 与逻辑之间更灵活 前端框架使用的技术细粒度更新在 Vue 和 Mobx 中使用的 ”能自动追踪依赖的技术“ 被称为 ”细粒度更新“（Finegrained Reactivity），这不是一项新技术，KnockoutJS 曾今在 2010 年采用这种技术实现 ”响应式更新“ 这种 ”响应式更新“ 相比 React Hooks 有两个显著优点 无需显示指明依赖 由于可以自动跟踪依赖，因此不受 React Hooks ”不能再条件语句中声明 Hooks“ 的限制 那么为什么 React Hooks 没有使用细粒度更新呢？ 原因是 React 属于应用级框架，从关注 ”自变量与应用的对应关系“ 角度看，其更新粒度不需要很细，因此无需使用细粒度更新。作为代价，React Hooks 在使用上则会受到以上两个优点相对应的限制 AOT现代框架都需要 ”编译“ 这一步骤，用于： 将 ”框架中描述的 UI“ 转换为宿主环境可识别的代码 代码转化，比如将 ts 编译为 js、实现 polyfill 等 执行一些编译时优化 代码打包、压缩、混淆 ”编译“ 可选择两个时机执行 代码在构建时，被称为 AOT（Ahead Of Time 提前编译或预编译），宿主环境获得的是编译后的代码 代码在宿主环境执行时，被称为 JIT （Just In Time 即时编译），代码在宿主环境中编译并执行 AOT 与 JIT 的区别包括 AOT 编译报错，JIT 宿主环境运行报错 使用 JIT 的应用 首次加载慢于 AOT 的应用，因为其需要先编译代码，AOT 的应用已经在构建时完成编译，可以直接执行代码 使用 JIT 的应用 代码体积可能大于 使用 AOT 的应用，因为运行时会增加编译器代码 借助 AOT 对模版语法编译时的优化，可以减少之前提到公式工作原理的第一步 根据自变量变化计算出 UI 变化。这是大部分 ”采用模版语法描述 UI “的前端框架都会进行的优化，如 Vue3、Angular、Svelte，因为模版语法是固定的，固定意味着 可分析，可分析 意味着在编译时可以标记模版语法静态部分与动态部分，使步骤 1 在寻找 “变化的 UI” 时可以跳过静态部分。 注 AOT 能够在多大程度上减少步骤 1（根据自变量变化计算出 UI 变化）视框架实现细节不同而不同 可是 “采用 JSX 描述 UI” 的前端框架则难以 AOT 中收益，原因在于 JSX 是 ES 的语法糖，ES 语句的灵活性使其很难进行静态分析 不过有两个思路可以使 “使用 JSX 描述 UI” 的前端框架在 AOT 中收益 使用新的 AOT 实现 约束 JSX 的灵活性 不过 Meta 正在开发的 React Forget 编译器试图来解决这方面问题 Virtual DOMVirtual DOM 是实现 “根据自变量变化计算出 UI 变化” 的一种主流技术，其工作原理可以概括为两个步骤： 将 ”元素描述的 UI“ 转化为 ”VDOM 描述的 UI“ 对比变化前后 ”VDOM 描述的 UI“，计算出 UI 中发生变化的部分 VDOM 细节上 Vue 和 React 又有一些区别 Vue：使用 模版语法 描述 UI，模版语法变异为 render 函数1.render 函数执行后返回 ”VNode 描述的 UI“ =&gt; render 2.将变化前后 ”VNode 描述的 UI“ 进行比较，计算出 UI 中变化的部分 =&gt; patch React：使用 JSX 描述 UI，JSX 编译为 createElement 方法 createElement 方法执行后返回 ”React Element 描述的 UI“ 将 ”React Element 描述的 UI“ 与变化前 ”FiberNode 描述的 UI“ 进行比较，计算出 UI 中变化的部分，同时生成本次更新 ”FiberNode 描述的 UI“ VDOM 的主要优点： 相较于 DOM 的体积优势 (DOM 包含大量冗余的属性) 相较于 AOT 更强大的描述能力 多平台渲染的抽象能力 前端框架的实现原理 Svelte：借由模版语法的约束，经过 AOT 的编译优化，直接建立 “自变量与元素的对应关系” Vue3：通过 watchEffect 与自变量形成发布订阅关系，自变量变化触发 render 函数通过 patch 与 prevVDOM 进行对比更新，建立在 ”自变量与组件的对应关系“ React：改变自变量 =&gt; reconcile(VDOM 相关操作) =&gt; commit，每次更新都是从应用的根节点开始遍历整个应用 虽然 React 每次遍历整个应用，但是性能并不会很差，一方面 React 内部有优化机制(优先级调度、Time Slice、Hooks、Suspense)，另一方面 React 提供了相关 API 来减少无意义的遍历，比如 shouldComponentsUpdate、React.Memo、PureComponent 从 ”编译时或者运行时“ 的角度看待框架 Svelte 是极致的编译时框架 React 是极致的运行时框架 Vue3 同时拥有两者的特性（AOT 和 VDOM），比较均衡","link":"/2023/03/05/react/%E7%90%86%E8%A7%A3react/"},{"title":"写在前面","text":"学习前可能先看这个比较好 我也是在整理笔记的时候看到，就目前主流看来，webcomponents 开发的框架选型，svelte 是优于 stencil 的，我自己看到也是有点沮丧的，谁都不希望自己所学所用的技术被淘汰，但是前沿技术，尤其是框架这块是不可避免的，所以还是掌握 webcomponent 原生原理会更好，框架嘛，谁好就用谁，只是可怜我这些笔记了，突然不太想加这块笔记到博客 来读博客准备 webcomponent 开发的我还是推荐使用 svelte 吧，我稍微看了下对比，他的体积优化、性能的确高上不少，后面有空再出 svelte 博客吧，tencil 我把笔记挪过来大概率就不会更新了，除非哪天有了突破性的进展","link":"/2023/08/09/stencil/%E5%89%8D%E8%A8%80/"},{"title":"","text":"","link":"/2023/08/07/stencil/%E6%80%BB%E8%A7%88%E5%9B%BE/"},{"title":"AST","text":"摄像头和麦克风属于用户的隐私设备，WebRTC既然成为了浏览器中音视频即时通信的W3C标准，因此必然会提供API，让有一定代码开发能力的人去调用。当然，这些是程序员的基础技能了，要求不是很高，但也需要我们基本熟知。这节课，我们就来看看这些基础API。 注意敲黑板： 使用这些API是有前提条件的哦，首先在安全源访问，调用API才没有任何阻碍的。那什么是安全源呢？看下面思维导图（更详细的看：chrome 官方文档），且记住这句话：**安全源** 是至少匹配以下（ Scheme 、 Host 、 Port ）模式之一的源。 举个简单的例子：你本地开发用HTTP请求地址获取摄像头API没有问题，但是你的同事用他的电脑访问你电脑IP对应的项目地址时，摄像头调用失败，为什么呢？ 因为在他的浏览器中，你的项目访问地址非HTTPS，在非HTTPS的情况下，如果IP不是localhost或127.0.0.1，都不属于安全源。 当然事非绝对，在特定情况下必须使用非HTTPS访问也是可以的，Chrome提供了对应的取消限制但是不太建议用（安全为上），因此我在这里就不再多余阐述。 所以经常有同学问，为什么我的代码在自己浏览器中可以获取到摄像头，但是在区域网下别的电脑的浏览器中获取不到？同样的浏览器、同样的操作系统，为什么获取不到呢？原因就是上面的安全源限制。 getUserMedia以前的版本中我们经常使用 navigator.getUserMedia 来获取计算机的摄像头或者麦克风，但是现在这个接口废弃，变更为 navigator.mediaDevices.getUserMedia，因此后面我们均使用新的API来完成代码编写。 getUserMedia可以干什么？意如其名，那就是获取用户层面的媒体，当你的计算机通过 USB 或者其他网络形式接入了 N 多个摄像头或虚拟设备时，都是可以通过这个 API 获取到的。 当然不仅仅是视频设备，还包括音频设备和虚拟音频设备。 获取媒体设备是最简单的操作，它还可以控制获取到媒体的分辨率，以及其他的以一些可选项。 PS：在很多云会议中，我们开会只能选择一个摄像头，这并不是只能使用一个摄像头，而是厂商针对“大多数场景中只会用到一个摄像头”而设计的； 但在有些业务中，我们可能需要自己设备上的 N 个摄像头（带 USB 摄像头）同时使用，那么如何办到呢 （这个场景其实蛮多的，后面留个课后题）。因此熟知这个 API 对于解决基本的会议和其他复杂场景问题很有用。 如何使用 getUserMedia？有简单的用法，有复杂的用法。一般简易场景下，大多数 API 用默认参数就可以实现对应功能，getUserMedia也一样，直接调用不使用任何参数，则获取的就是 PC 的默认摄像头和麦克风。 但是，当我们遇到复杂一点的应用场景，比如你的电脑上自带麦克风，同时你连接了蓝牙耳机和有线耳机，那么在视频通话过程中，你如何主动选择使用哪个呢？也就是说， 在用摄像头或者麦克风之前，我们先要解决如何从 N 个摄像头或者麦克风中选择我们想要的。 要解决这个问题，我们必须先有个大体的思路（当然这个思路并不是凭空想象出来的，而是在一定的技术储备下才有的。如果你开始前没有任何思路也没关系，可以参考他人的经验），如下： 获取当前设备所有的摄像头和麦克风信息； 从所有的设备信息中遍历筛选出我们想要使用的设备； 将我们想要使用的设备以某种参数的形式传递给浏览器 API； 浏览器API去执行获取的任务。 上面提到的设备以某种参数的形式传递给 API ，那么这个设备必然是以参数存在的，因此这里有几个概念需要提前知道，如下： 设备分成了图中的三个大类型，每个类型都有固定的字段，比如 ID、kind、label ，而其中用于区分它们的就是kind字段中的 固定值 ， 最核心的字段就是 ID ，后面我们经常用的就是这个 ID。 那么，在前端如何使用 JavaScript获取到这些信息？ 大家先看下面这段代码，大体上过一遍，并留意 initInnerLocalDevice函数内部执行顺序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function handleError(error) { alert(&quot;摄像头无法正常使用，请检查是否占用或缺失&quot;) console.error('navigator.MediaDevices.getUserMedia error: ', error.message, error.name);}/** * @author suke * device list init */function initInnerLocalDevice(){ const that = this var localDevice = { audioIn:[], videoIn: [], audioOut: [] } let constraints = {video:true, audio: true} if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) { console.log(&quot;浏览器不支持获取媒体设备&quot;); return; } navigator.mediaDevices.getUserMedia(constraints) .then(function(stream) { stream.getTracks().forEach(trick =&gt; { trick.stop() }) // List cameras and microphones. navigator.mediaDevices.enumerateDevices() .then(function(devices) { devices.forEach(function(device) { let obj = {id:device.deviceId, kind:device.kind, label:device.label} if(device.kind === 'audioinput'){ if(localDevice.audioIn.filter(e=&gt;e.id === device.deviceId).length === 0){ localDevice.audioIn.push(obj) } }if(device.kind === 'audiooutput'){ if(localDevice.audioOut.filter(e=&gt;e.id === device.deviceId).length === 0){ localDevice.audioOut.push(obj) } }else if(device.kind === 'videoinput' ){ if(localDevice.videoIn.filter(e=&gt;e.id === device.deviceId).length === 0){ localDevice.videoIn.push(obj) } } }); }) .catch(handleError); }) .catch(handleError); } 这个代码片段的主要作用就是获取用户设备上所有的摄像头和麦克风信息，起关键作用的是enumerateDevices函数，但是在调用这个关键函数之前，getUserMedia函数出现在了这里，它的出现是用户在访问服务时直接调用用户摄像头，此时如果用户授权且同意使用设备摄像头、麦克风，那么enumerateDevices函数就能获取设备信息了，在这里getUserMedia函数可以理解为获取摄像头或者麦克风权限集合的 探路函数 。 看下图，我将我电脑上使用enumerateDevices函数加载到的信息，根据前面提到的字段kind，将其分三类并打印到控制台。 千万不要小看现在获取到的这些信息哦，在后面视频通话或会议过程中，我们需要抉择摄像头用前置还是后置，麦克风是用蓝牙还是有线，都是离不开这些信息的。 在拿到所有的摄像头麦克风信息之后，我们需选出最终要参与视频通话的那个信息体，看上图中 VideoIn数组里面label:&quot;eseSoft Vcam&quot; ， 这个摄像头就是我想要参会的摄像头，那么我怎样指定让代码去选择这个摄像头呢？这里就涉及到了getUserMedia的约束参数constraints 。 媒体约束 constraints在具体讲解约束参数 constraints 之前，大家先看下面这段示例代码。 1234567891011121314151617let constraints = {video:true, audio: true}-- function handleError(error) { console.error('navigator.MediaDevices.getUserMedia error: ', error.message, error.name); }-- /** * 获取设备 stream * @param constraints * @returns {Promise&lt;MediaStream&gt;} */ async function getLocalUserMedia(constraints){ return await navigator.mediaDevices.getUserMedia(constraints) }-- let stream = await this.getLocalUserMedia(constraints).catch(handleError);console.log(stream) 上面的代码片段为JavaScript获取计算机摄像头和麦克风的媒体流（视频和音频流我们统称为媒体流）的一种方式，大多数情况下都是这么用的，如果电脑有摄像头、麦克风，这样获取没有任何问题，但就担心你用的时候，你的电脑上 没有配摄像头或麦克风 ，或者有多个摄像头而你想指定其中某一个。 为了兼容更多情况，我们需要知道constraints这个参数的详细用法。 接下来我们看下这个参数在几种常见场景下的具体配置，以及为什么这样配置。 同时获取视频和音频输入 使用下面约束， 如果遇到计算机没有摄像头的话，你调用上述代码的过程中就会报错，因此我们在调用之前可以通过enumerateDevices返回结果主动判断有无视频输入源，没有的话，可以动态将这个参数中的 video设置为false。 1{ audio: true, video: true } 获取指定分辨率 在会议宽带足够且流媒体传输合理的情况下，无需考虑服务端压力，而需考虑客户端用户摄像头的分辨率范围，通常我们会设置一个分辨率区间。 下面展示的 ① 约束是请求一个 1920×1080 分辨率的视频，但是还提到 min 参数，将 320×240 作为最小分辨率，因为并不是所有的网络摄像头都可以支持 1920×1080 。当请求包含一个 ideal（应用最理想的）值时，这个值有着更高的权重，意味着浏览器会先尝试找到最接近指定理想值的设定或者摄像头（如果设备拥有不止一个摄像头）。 但是，在多人会议简单架构场景中，在不改变会议稳定性的情况下，为了让更多的客户端加入，我们通常会把高分辨率主动降低到低分辨率，约束特定摄像头获取指定分辨率如下面 ② 配置。 12345678910111213--------------------①:1-------------------------- { audio: true, video: { width: { min: 320, ideal: 1280, max: 1920 }, height: { min: 240, ideal: 720, max: 1080 } } } --------------------②:2-------------------------- { audio: true, video: { width: 720, height: 480}} 指定视频轨道约束：获取移动设备的前置或者后置摄像头 facingMode属性。可接受的值有：user（前置摄像头）、environment（后置摄像头）；需要注意的是， 这个属性在移动端可用 ，当我们的会议项目通过 h5 在移动端打开时，我们可以动态设置这个属性从而达到切换前后摄像头的场景。 123456789101112 { audio: true, video: { facingmode: &quot;user&quot;; }} { audio: true, video: { facingmode: { exact: &quot;environment&quot;; } }} 指定帧速率frameRate 帧速率（你可以理解为FPS）不仅对视频质量，还对带宽有着影响，所以在我们通话过程中，如果判定网络状况不好，那么可以限制帧速率。 我们都知道， 视频是通过一定速率的连续多张图像形成的 ，比如每秒 24 张图片才会形成一个基础流畅的视频，因此帧速率对于实时通话的质量也有影响，你可以想象成和你的游戏的FPS一个道理。 12345678const constraints = { audio: true, video: { width:1920, height:1080, frameRate: { ideal: 10, max: 15 } }}; 实际上，通过FPS我们可以引申出来一些场合，在特定场合选择特定的FPS搭配前面的分辨率配置，以提高我们会议系统的质量，比如： 屏幕分享过程中，我们应当很重视高分辨率而不是帧速率，稍微卡点也没关系； 在普通会议过程中，我们应当重视的是画面的流畅，即帧速率而不是高分辨率； 在开会人数多但宽带又受限的情况下，我们重视的同样是会议的流程性，同样低分辨率更适合宽带受限的多人会议； …… 还有很多场合大家可以想想。 使用特定的网络摄像头或者麦克风 重点哦，我们最前面enumerateDevices函数获取到的设备集合可以派上用场了。 1234567891011121314151617181920212223242526/** * 获取指定媒体设备id对应的媒体流 * @author suke * @param videoId * @param audioId * @returns {Promise&lt;void&gt;} */async function getTargetIdStream(videoId,audioId){ const constraints = { audio: {deviceId: audioId ? {exact: audioId} : undefined}, video: { deviceId: videoId ? {exact: videoId} : undefined, width:1920, height:1080, frameRate: { ideal: 10, max: 15 } } }; if (window.stream) { window.stream.getTracks().forEach(track =&gt; { track.stop(); }); } //被调用方法前面有，此处不再重复 let stream = await this.getLocalUserMedia(constraints).catch(handleError);} getDisplayMedia我们日常开会，多数需要通过会议 App 来分享自己的屏幕，或者仅分享桌面上固定的应用程序那么在浏览器中实现视频通话，能否实现分享屏幕呢？ 答案是肯定的 ， W3C的 Screen Capture 标准中有说明，就是使用getDisplayMedia。 12345678910var promise = navigator.mediaDevices.getDisplayMedia(constraints);## 获取屏幕分享navigator.mediaDevices.getDisplayMedia(constraints) .then((stream) =&gt; { /* use the stream */ }) .catch((err) =&gt; { /* handle the error */ }); 参数 Constraints同上一个函数一样，同样需要配置constraints约束，当然这个也是可选的， 如果选择传参的话，那么参数设置如下： 1234getDisplayMedia({ audio: true, video: true}) 但是这里的constraints配置和前面getUserMedia的约束配置是有差别的。又一个重点来了，在屏幕分享的约束中，video 是不能设置为false 的， 但是可以设置指定的分辨率 ，如下： 1234getDisplayMedia({ audio: true, video: {width:1920,height:1080}}) audio为true audio 为 false 请留意上面两图的对比，当去掉音频后，第二张图少了个勾选系统音频的 radio 框。 完整案例12345678910111213141516171819/** * 获取屏幕分享的媒体流 * @author suke * @returns {Promise&lt;void&gt;} */async function getShareMedia() { const constraints = { video: { width: 1920, height: 1080 }, audio: false, }; if (window.stream) { window.stream.getTracks().forEach((track) =&gt; { track.stop(); }); } return await navigator.mediaDevices .getDisplayMedia(constraints) .catch(handleError);} 项目演示指南下载仓库代码之后，启动；然后打开第一个摄像头操作模块。 请选择好参数，然后点击确定，就可以演示这些参数的作用，尤其到 FPS 那里，大家可以尝试调制 1-5 效果最明显。 本节所有源代码地址源码和体验地址 小提示 在前面的案例代码中，我们在获取系统的音频或者视频的stream之前，一般会调用以下代码，目的是清除当前标签页中没有销毁的媒体流。 12345if (window.stream) { window.stream.getTracks().forEach(track =&gt; { track.stop(); }); } 如果不销毁，你可以看到在标签页旁边一直有个小红圈闪烁，鼠标按上去提示正在使用当前设备的摄像头，因此在后面的开发中保持好习惯：结束自己会议后或页面用完摄像头后，一般除了强制刷新，也可以调用上面代码清除正在使用的stream调用。 好了，这节课我们我们掌握了两个最重要的 API，下节课我们开始搭建一个信令服务器，同时完成 P2P (单人对单人)的视频通话（跑代码的时候一定要记得前面提到的安全源哦）。","link":"/2023/02/01/webrtc/1.%E5%9F%BA%E7%A1%80api/"},{"title":"AST","text":"前面我们熟悉了WebRTC的核心对象PeerConnection，也了解了核心对象的一些基本方法；后面我们也分析了WebRTC的会话过程，以及中间需要调用哪些方法；最后我们通过 nodejs搭建了最基本的信令服务器。接下来我们就开始用代码还原前面的WebRTC的基本会话流程。 后续pc代表PeerConnection, caller为A，callee为B举例。 P2P 音视频实战首先，呼叫方A。 localRtcPc为本地实例化后的PeerConnection实例，与前面整体流程有差异的地方是，我们现在在初始化 pc 后，直接同步获取本地摄像头和音频输入并添加到 pc 中。初始获取媒体流需要一定时间响应，如果在乎创建连接时间的，这一步可异步完成。 1234567891011121314151617181920async initCallerInfo(callerId,calleeId){ //初始化pc this.localRtcPc = new PeerConnection() //获取本地媒体并添加到pc中 let localStream = await this.getLocalUserMedia({ audio: true, video: true }) for (const track of localStream.getTracks()) { this.localRtcPc.addTrack(track); } //本地dom渲染 await this.setDomVideoStream(&quot;localdemo01&quot;,localStream) //回调监听 this.onPcEvent(this.localRtcPc,callerId,calleeId) //创建offer let offer = await this.localRtcPc.createOffer(); //设置offer未本地描述 await this.localRtcPc.setLocalDescription(offer) //发送offer给被呼叫端 let params = {&quot;targetUid&quot;:calleeId,&quot;userId&quot;:callerId,&quot;offer&quot;:offer} this.linkSocket.emit(&quot;offer&quot;,params)} A 呼叫 B 后双方同意建立通信，A 首先初始化 pc，代码中的localRtcPc 。 然后 A 初始化本地mediaStream，并添加到 pc 对象中，同时渲染在本地预览 DOM 元素。 初始化回调信息，比如 ontrack（监听 B 端媒体），onicecandidate（双方 ICE 候选信息）事件等。 123456789101112131415161718192021onPcEvent(pc,localUid,remoteUid){ const that = this this.channel = pc.createDataChannel(&quot;chat&quot;); pc.ontrack = function(event) { that.setRemoteDomVideoStream(&quot;remoteVideo01&quot;,event.track) }; pc.onnegotiationneeded = function(e){ console.log(&quot;重新协商&quot;,e) } pc.ondatachannel = function(ev) { console.log('Data channel is created!'); }; pc.onicecandidate = (event) =&gt; { if (event.candidate) { that.linkSocket.emit('candidate',{'targetUid':remoteUid,&quot;userId&quot;:localUid,&quot;candidate&quot;:event.candidate}) } else { /* 在此次协商中，没有更多的候选了 */ console.log(&quot;在此次协商中，没有更多的候选了&quot;) } }} 创建offer信令设置为本地描述后发送给 B 。 等 B 创建应答信令之后，信令服务器会将其转发到 A 这边。 123async onRemoteAnswer(fromUid,answer){ await this.localRtcPc.setRemoteDescription(answer);} A 接受 B 的 answer信令后，将其设置为 remoteDesc 。 注意看日志中的candidate，这个过程是贯穿整个会话的，直到ice候选完成。 被呼叫端B。 被呼叫端的过程和呼叫端类似，大体代码如下： 1234567891011121314async initCalleeInfo(localUid,fromUid){ //初始化pc this.localRtcPc = new PeerConnection() //初始化本地媒体信息 let localStream = await this.getLocalUserMedia({ audio: true, video: true }) for (const track of localStream.getTracks()) { this.localRtcPc.addTrack(track); } //dom渲染 await this.setDomVideoStream(&quot;localdemo01&quot;,localStream) //监听 this.onPcEvent(this.localRtcPc,localUid,fromUid) } B 接听后同时初始化 pc。 B 创建本地mediaStream，并添加到 pc 对象中，同时渲染在本地预览 Dom 元素。 同 A 初始化回调监听。 当然此时 A 发送的offer信令通过信令服务器转发到 B 这边，B 将其设置为remoteDesc后，同时创建answer信令。 1234567891011async onRemoteOffer(fromUid,offer){ //B接受到A的offer 设置为remote desc this.localRtcPc.setRemoteDescription(offer) //创建应答 let answer = await this.localRtcPc.createAnswer(); //设置为local desc await this.localRtcPc.setLocalDescription(answer); //并通过信令服务器发送给A let params = {&quot;targetUid&quot;:fromUid,&quot;userId&quot;:getParams(&quot;userId&quot;),&quot;answer&quot;:answer} this.linkSocket.emit(&quot;answer&quot;,params) } 至此，所有的会话建立完成，在双方监听的 pc 核心方法ontrack中，就能拿到双方的音频和视频信息了，完整的代码我会放在文末，大家自取即可。不过纸上得来终觉浅，还需要你自己在实践中理解，这才是掌握最快速的。 大家可以看下下图中具体的 SDP信息，实际上都是WebRTC封装好的，不需要我们去组装，如果你认真从前面看的，应该很容易理解，完成一个 P2P 的视频通话是不是很简单？ 不过我先打个预防针：在真正的复杂网络环境中 ， 我们需要考虑的还有很多，如果之前大家了解过 WebRTC 相关的知识，一定对 stun 和 turn 这几个词不陌生，我们暂时不考虑这个， 从最简单的网络环境中开始 ，完成我们的目标。 通话过程中媒体流的变更 完成以上视频通话，可能有人会问，怎么实现类似微信视频中，视频和音频之间随意切换，或摄像头前置后置切换呢？ 这里我们就需要再学习一个知识点：RTCRtpSender对象。这个对象的接口支持变更你发送到对方的媒体，通过这个对象接口，你可以编辑更改流属性，从而达到控制远端媒体流的目的。 通过实例化后的PeerConnection对象调用getSenders方法，可获取每个媒体轨道对应RTCRtpSender对象。这里再解释下这个媒体轨道，我们在获取到媒体信息的时候，一般包含两部分，一部分音频信息(audiotrack)，一部分视频信息(videotrack)，因此这里的媒体轨道指的就是媒体信息。 音频视频模式切换。 12345//获取发送到远端的具体媒体信息的发送方信息const senders = this.localRtcPc.getSenders();console.log(senders);const send = senders.find((s) =&gt; s.track.kind === &quot;video&quot;); //找到视频发送方信息send.track.enabled = !send.track.enabled; //控制视频显示与否 即仅音频模式 摄像头切换。 12345//我这里web端因此只获取屏幕分享流 APP端则获取前置后置摄像头流即可let stream = await this.getShareMedia();const [videoTrack] = stream.getVideoTracks();const send = senders.find((s) =&gt; s.track.kind === &quot;video&quot;); //找到视频类型发送方信息send.replaceTrack(videoTrack); //替换视频媒体信息 类IM实现前面初始化回调流程中有个监听方法 onPcEvent()，内部你会发现有个函数createDataChannel，看名字就是创建了一个通道。是的，这就是的WebRTC中的datachannel可以实现无服务端 P2P 文本等富文本信息双向传输，只要完成WebRTC会话，即使视频通话过程中你的云服务器宕机了也没关系，P2P 的即时通讯还是可以正常进行的。我先演示下： 官方描述 RTCPeerConnection 的 createDataChannel() 方法可以创建一个可以发送任意数据的数据通道， 常用于后台传输内容，例如：图像、文件传输、聊天文字等其他数据，当然除了后台，最常用的就是 P2P 中客户端的双向通信了。 基础语法和使用 下面的创建 datachannel 的前提是双方已经完成WebRTC的基础信令交换，pc变量为初始化后的RTCPeerConnection。 let dataChannel = RTCPeerConnection.createDataChannel(label[, options]); 创建一个datachannel，发送并监听消息。 123456789101112131415161718192021this.channel = pc.createDataChannel(&quot;my channel&quot;, { protocol: &quot;json&quot;, ordered: true,});-----------------监听消息------------------------------pc.ondatachannel = function(ev) { console.log('Data channel is created!'); ev.channel.onopen = function() { console.log('Data channel ------------open----------------'); }; ev.channel.onmessage = function(data) { console.log('Data channel ------------msg----------------',data); }; ev.channel.onclose = function() { console.log('Data channel ------------close----------------'); }; }; -------------发送消息-------------------------------------- this.channel.send(this.rtcmessage) 通过这种方式发送消息，你在浏览器的 NetWork 是看不到的哦，因此按照常规抓包逻辑直接抓HTTP或者WS协议包的话，也是抓不到的。之前在某些网站看到过这种方式传输数据，我相信以后会有更多的地方用到WebRTC的datachannel。如果同学们想要深入了解原理，可以去看看SCTP协议 ，点击前往相关协议说明官方文档地址。 项目操作指南 打开项目源码，找到模块：一对一网络视频。 进去后请在 URL 中携带参数 userId 和 roomId 。 1234#用户1001 房间号：10012http://localhost:8080/demo03-one2one?userId=1001&amp;roomId=10012#用户1002 房间号：10012http://localhost:8080/demo03-one2one?userId=1002&amp;roomId=10012 此时访问成功后，页面会展示如下内容，点击指定用户旁边通话按钮，则可以和同一个房间内的指定人员通话。之前可能大家有疑惑为何要带房间号呢？因为第一是为了我们后面的会议做铺垫，第二是为了用户隔离。 操作完成视频通话之后，大家尝试在输入框输入文本消息，然后点击发送。此时会在另一端的窗口展示你在第一个窗口发送消息，这个就是 P2P 即时通讯。但是请注意，完成此功能的前提就是你已经建立了对等的WebRTC连接，否则会提示错误。 点击用户列表自己账户旁边的切换，则可以关闭或者打开自己的画面，同时另一方也会实时变化，这个切换的功能，后面到媒体控制我们再做详细的解释。 本节所有源代码地址本节课相关代码 课后题这节课算是WebRTC的正式入门实践了，在学习完理论知识后，请大家模仿我的 Demo 自己实现类似页面，如果你是前端的话那么可以实现一个美化版本且可部署的点对点音视频通话的在线 Demo，让大家一起试试你的成果。","link":"/2023/02/01/webrtc/3.%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B01%E5%AF%B91/"},{"title":"AST","text":"上节我们学了如何通过浏览器的 API 去操控电脑上的摄像头、麦克风、屏幕分享桌面，这些是我们实现会议系统必备的基础知识，接下来我们就要去思考如何实现一个会议系统，以及如何将我们学到的基础 API 和WebRTC组合。 清晰的逻辑和流程对于解决任何事情，都可以事半功倍。所以同样的，我们也得首先构思下应该以什么样的方式或流程去实践这项技术，完成这个功能。 第一步，我们必须得知道WebRTC是如何将远端的两个浏览器关联起来的，因为只有建立关联关系，接下来才有多媒体通信的基础。 第二步，关联关系转换到代码层面，那意味着在双方的浏览器中必须存在共性，这个共性你可以理解为一个核心的载体，有了载体就可以维护关联关系，那么在WebRTC中这个载体是什么？ 这时我们就需要了解下WebRTC的核心对象PeerConnection，因为这就是上面两个问题的答案，建立关联关系和维护关联关系的载体。 核心对象 PeerConnectionPeerConnection可以说是整个WebRTC通话的载体，如果没有这个对象，那么后面所有流程都是没法进行的。 首先要明确的是，在不同的浏览器中，WebRTC兼容性不一样，虽然前面开篇词提到它的相关 API 已经成为 W3C 的基础标准，但并不是所有的浏览器都满足这些标准的。WebRTC最先开始是谷歌体系，那么兼容性而言，谷歌浏览器就是首选。国内很多的浏览器也是基于谷歌内核的，因此WebRTC在很大程度上也是兼容的，这里先说几个常用且兼容WebRTC的浏览器：Chrome、360、edge、火狐、Safari。 因此为了尽可能地兼容不同浏览器，获取到有效的PeerConnection对象，我们可以通过如下方式获取： 1234var PeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection; 知道了这个核心载体，自然就要了解这个载体的核心方法，只有它自身的核心方法才能驱动它进行工作。 这些 核心方法 ，在这里混个眼熟，后面到整体会话过程的时候，我们会详细来看这些方法的调用顺序以及方式。留意后面红字部分，这个也是很重要的一个点，后面我们单独引申展开看看。 addIceCandidate()： 保存 ICE 候选信息，即双方协商信息，持续整个建立通信过程，直到没有更多候选信息。 addTrack() ：添加音频或者视频轨道。 createAnswer() ：创建应答信令。 createDataChannel()： 创建消息通道，建立WebRTC通信之后，就可以 p2p 的直接发送文本消息，无需中转服务器。 createOffer()： 创建初始信令。 setRemoteDescription()： 保存远端发送给自己的信令。 setLocalDescription() ：保存自己端创建的信令。 以上就是PeerConnection这个载体核心驱动的主要方法了，除了这些核心方法之外，还有一些 事件监听函数 ，这些监听函数用于监听远程发送过来的消息。 假如 A 和 B 建立连接，如果 A 作为主动方即呼叫端，则需要调用的就是上述核心方法去创建建立连接的信息，而 B 则在另一端使用上述部分核心方法创建信息再发送给 A，A 则调用事件监听函数去保存这些信息。常用的事件监听函数如下： ondatachannel： 创建datachannel后监听回调以及 p2p消息监听。 ontrack ：监听远程媒体轨道即远端音视频信息。 onicecandidate： ICE 候选监听。 WebRTC的会话流程解决完上面俩问题，我们知道了既然要达成会话，那么就需要上述的载体，然后通过载体的核心方法和事件就可以完成从 A 到 B 两个浏览器的关联，那么关联的具体过程是什么呢？那就是我们接下来要详细解释的。首先看我给大家绘制的流程图： 对照这个流程图，我们再来口述一边，上图中 A 为caller（呼叫端），B 为 callee（被呼叫端）。 首先 A 呼叫 B，呼叫之前我们一般通过实时通信协议WebSocket即可，让对方能收到信息。 B 接受应答，A 和 B 均开始初始化PeerConnection 实例，用来关联 A 和 B 的SDP会话信息。 A 调用createOffer创建信令，同时通过setLocalDescription方法在本地实例PeerConnection中储存一份（ 图中流程 ① ）。 然后调用信令服务器将 A 的SDP转发给 B（ 图中流程 ② ）。 B 接收到 A 的SDP后调用setRemoteDescription，将其储存在初始化好的PeerConnection实例中（ 图中流程 ③ ）。 B 同时调用createAnswer创建应答SDP，并调用setLocalDescription储存在自己本地PeerConnection实例中（ 图中流程 ④ ）。 B 继续将自己创建的应答SDP通过服务器转发给 A（ 图中流程 ⑤ ）。 A 调用setRemoteDescription将 B 的SDP储存在本地PeerConnection实例（ 图中流程 ⑤ ）。 在会话的同时，从图中我们可以发现有个ice candidate，这个信息就是 ice 候选信息，A 发给 B 的 B 储存，B 发给 A 的 A 储存，直至候选完成。 我们可以发现，这里又出来个新的名词 SDP ，这玩意实际就是WebRTC会话的信令，完成以上过程就相当于建立了WebRTC的会话基础，然后你才可以借助这个桥梁去添加和监听双方的音视频流信息。 信令服务器的搭建从上述整个流程来看，信令服务器为 A、B 两者中转信令起了很重要的角色，直白地讲，就是串通 A、B 的媒介，假如我的手机是 A，你的手机是 B，那么我们俩联系就需要通过运营商，而运营商的服务器替我们中转呼叫、接听、挂断等操作，在这里， 运营商的服务器就是信令服务器 。 信令服务器听上去很高大上，但实际上，它在不做复杂操作的时候，就是个即时通讯服务器，转发通话双方需要交换的信息，或者会话的信息，因此我们可以直接写个WebSocket服务端来完成信令服务器的使命。 当然，要完成信令服务器，我们也需要有针对性，我们的目的是为了WebRTC，那么针对的肯定就是WebRTC会话过程中需要的转发逻辑，由此我们可以构思下服务端应该具备哪些功能，看下图。为了完成上面这个构思，我们可以尝试写出来一个最基本的信令服务器。记住我们的目的是什么？ 一个会议系统 ，是的，所以我们设计的东西一定要满足会议的基本条件，即：用户单独标识和集体标识，也就是一开始必须区分的关键信息userId、roomId，但是怎么存会议室中的用户信息呢？这里我会用到Redis的一种数据结构Hash，存放的大体结构如下图所示。信令服务器用什么语言呢？我们以 Web 端为主体，因此直接通过大家熟悉的nodejs来写即可，简单、方便、成本低，会一点点JavaScript即可。 具体代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162const httpServer = require(&quot;http&quot;).createServer();const io = require(&quot;socket.io&quot;)(httpServer);//redisvar redis = require(&quot;redis&quot;);const roomKey = &quot;meeting-room::&quot;;var redisClient = redis.createClient(6379, &quot;127.0.0.1&quot;);redisClient.on(&quot;error&quot;, function (err) { console.log(&quot;redisClient connect Error &quot;, err);});const userMap = new Map(); // user - &gt; socketio.on(&quot;connection&quot;, async (socket) =&gt; { await onListener(socket);});httpServer.listen(18080, async () =&gt; { console.log(&quot;服务器启动成功 *:18080&quot;); await redisClient.connect();});/** * res data */function getMsg(type, msg, status = 200, data = null) { return { type: type, msg: msg, status: status, data: data };}function getParams(url, queryName) { let query = decodeURI(url.split(&quot;?&quot;)[1]); let vars = query.split(&quot;&amp;&quot;); for (var i = 0; i &lt; vars.length; i++) { var pair = vars[i].split(&quot;=&quot;); if (pair[0] === queryName) { return pair[1]; } } return null;}/** * DB data * @author suke * @param {Object} userId * @param {Object} roomId */async function getUserDetailByUid(userId, roomId) { let res = JSON.stringify({ userId: userId, roomId: roomId }); console.log(res); return res;}/** * 监听 * @author suke * @param {Object} s */async function onListener(s) { let url = s.client.request.url; let userId = getParams(url, &quot;userId&quot;); let roomId = getParams(url, &quot;roomId&quot;); console.log(&quot;client uid：&quot; + userId + &quot; roomId: &quot; + roomId + &quot; online &quot;); //user map userMap.set(userId, s); //room cache if (roomId) { await redisClient.hSet( roomKey + roomId, userId, await getUserDetailByUid(userId, roomId) ); oneToRoomMany(roomId, getMsg(&quot;join&quot;, userId + &quot; join then room&quot;)); } s.on(&quot;msg&quot;, async (data) =&gt; { console.log(&quot;msg&quot;, data); await oneToRoomMany(roomId); }); s.on(&quot;disconnect&quot;, () =&gt; { console.log(&quot;client uid：&quot; + userId + &quot; roomId: &quot; + roomId + &quot; offline &quot;); userMap.delete(userId); if (roomId) { redisClient.hDel(roomKey + roomId, userId); oneToRoomMany(roomId, getMsg(&quot;leave&quot;, userId + &quot; leave the room &quot;)); } }); s.on(&quot;roomUserList&quot;, async (data) =&gt; { // console.log(&quot;roomUserList msg&quot;,data) s.emit(&quot;roomUserList&quot;, await getRoomUser(data[&quot;roomId&quot;])); }); s.on(&quot;call&quot;, (data) =&gt; { let targetUid = data[&quot;targetUid&quot;]; if (userMap.get(targetUid)) { oneToOne(targetUid, getMsg(&quot;call&quot;, &quot;远程呼叫&quot;, 200, data)); } else { console.log(targetUid + &quot;不在线&quot;); } }); s.on(&quot;candidate&quot;, (data) =&gt; { let targetUid = data[&quot;targetUid&quot;]; if (userMap.get(targetUid)) { oneToOne(targetUid, getMsg(&quot;candidate&quot;, &quot;ice candidate&quot;, 200, data)); } else { console.log(targetUid + &quot;不在线&quot;); } }); s.on(&quot;offer&quot;, (data) =&gt; { let targetUid = data[&quot;targetUid&quot;]; if (userMap.get(targetUid)) { oneToOne(targetUid, getMsg(&quot;offer&quot;, &quot;rtc offer&quot;, 200, data)); } else { console.log(targetUid + &quot;不在线&quot;); } }); s.on(&quot;answer&quot;, (data) =&gt; { let targetUid = data[&quot;targetUid&quot;]; if (userMap.get(targetUid)) { oneToOne(targetUid, getMsg(&quot;answer&quot;, &quot;rtc answer&quot;, 200, data)); } else { console.log(targetUid + &quot;不在线&quot;); } });}/** * ono to one (event msg) * @author suke * @param {Object} uid * @param {Object} msg */function oneToOne(uid, msg) { let s = userMap.get(uid); if (s) { s.emit(&quot;msg&quot;, msg); } else { console.log(uid + &quot;用户不在线&quot;); }}/** * 获取房间用户列表 * @author suke * @param {Object} roomId */async function getRoomUser(roomId) { return await redisClient.hGetAll(roomKey + roomId);}/** * one to room many * @author suke * @param {Object} roomId * @param {Object} msg */async function oneToRoomMany(roomId, msg) { let ulist = await redisClient.hGetAll(roomKey + roomId); for (const uid in ulist) { oneToOne(uid, msg); }} 项目演示指南下载代码后，找到目录下： socket-server 文件夹，到文件夹执行依赖安装并配置 Redis 链接。 123456789cd socket-server cnpm i npm run start ## 启动 ---------------------打印如下则代表信令服务器启动成功--------------------------------- &gt; socket-server@1.0.0 start &gt; node app.js 服务器启动成功 *:18080 redis 连接成功 扩展在看完WebRTC会话流程之后，你会发现，在整个核心会话中，并没有出现媒体信息交换（比如：摄像头、麦克风媒体流的发送和接受）。所以很明显，WebRTC不只可以用来音视频通话。 确实如此，在无需视频通话的时候，我们可以用WebRTC这个桥梁当作是一种新的数据双向传输方案，现阶段已经有网站用这种方式上传用户数据或其他加密消息媒介了，而且因为WebRTC中数据传输协议非HTTP或者WebSocket协议请求，很多探测工具也就没法察觉。 下一节，我们将利用搭建好的信令服务器，去具体实现最简单的 P2P 音视频通话，同时也为了给大家演示下，WebRTC除音视频场景之外，利用WebRTC已完成会话这个桥梁，去实现无需服务端的点对点 IM 通信。","link":"/2023/02/01/webrtc/2.%E4%BF%A1%E4%BB%A4%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"AST","text":"上节课我们实现了简易直播，但在实际直播场景中，我们会遇到如题目中描述的虚拟背景的需求，这节课，我们就看看如何在前端实现给视频流赋于虚拟背景，后面我们再将虚拟背景和直播以及视频会议组合起来。 初步认识虚拟背景很多人都或多或少在生活中见到过虚拟背景，尤其是现在微信视频通话过程中新增的模糊背景功能。这个过程还挺复杂的，整个实现逻辑涉及到人物动态计算、人像抠图、背景填充（增加马赛克或者其他的色彩）等从而才能实现模糊背景这个看似简单的功能。而我们现在只不过是站在巨人的肩膀上，用别人已经写好的算法并训练出对应的人工智能模型完成我们现在的目的。 从前面阐述的整体实现逻辑，大体可以看出，实现模糊背景需要的几个核心步骤： 第一，识别当前画面中的人； 第二，动态从这个画面中扣出第一步识别出的人的画面； 第三，给非人部分增加马赛克或者其他的背景。 就三个步骤而言看起来很简单，但是每个步骤要实现对应的功能可不简单，这里面就涉及到了机器学习和复杂算法。当然，我们的目的仅仅是实现这个功能，而不是学习深层次的核心算法，因此上面提到的东西，我们只需要大体有个认知，能找到对应的解决方案即可。 而本节课，我将利用谷歌开源的一个机器学习框架 MediaPipe实现虚拟背景的功能。 什么是 MediaPipe呢？ MediaPipe 是谷歌开源的适用于多平台、终端的机器学习框架，其内部有很多的工具包和基础解决方案，安装即可使用，内部使用的模型也有开源的。像人脸检测、面部识别、虹膜、手势、姿态、人体、人体分割、头发分割、3D 识别等常见场景，都可以直接找到对应的成熟解决案例和模型。 因此利用上述框架中的人体分割模型，就可以实现我们在摄像头中的画面人物和背景分割的目标。分割完成后，还可以利用其他强大的功能，对已经分割识别的动态流自定义处理，进而实现背景自定义。 在线演示 点击前往 代码实战 准备基础的环境 。因为我们用前端开发，因此利用已经搭建好的前端 node 环境即可，在当前项目安装 JS 版本的 MediaPipe中的人体分割相关的依赖库。 1npm i @mediapipe/selfie_segmentation //可以指定版本 当前案例我自己选择的是 ^0.1.1632777926 视频流初始化 。获取摄像头的视频流和前面课程中的一致，copy 过来即可。 12345678910111213141516171819202122232425/** * 获取指定媒体设备id对应的媒体流（不传参数则获取默认的摄像头和麦克风） * @author suke * @param videoId * @param audioId * @returns {Promise&lt;void&gt;} */async getTargetDeviceMedia(videoId,audioId){ const constraints = { audio: {deviceId: audioId ? {exact: audioId} : undefined}, video: { deviceId: videoId ? {exact: videoId} : undefined, width:1920, height:1080, frameRate: { ideal: 10, max: 15 } } }; if (window.stream) { window.stream.getTracks().forEach(track =&gt; { track.stop(); }); } //被调用方法前面有，此处不再重复 return await this.getLocalUserMedia(constraints).catch(handleError);}, 初始化图像分割工具 以下代码中出现了一个 canvas 元素，这个载体我们作为拿到虚拟背景后将对应画面展示的地方。 同时可以看到，有个地方用到了动态地址，这个动态地址就是下载具体版本模型的地方，因为 cdn 地址在国内访问比较慢，因此我将其下载到本地，然后通过 nginx 代理通过区域网访问对应模型。 1234567891011121314151617initVb(){ canvasElement = document.getElementById('output_canvas'); canvasCtx = canvasElement.getContext('2d'); image = new Image(); image.src = this.meimage selfieSegmentation = new SFS.SelfieSegmentation({locateFile: (file) =&gt; { console.log(file); return `http://192.168.101.138:8080/${file}`;//ng 代理模型文件夹 // return `https://cdn.jsdelivr.'net/npm/@mediapipe/selfie_segmentation@0.1.1632777926/${file}`; }}); selfieSegmentation.setOptions({ modelSelection: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5, }); selfieSegmentation.onResults(this.handleResults);}, 图像分割后处理背景和人像 在前面的官方 Demo 中，并没有设置背景的，仅仅是将分割后的人像使用特定的颜色框出来，这里大家可以和官方的案例中对比下。 1234567891011121314handleResults(results) { // Prepare the new frame canvasCtx.save(); canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height); canvasCtx.drawImage(results.segmentationMask, 0, 0, canvasElement.width, canvasElement.height); //利用canvas绘制新背景 //canvasCtx.globalCompositeOperation = 'source-in';则意味着处理分割后图像中的人体。 canvasCtx.globalCompositeOperation = 'source-out'; canvasCtx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvasElement.width, canvasElement.height); canvasCtx.globalCompositeOperation = 'destination-atop'; canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height); // Done canvasCtx.restore();}, 监听流播放后触发上述工具模型处理画面，并绘制到前面声明的 Canvas 载体。 123456789101112131415161718192021/** * 监听触发模型处理 */async virtualBg(){ const that = this let video = document.getElementById('localdemo01') video.addEventListener('playing',function(){ let myvideo = this; let lastTime = new Date(); async function getFrames() { const now = myvideo.currentTime; if(now &gt; lastTime){ await selfieSegmentation.send({image: myvideo}); } lastTime = now; //无限定时循环 退出记得取消 cancelAnimationFrame() requestAnimationFrame(getFrames); }; getFrames() })} 我们对整体流程进行一个总结。 获取摄像头画面流。 初始化图像分割工具。 在本地的页面 DOM 中，播放第一步获取到的视频流。 监听视频流播放后，将画面帧发送到图像分割工具处理。 图像分割工具利用机器学习模型，识别画面并分割人体，然后处理得到分割后的蒙版，我们得到蒙版后将背景替换成自己的图片，最后展示到 canvas 。 初始化图像分割工具时有几个参数配置，这里挑几个重要的说明下。 MIN_DETECTION_CONFIDENCE ：手部检测模型中的最小置信度值，取值区间[0.0, 1.0] 被认为是成功的检测。默认为0.5。 MIN_TRACKING_CONFIDENCE ： 跟踪模型的最小置信度值，取值区间[0.0, 1.0]，将其设置为更高的值可以提高解决方案的稳健性，但是会带来更高的延迟，默认0.5。 项目操作演示 打开项目。找到模块：虚拟背景。 在根目录找到模型文件夹：virtualbg-model，然后在根目录启动 Http-Server，当然这里可以不用 Http-Server，也可以用 Nginx 代理。我们的目的是将该文件夹下的文件代理到一个可以访问的路径。 1234567891011121314151617181920cd virtualbg-model## 以允许跨域的参数启动http-server --cors----------------启动成功如下----------------Starting up http-server, serving ./http-server settings:CORS: trueCache: 3600 secondsConnection Timeout: 120 secondsDirectory Listings: visibleAutoIndex: visibleServe GZIP Files: falseServe Brotli Files: falseDefault File Extension: noneAvailable on: http://192.168.101.37:8081 http://127.0.0.1:8081Hit CTRL-C to stop the server 看上面项目截图，红色框框标记的位置：模型文件和被代理后的模型文件地址。如果大家要在线上使用该虚拟背景，那么这个静态文件是必须要有的，官网的例子使用的是 CDN 链接，但是该 CDN 在网络已被限制，因此这里给大家演示离线的版本。 选择摄像头和麦克风参数后点击确定。等待模型加载完毕后视频的旁边 Canvas 幕布中就是实时显示虚拟背景画面。 完整代码地址本节课相关代码 课后题这节课的内容，如果你已经完全消化，那么我们实现虚拟背景的目的就很好达到了。但是完成后，如何将这个虚拟背景转化为媒体流，并发送给对直播间的观众呢？欢迎大家在留言区讨论。 上节课给大家留了课后思考题，大家做的怎么样？如果能解决上节课的课后题，那么这节课的内容学习起来就很简单，无非是流的替换而已。接下来我们就一起实践下，如何借助 虚拟背景 美化我们前面做的简易直播系统。 开始之前，大家先回顾下我们在上节课的成果：将摄像头画面和虚拟背景通过机器学习模型融合后，展示在 Canvas 节点上，那么这节课我们就要对融合后的画面和 WebRTC 结合，并在我们之前写的简易直播中应用。 Canvas 画布流Canvas 本身只是一个画布，但是有对应的 API，可以将画布上的每一帧捕捉并形成媒体流，我们可以改造下上节课的方法，如下： 1234567891011121314151617181920async virtualBg(){ const that = this let video = document.getElementById('localdemo01') if(this.rfId){ cancelAnimationFrame(this.rfId) } let lastTime = new Date(); async function getFrames() { console.log(&quot;timer&quot;,lastTime) const now = video.currentTime; if(now &gt; lastTime){ await selfieSegmentation.send({image: video}); } lastTime = now; //无限定时循环 退出记得取消 cancelAnimationFrame() that.rfId = requestAnimationFrame(getFrames); }; getFrames() return canvasElement.captureStream(25)} 核心实际上就是canvasElement.captureStream方法，通过此方法即可捕捉画布并转换成流。内部唯一的参数就是帧速率FPS，一般设置为 20 到 25 这个区间即可满足正常视觉上的视频流畅度。 拿到画布媒体流后就要思考如何将该流发送给WebRTC对端，也就是我们所说的 观众端 。这样直播间的直播画面就是带有虚拟背景的画面。 这个流程就很简单了，和之前发送普通流一样，这次只不过是发送的画布流而已，名字不管是画布流还是普通流，在我们的代码中仅仅是 MediaStream 对象，因此按照正常流程来即可，如下： 获取虚拟背景流： 12//虚拟背景流暂存变量this.virtualMediaStream = await this.virtualBg() 建立关联关系后替换媒体流： virtualMediaStream : 1234567891011121314151617async onRemoteOffer(fromUid,offer){ const localUid = this.formInline.userId let pcKey = localUid+'-'+fromUid let pc = new PeerConnection(this.rtcPcParams) RtcPcMaps.set(pcKey,pc) console.log(&quot;主播监听到远端offer&quot;,pc); this.onPcEvent(pc,localUid,fromUid) //注意这里我们直接用的是虚拟背景流 替换原先的 localstream for (const track of this.virtualMediaStream.getTracks()) { pc.addTrack(track); } pc.setRemoteDescription(offer) let answer = await pc.createAnswer(); await pc.setLocalDescription(answer); let params = {&quot;targetUid&quot;:fromUid,&quot;userId&quot;:localUid,&quot;answer&quot;:answer} this.linkSocket.emit(&quot;answer&quot;,params) } 演示： 上面的动态图中，第一个为主播俩画面，一个为原始画面，另一个为带有虚拟背景的画面。后面的两个则是观众观看到的为带有虚拟背景的画面。 到这里我们直播间带虚拟背景的问题算是解决了，并且虚拟背景可以传送到观众端。但是接下来就要思考我们这节课的另一个重要问题了，直播开始如果并不使用虚拟背景而是在直播过程中自主切换虚拟背景，如何做到呢？ 问题思考和实战实际上，我们可以把直播中切换背景看作是切换视频流。如果我们能够在直播过程中无缝替换视频流，那么这个问题最重要的一步也就迎刃而解了，剩下的无非就是按照前面的流程，生成新的虚拟背景画布并获取视频流。 那么，在本身直播过程中，如何做到视频的无缝替换呢？ 如果按照前面的老路子，你可能会选择重新建立新的WebRTC连接并发布新的媒体流，但是你有没有想过，当你重新协商的时候，又需要重新走繁琐的信令协商过程，观众端需要经历重新协商这段时间，才能看到新的画面，这样不仅仅需要消耗信令服务器的资源，还浪费了观众端的时间，岂不是得不偿失？ 大家不必担心，我们能考虑到这个问题，实际上WebRTC的开发者也早就考虑到了，因此开发了相应的 API ，我们可以通过现有的 API 完成视频流的无缝切换，请看下面代码： 12345const senders = this.localRtcPc.getSenders();let stream = await this.getShareMedia()const [videoTrack] = stream.getVideoTracks();const send = senders.find((s) =&gt; s.track.kind === 'video')send.replaceTrack(videoTrack) 第一行代码为获取和某个客户端建立连接的WebRTC关联的核心对象 。 第二行为获取新的媒体流。 第三行为获取新的媒体流中的视频流。 第四行为获取核心对象中正在发布的视频轨道。 第五行为用新的视频流替换旧的流。 注意第一行代码中的 localRtcPc.getSenders()，这个方法的官方描述就是“返回一个对象数组 RTCRtpSender，每个对象代表负责传输一个轨道数据的 RTP 发送方。发送器对象提供用于 检查和控制轨道数据的编码和传输的方法和属性 。” 大白话就是，这个方法返回的数组中，维护着发送方的媒体信息（ RTP 就是最原始的媒体流 ），我们可以通过这个对象去检查和控制发送方媒体的编码和传输。 这样是不是就很容易理解了？如果不明白没关系，这节课我们只要知道可以通过这个方法去替换视频流就行了，后面《10 | 会议实战：实时通话过程中音频、视频画面实时控制切换》节我会给大家详细解释。 123const senders = this.localRtcPc.getSenders();const send = senders.find((s) =&gt; s.track.kind === 'video')send.replaceTrack(xxx) # xxx 为新的视频流 再来回味下前面这段代码，首先获取当前已有WebRTC关联关系的核心对象localRtcPc，然后通过getSenders获取发送器对象数组，并过滤其中带有视频标签的轨道信息。最后替换发送器对象中的视频轨道信息。 而我们的场景是直播，也就是一对多的关联关系，因此在主播端，维护有 N 对RTCPeerConnection，因此需要遍历直播间所有的关联关系，并替换新的流，即可完成远程流的切换，如下： 1234567891011//切换发送的远程流async changeRemoteStream(stream){ //先获取要替换的流 过滤音频 仅仅保留视频 const [videoTrack] = stream.getVideoTracks(); //主播端所有关联关系遍历并替换新的流 RtcPcMaps.forEach(e =&gt; { const senders = e.getSenders(); const send = senders.find((s) =&gt; s.track.kind === 'video') send.replaceTrack(videoTrack) })} 演示 项目操作指南 打开项目，找到模块：小型直播。 流程第五节的流程一样。第五节中，如果大家已经运行过源码，那么应该已看到主播端中间一栏 写有 直播开始后点击背景即可切换直播背景的醒目提示。当时给大家说不用理会，但是现在是时候试试了。 在观众和主播都已经就位后，此时还不是点击背景开始虚拟背景的时机，请问你的模型文件夹内的模型被代理了吗？代码中是否已配置模型加载路径？如果没有请回到上一节重新再复习一边。 模型文件没问题后此刻就可以点击中间的虚拟背景了，任选一个然后稍等几秒钟就可以在两端看到效果。 完整代码地址直播部分代码 虚拟背景源码 课后作业在直播使用虚拟背景的时候，大家可以注意下不同浏览器的 FPS，比如 360、谷歌、edge 等，然后开启浏览器的硬件加速后，再测试下 FPS 看下有何不同，同时注意计算机的资源占用情况。","link":"/2023/02/01/webrtc/5.%E8%99%9A%E6%8B%9F%E8%83%8C%E6%99%AF/"},{"title":"AST","text":"前面课程，我们完成一对一的视频通话后，大体上熟悉了WebRTC的基本用法以及它的会话流程。WebRTC的本质就是 P2P，即点对点的即时通讯，而这节课我们的目标是学会如何完成 1 对多的会话模式。 基础构思在开始之前，我们先熟悉下这个最简单的讲课场景，首先看下图模拟场景，T 作为老师，需要将自己的画面实时地发送给下面的三个学生，但是学生却不需要将自己的画面同步给老师，而仅仅是在需要反馈的时候给予老师反馈即可。 说到这里，大家很明确这个场景实际就是一个小型直播，而我们这节课的目标也由此可以转变为“WebRTC实现简易直播系统”。 场景和目标清晰了，接下来就是构思和实战了。 WebRTC实现 P2P 视频通话以及 IM 大家都没问题，那么对于解决我们的目标而言都不成问题。T 和 S-1 、S-2、S-3 单独完成视频通话和普通消息发送都没问题，那怎么实现一次性同时和三个学生建立通话呢？ 很简单，老师 T 和他们三个单独建立视频通话后，将关联关系都保存在本地不就可以？ 前面我们反复提到过WebRTC的核心就是PeerConnection对象，任何建立视频通话的双方都离不开这个对象，因为这里面包含连接双方的核心协商数据。所以只要 T 和三个学生建立关联关系时，都维护一份独立的PeerConnection对象即可。 如上图，老师端保存三分独立的PeerConnection对象，而学生端只需要保存自己和老师的关联信息，即一份核心对象。用代码描述如下： 老师端 12345678// T：9999 S-1：10001 S-2：10002 S-3:10003 分别代表上面流程图中的师生var RtcPcMaps = new Map()const TS01= 9999 -10001const TS02= 9999 -10002const TS03= 9999 -10003RtcPcMaps.set(TS01, new PeerConnection()) //维护T-S-1关系RtcPcMaps.set(TS01, new PeerConnection()) //维护T-S-2关系RtcPcMaps.set(TS01, new PeerConnection()) //维护T-S-3关系 在老师 T 收到学生 S 需要关联的“意向”后，创建三个PeerConnection核心对象，去维护三分关系，然后将其保存在本地的集合中。 学生端 S-1 1234//S-1：10001var RtcPcMaps = new Map()const S01T= 10001-9999RtcPcMaps.set(S01T, new PeerConnection()) //学生维护和老师的关联 学生端 S-2 1234//S-2：10002var RtcPcMaps = new Map()const S02T= 10002-9999RtcPcMaps.set(S02T, new PeerConnection()) //学生维护和老师的关联 学生端 S-3 1234//S-3：10003var RtcPcMaps = new Map()const S03T= 10003-9999RtcPcMaps.set(S03T, new PeerConnection()) //学生维护和老师的关联 可以很清晰地看到，在学生端只需要维护一份和老师的关系即可，在建立关联之后，将老师的直播流拉取，然后在本地展示。 而老师端相对复杂些，需要维护 3 份关系，如果学生有 50 个的话，那么对象关联就需要创建 50 个，因此对于直播老师端而言，人数越多，需要维护的关联关系也就越多，同时需要给每个关系发送音视频媒体流。人数越多，宽带压力也随之而来，相关的配置我们在《02 | Web 端基础 API 学习》中概述了一些，具体消耗的宽带计算方式，我们在后面讲《11 | 会议优化：WebRTC 通话过程中宽带计算及网络速率优化》中会详细的介绍。 实战有了上面的大体构思和基础伪代码，接下来我们看看，从老师直播到学生观看直播，这整个过程我们架构上的整体设计。 首先，老师讲课学生听课，实际上就是在一个房间，老师在黑板书写，而学生看黑板。类比于网络，我们可以将这个房间“搬”到云上，老师在云房间直播，观众在云房间看直播。 所以，实际上我们整体的架构设计，就是围绕一个“云房间”展开，在云房间中观众和老师互动。 但是，问题来了，同一个房间中有老师和学生，那么如何区分老师和学生的身份呢？这就是我们架构设计上的第一个重点，那就是加入这个房间后，所有用户的身份标识。有了标识，后面加入的学生才知道和哪个有老师身份的用户进行WebRTC关联。 看下面客户端代码： 1234567this.formInline.nickname = getParams(&quot;nickname&quot;);this.formInline.roomId = getParams(&quot;roomId&quot;);this.formInline.userId = getParams(&quot;userId&quot;);this.formInline.pub = getParams(&quot;pub&quot;)? getParams(&quot;pub&quot;) : 'no';if(this.formInline.nickname &amp;&amp; this.formInline.roomId &amp;&amp; this.formInline.userId){ this.init()//连接服务器} 客户端携带加入房间的基础信息，有基础用户信息和 pub 这个身份信息，服务端接受这个参数后，将其保存在房间缓存信息中： 老师 T 端作为发布者，在加入房间后就需要发布自己的直播流，此时还没有任何学生和他建立连接。 12345678//?userId=9999&amp;roomId=10013&amp;nickname=S&amp;pub=pubinitMeetingRoomPc(){ if(that.formInline.pub === 'pub'){ this.localStream = await this.getLocalUserMedia() //将本地直播流挂到video标签，在自己的页面显示 this.setDomVideoStream(&quot;localdemo01&quot;,this.localStream) }} 学生 S 端进入房间后，首先获取用户列表，获取到用户列表后找到老师，和老师建立WebRTC连接。 12345678910111213141516171819202122232425262728//userId=1001&amp;roomId=10013&amp;nickname=S-01const localUid = this.formInline.userId//找到当前房间的视频流发布者 即主播let publisher = this.roomUserList.filter(e =&gt; e.userId !== localUid &amp;&amp; e.pub === 'pub').map((e,index) =&gt;{return e.userId})if(publisher.length &gt;0){ publisher = publisher[0]}else{ return;}//和发布者建立RTC连接 不发送自己视频流let pcKey = localUid+'-'+publisherconsole.log(&quot;pcKey&quot;,pcKey);//1001-9999 S-1：1001和老师9999let pc = RtcPcMaps.get(pcKey)if(!pc){ pc = new PeerConnection(that.rtcPcParams) RtcPcMaps.set(pcKey,pc)}pc.addTransceiver(&quot;audio&quot;, {direction: &quot;recvonly&quot;});pc.addTransceiver(&quot;video&quot;, {direction: &quot;recvonly&quot;});//创建offerlet offer = await pc.createOffer();//设置offer未本地描述await pc.setLocalDescription(offer)//发送offer给被呼叫端let params = {&quot;targetUid&quot;:publisher,&quot;userId&quot;:localUid,&quot;offer&quot;:offer}that.linkSocket.emit(&quot;offer&quot;,params)//监听相关事件 比如老师的应答信令，视频流等等that.onPcEvent(pc,localUid,publisher) 老师 T 端 ，收到学生的关联意向之后，① 创建关联关系并保存；② 添加监听；③ 将视频流添加到媒体轨道；④ 发送应答。 12345678910111213141516async onRemoteOffer(fromUid,offer){ const localUid = this.formInline.userId let pcKey = localUid+'-'+fromUid let pc = new PeerConnection(this.rtcPcParams) RtcPcMaps.set(pcKey,pc) console.log(&quot;老师监听到远端WebRTC意向&quot;,pc); this.onPcEvent(pc,localUid,fromUid) for (const track of this.localStream.getTracks()) { pc.addTrack(track); } pc.setRemoteDescription(offer) let answer = await pc.createAnswer(); await pc.setLocalDescription(answer); let params = {&quot;targetUid&quot;:fromUid,&quot;userId&quot;:localUid,&quot;answer&quot;:answer} this.linkSocket.emit(&quot;answer&quot;,params)} 以上就是教师授课直播的实战流程，其他的直播场景类比于此，都是一样的，老师即为主播，学生为观众，只不过是在我们代码层面将用户的标签设置为我们需要的而已。 项目操作指南 打开项目，找到模块：小型直播。 进入后默认没有任何参数，因此也需要携带 URL 参数，看下面访问参数，注意参数 pub这个参数是作为同一个房间中主播和非主播的区别的，因此你如果想体验主播端，那么请携带此参数，看下面案例： 123456# 主播进入 房间号：10012 用户ID：1001 用户昵称：suke001http://localhost:8080/demo03-one2many?userId=1001&amp;roomId=10012&amp;nickname=suke001&amp;pub=pub# 非主播进入 房间号：10012 用户ID：11111 用户昵称：US01http://localhost:8080/demo03-one2many?userId=11111&amp;roomId=10012&amp;nickname=US01# 非主播进入 房间号：10012 用户ID：22222 用户昵称：US02http://localhost:8080/demo03-one2many?userId=22222&amp;roomId=10012&amp;nickname=US02 在演示过程中大家可能会看到弹幕和虚拟背景相关的，大家不必着急，这个是后面的内容，这节课的核心是搞懂直播这个概念以及WebRTC如何实现小型直播的。 完整代码仓库地址本节课相关代码 课后题请大家先按照上述的过程完成本地的模拟场景，然后着重看下“ 学生 S 端 ”那里pc.addTransceiver()方法的作用（参考连接），如果去掉这行代码，你的直播代码又会变成什么样子，还能正常进行直播吗？欢迎大家在留言区讨论。","link":"/2023/02/01/webrtc/4.1%E5%AF%B9N/"},{"title":"AST","text":"从点对点视频通话到点到多的小型直播间，再到直播间虚拟背景的切换，如果认真消化完这些内容，那么我相信大多数人已经从小白正式入门WebRTC了。接下来这节课我们就先不讲WebRTC会议模式，我们先玩个好玩的，如题。 一般意义上要完成弹幕，首选必须是即时通讯，比如大家熟知的 Websocket，通过即时消息实现实时弹幕展示。但是我们在前面《04 | 实现点对点音视频及类 IM 的即时消息发送》那节课中提到了，利用WebRTC自己的实时数据传输通道即可实现类似 IM 的即时通讯功能，因此我们就用WebRTC自带的功能去完成“直播+滚动弹幕”。 正式开始之前，大家可以先翻到前面课程再熟悉下，我们接下来就直接进入主题。 基础流程 建立WebRTC会话，并在初始化监听阶段创建数据通道（DataChannel）。 12345678910111213141516/** * 创建数据通道 * @param {Object} pc * @param {Object} localUid * @param {Object} remoteUid */async createDataChannel(pc,localUid,remoteUid){ let datachannel = await pc.createDataChannel(localUid+'-'+remoteUid); console.log(&quot;datachannel &quot;+localUid+'-'+remoteUid,datachannel) dataChannelMap.set(localUid+'-'+remoteUid,datachannel)}//1.初始化 RTCPeerConnection =&gt; initPc//2.初始化基础监听 initPc.ontrack() initPc.ondatachannel() initPc.onicecandidate()//3.执行上步创建数据通道await this.createDataChannel(initPc,localUid,remoteUid) 通道建立成功，如果是 A 和 B 通话，那么 A 创建通道成功后，B 端则可以看到如下信息： 1234567891011121314pc.ondatachannel = function (ev) { console.log(&quot;用户：&quot; + remoteUid + &quot; 数据通道创建成功&quot;); ev.channel.onopen = function () { console.log(&quot;用户：&quot; + remoteUid + &quot; 数据通道打开&quot;); }; ev.channel.onmessage = function (data) { console.log(&quot;用户：&quot; + remoteUid + &quot; 数据通道消息&quot;, data.data); // 弹幕上屏幕 that.danmuForRoller(data.data); }; ev.channel.onclose = function () { console.log(&quot;用户：&quot; + remoteUid + &quot; 数据通道关闭&quot;); };}; 发送消息。 12//datasechannel 为创建通道端初始化后的通道实例datasechannel.send(this.message) 至此，数据通道的创建和消息发送都没有问题了，接下来就要我们本节课的大招了：利用数据通道打造实时弹幕。 注意事项前面的课程讲到基础流程，第二步就是创建通道者和创建成功的响应，也就是说 A 和 B 形成WebRTC关联，A 如果创建数据通道，那么这个数据通道的操作权限就在 A ，再明确点就是这个通道创建者才可以发消息，而和 A 形成关联关系的 B 仅仅是数据接受者。 有了上面的解释，我们就要思考下，直播间数据通道如何创建 。 直播间主播和观众是一对多的关系，因此在观众这一端只会存在一条发消息的数据通道和一条收消息的数据通道；在主播这一端则存在着 N 条数据发送通道，N 条接收消息的数据通道 （收消息的数据通道在这里虽然写了出来，但是并无需人工创建，拿前面例子： A 和 B 形成WebRTC关联之后，只要 A 创建了数据发送通道，那么 B 一定会存在与之对应的接受消息的数据通道）。 因此在实际编码过程中，我们的思路应该是考虑发消息的数据通道的创建，有了发送通道，在另一端必然存在接收通道。 观众端： 看下面代码，仅仅在加入直播间，以及主播建立关联关系后，创建一条数据发送通道即可，这样每个观众就可以将弹幕通过该通道发送给主播。 123456789101112131415161718192021//和发布者建立RTC连接 不发送自己视频流 let pcKey = localUid+'-'+publisher //初始化核心对象 PeerConnection let pc = RtcPcMaps.get(pcKey) if(!pc){ pc = new PeerConnection(that.rtcPcParams) RtcPcMaps.set(pcKey,pc) } // 设置仅接收流 不发送流 pc.addTransceiver(&quot;audio&quot;, {direction: &quot;recvonly&quot;}); pc.addTransceiver(&quot;video&quot;, {direction: &quot;recvonly&quot;}); //初始化一系列监听 比如主播媒体流 主播ICE协商信息等等 that.onPcEvent(pc,localUid,publisher) //创建数据通道 await this.createDataChannel(pc,localUid,publisher) //创建offer let offer = await pc.createOffer(); //设置offer未本地描述 await pc.setLocalDescription(offer) //发送offer给被呼叫端 ...... 主播端： 请注意，观众每次加进来都会和主播建立一次WebRTC关联，每次都会创建主播和该观众的数据通道并保存在本地数据通道 Map 中，如此主播在发送弹幕的时候，遍历拿到所有观众的数据通道，再通过该通道将消息广播，观众端即可看到主播的消息。 123456789101112131415161718192021async onRemoteOffer(fromUid,offer){ const localUid = this.formInline.userId let pcKey = localUid+'-'+fromUid //初始化核心对象PeerConnection 保存自己和直播间观众的关联关系 let pc = new PeerConnection(this.rtcPcParams) RtcPcMaps.set(pcKey,pc) //监听 ICE候选信息和观众端创建的数据通道 this.onPcEvent(pc,localUid,fromUid) //NOTE: 主播端创建数据通道，来一个观众建立一个通道 await this.createDataChannel(pc,localUid,fromUid) //发送主播的直播流 for (const track of this.localStream.getTracks()) { pc.addTrack(track); } pc.setRemoteDescription(offer) //其他操作 let answer = await pc.createAnswer(); await pc.setLocalDescription(answer); let params = {&quot;targetUid&quot;:fromUid,&quot;userId&quot;:localUid,&quot;answer&quot;:answer} this.linkSocket.emit(&quot;answer&quot;,params)}, 弹幕公共化看完上面的流程和代码，有细心的同学可能会发现，观众端只和主播建立了WebRTC关联，并没有和其他的观众建立关联，那么，怎么能看到其他观众发送的弹幕呢？ 这就要提到主播端维护的数据通道 Map了，利用这个 Map 中的通道，主播端可以将任何消息私信发给任何观众，因此当有观众发送弹幕到主播端的时候，主播利用该 Map 中的所有数据通道，将消息遍历发送给每个通道，即可实现弹幕的广播。 弹幕组件要实现弹幕，必不可少的就是弹幕组件了。本小册用到的组件如下： 1&quot;danmaku&quot;: &quot;^2.0.4&quot;, // npm install danmaku 即可安装 具体用法如下，注意看代码中的注释，弹幕组件和媒体播放容器绑定，因此在主播端和观众端需要区分，参数有颜色设置、速度设置，以及字体设置等等，具体大家可以看官方文档。 12345678910111213141516171819/** * 初始化弹幕容器 */initDanmuContainer(){ if(this.formInline.pub==='pub'){//主播 //增加弹幕组件 this.danmaku = new Danmaku({ container: document.getElementById('localdemo01Parent'), speed: 30 }); }else{ //客户端 this.danmaku = new Danmaku({ container: document.getElementById('publisherVideoParent'), speed: 30 }); } //首条弹幕 this.danmaku.emit({text: '直播间已开启，请踊跃发言', style: {fontSize: '20px',color: '#ff5500'}})}, 完整代码地址本节课相关代码位置 项目操作指南 打开项目，找到模块：小型直播。 直接点进去默认还是没有携带参数的，因此和前面的直播相关章节一样，都需要携带固定的参数。 如果你不想自己去换其他参数，那么启动前端和信令服务器后，直接在同一个浏览器三个不同的标签页访问下面地址。 123456# 主播进入 房间号：10012 用户ID：1001 用户昵称：suke001http://localhost:8080/demo03-one2many?userId=1001&amp;roomId=10012&amp;nickname=suke001&amp;pub=pub# 非主播进入 房间号：10012 用户ID：11111 用户昵称：US01http://localhost:8080/demo03-one2many?userId=11111&amp;roomId=10012&amp;nickname=US01# 非主播进入 房间号：10012 用户ID：22222 用户昵称：US02http://localhost:8080/demo03-one2many?userId=22222&amp;roomId=10012&amp;nickname=US02 操作：主播端在页面下方输入框输入消息，然后点击发送，注意观察 US01 和 US02 两端的控制台以及弹幕显示。 效果。 温馨提示 弹幕我是利用组件展示在 Video 元素之上，大家实际用的时候可能会自定义其他的展示窗体，因此你需要明白的是数据通道数据过来的代码位置，在这里你可以自定义数据操作逻辑。 课后题这节课算是把WebRTC的数据通道掌握了，实际上数据通道不仅仅可以实现弹幕，利用这个，还可以实现很多花样，课后大家可以再熟悉熟悉数据通道用法，传输文件、图片 等数据。","link":"/2023/02/01/webrtc/6.%E5%BC%B9%E5%B9%95/"},{"title":"AST","text":"到了这节课，想必大家对 WebRTC 已经有基础的了解了。毕竟从点对点视频通话到小型直播都已经熟悉了它的核心用法，WebRTC给大家的初步印象已经形成：即通过信令交换在各自的客户端形成 P2P 双向关联，然后发送双方的媒体信息。 无论是点对点音视频还是直播，都是通过 P2P 的方式形成关联关系，而接下来的多对多会议也是一样，无非就是每个客户端都去和会议室中的每个用户建立关联， 从而拿到对方的媒体信息。 接下来，我会再用一个例子给大家演示下如何用WebRTC实现会议系统。 流程分析假设有 A、B、C、D 四个人需要参会，但是WebRTC仅支持 P2P ，那么 A 如果要和剩下的三个人视频通话，就必须和他们三个人都建立关联，也就是形成A-B，A-C，A-D的关联关系 。 看上图所示，只有建立关联关系之后，A 才能将自己的视频流发给 B、C、D 三个人，同时也才能收到其余三个人的视频画面。但是注意看，A 和其余三个人形成视频通话，但是其余三人之间并没有相互关联。 也就是说，现在这个方案只是达成了 1 对多 的场景（前面的课程中的直播场景）。那么如何让其余三个人之间也形成互通呢？ 同理，看上图的 B，和 A 一样重新建立关联关系， 只不过变成 B 为主体，剩下的 A、C、D 为被关联对象进而形成B-A，B-C，B-D的关联关系 。但是这时你会发现，A-B 和 B-A 不是重复了吗？ 是的，所以在这里，我们相当于在代码层面维护重复判断，假如已经建立关联关系，那么后续就不再重新建立新的关联关系了。 从WebRTC的核心载体PeerConnection上来讲，上述的关联关系代表的就是这个核心载体，一对关联关系代表一个核心对象，**A-B** 这一关系从代码层面上来描述 ， 实际就是创建一个PeerConnection对象，这个对象中维护的是 A 和 B 之前的sdp信令 和媒体信息（反复提及的核心） 。 有了以上概念上的转换，我相信对于前面图中表达的意思，大家也就理解差不多了，为了更清晰，这里我再用代码层面的PeerConnection对象来解释上图中的关系： 首先 A 客户端需要和其余三个客户端通信，按照上述关系和WebRTC的会话流程，我们就需要创建三个PeerConnection对象来作为会话信令的载体，然后客户端还需要储存下这三个变量。这里为了操作方便，我们将其放置在Map数据结构中，key按照用户的 ID 组合成变量名，那么 A 和 B、C、D 关联关系储存方式如下： 12345678// A：10001 B：10002 C：10003 D：10004 分别代表四个客户端的用户IDvar RtcPcMaps = new Map()const ABKeys = 10001-10002const ACKeys = 10001-10003const ADKeys = 10001-10004RtcPcMaps.set(ABKeys , new PeerConnection()) //维护A-B关系RtcPcMaps.set(ACKeys , new PeerConnection()) //维护A-C关系RtcPcMaps.set(ADKeys , new PeerConnection()) //维护A-D关系 这样子是不是很清晰了，而对于被关联方 B、C、D 端同上述操作，只不过仅维护和 A 的关系，例如 B： 123var RtcPcMaps = new Map()const BAKeys = 10002-10001RtcPcMaps.set(BAKeys , new PeerConnection()) //维护B-A关系 在 B 端这边，细心的同学可能发现了，这里我们定义的变量为 BAKeys ，即B-A，在 A 端明明是 A-B，在这里为什么关系反了呢？ 这里大家其实可以思考下，如果 B 端我作为主体方，即 P2P 的发起方，那么和上图中的 A 一样，我也需要创建三个关联关系 B-A、B-C、B-D，此时 B-A 就和 A-B 关系重叠了，在代码层面实际上它俩就是同一对关联。 所以，为了维护代码层面的简洁性和逻辑直观性，我们可以适当优化下，P2P 发起方变量命名和 P2P 接受方变量命名 ， 按照自己客户端拼接对方客户端的形式 （A 和 B 建立关联，在 A 端就是 A-B 变量维护，在 B 端就是 B-A 变量维护） 。 再接着前面的代码，B 现在只维护了一份和 A 的关系，但是为了实现会议的效果，B 必须和 C、D 继续形成关联关系，所以此时 B 这边： 12345//由于前面A已经和B建立关联关系因此在后续B这边不再重新发起和A的关联关系const BCKeys = 10002-10003const BDKeys = 10002-10004RtcPcMaps.set(BCKeys , new PeerConnection()) //维护B-C关系RtcPcMaps.set(BDKeys , new PeerConnection()) //维护B-D关系 虽然看起来很绕，但是如果我们理清楚这个逻辑，实际实现起来和 P2P 的流程一样，很简单。先看看下图，第一个就是我们前面所说的独立关联关系，第二个是美化后以及代码层面优化后的流程（ 即已建立关联后不再重新建立新的关联 ）。 如果能明白上面的逻辑，那么我们就理解了WebRTC架构中最简单的，维护最方便的 Mesh 架构 。这种架构不需要经过任何流媒体服务器，端对端的就可以直接实现多人视频通话，虽然简单，但是也有它的缺点，那就是昂贵的宽带，下一节我们会深入讨论。 代码实战我们按照下面动图流程来： A 进入会议室：初始化信令服务器连接，然后初始化房间，如果房间中没有人，则仅获取本地媒体流并将其展示在已初始化好的 DOM 节点 。 roomUserList 变量为房间用户，获取全部用户后，剔出自己，然后看有无其他用户加入房间。 12345678910111213141516171819//初始化服务器连接this.linkSocket = io(this.$serverSocketUrl, { reconnectionDelayMax: 10000, transports: [&quot;websocket&quot;], query: that.formInline});//async initMeetingRoomPc(){ const that = this if(!this.localStream){ this.localStream = await this.getLocalUserMedia() //开始静音和关闭摄像头 this.initMediaStatus() } this.setDomVideoStream(&quot;localdemo01&quot;,this.localStream) const localUid = this.formInline.userId let others = this.roomUserList.filter(e =&gt; e.userId !== localUid).map((e,index) =&gt;{return e.userId}) //others 为空不再进行后面的, B 用户同上：先初始化，然后获取房间用户列表。与此同时，本地获取自己的媒体流。但是与上面 A 不同的是，B 加入后，A 已经在房间中，因此接下来就是 B 和 A 创建 RTC 关联。创建流程我们不再阐述，和之前 P2P 以及直播都一样，无变化。 12345678910111213141516171819202122232425262728293031async initMeetingRoomPc(){ const that = this if(!this.localStream){ this.localStream = await this.getLocalUserMedia() //开始静音和关闭摄像头 this.initMediaStatus() } this.setDomVideoStream(&quot;localdemo01&quot;,this.localStream) const localUid = this.formInline.userId let others = this.roomUserList.filter(e =&gt; e.userId !== localUid).map((e,index) =&gt;{return e.userId}) //others 不为空 里面有 A用户 others.forEach(async (uid) =&gt; { let pcKey = localUid+'-'+uid let pc = RtcPcMaps.get(pcKey) if(!pc){ pc = new PeerConnection(that.rtcPcParams) RtcPcMaps.set(pcKey,pc) } for (const track of that.localStream.getTracks()) { pc.addTrack(track); } //创建offer let offer = await pc.createOffer({iceRestart:true}); //设置offer未本地描述 await pc.setLocalDescription(offer) //发送offer给被呼叫端 let params = {&quot;targetUid&quot;:uid,&quot;userId&quot;:localUid,&quot;offer&quot;:offer} that.linkSocket.emit(&quot;offer&quot;,params) that.onPcEvent(pc,localUid,uid) })}, C 用户进入会议室：初始化服务连接，获取房间用户，同时本地媒体流获取和预览。但房间中有 A 和 B，因此和 B 步骤一样。 C 和 A 创建 RTC 关联。 C 和 B 创建 RTC 关联。 根据 上面的步骤 ， 我们就可以还原如下流程了 。 在整个房间人员变动中，无论如何 ， 新进来的用户都会去和房间内的其他人进行 RTC 关联 ， 并实现新用户媒体流广播，从而达到我们这节课的目的：Mesh 架构的会议系统。 项目操作指南 打开项目，找到模块：多对多网络视频。 点击进去后首先会显示填写基础信息，要体验会议那么要加入的用户必须在同一个房间；此外，请大家注意下面图中的身份ID，它默认获取的是当前浏览器的指纹，因此如果在同一个浏览器不同标签页访问页面当前页面时身份ID都是一样的。 为了避免这个问题请大家注意我访问的时候携带的参数，这个参数优先于浏览器指纹且手动指定 ，这样就可以避免不同用户身份ID一样造成加入会议失败的情况。 用不同的身份 ID，但是同一个房间号进入会议室。 完整代码地址本节课相关代码仓库地址 课后题在本地启动成功并模拟会议成功后，请大家尝试部署到区域网的某个主机上，然后通过区域网进行多人会议看看效果如何，有问题大家留言一起讨论。","link":"/2023/02/01/webrtc/7.%E5%A4%9A%E5%AF%B9%E5%A4%9A-mesh%E6%9E%B6%E6%9E%84/"},{"title":"AST","text":"这节课我们正式进入第二阶段。实战开始前，我们先来了解下 Janus 是什么，以及我们为何用 Janus？此外，我们还需要补充一个概念：WebRTC网关。 音视频时代，简单的音视频通话功能已经远远无法承载这个时代的更多需求，比如视频云录制、呼叫转移、视频流 AI 检测、视频流增强、信令暂存、和已有其他通信协议互相嫁接等等。这些庞大且涉及到复杂计算的能力，必须交给具有一定能力的服务来做，因此就有了WebRTC网关，本节课所提到的 Janus 就是其中一种开源且稳定更新的WebRTC网关。 Janus 相关地址 Janus 官网地址：官网。 Janus 仓库地址：Github。 Janus 非官方容器构建仓库 ：Github。 Janus 具有的基本功能 回声测试、会议桥、媒体记录器、SIP 网关等基本功能。 可插拔的，按需引入所需的功能，比如会议功能、p2p通信功能、录制功能、播放第三方媒体流、屏幕共享等等，要实现对应功能，可单独引入对应插件，因为 Janus 的设计架构就是插拔式的。 自带用户统计，只需要按照特定的格式去请求即可，相当于给你提供了 WebSocket 服务器，你只需要按照规范来即可。 使用json作为向服务器请求服务的参数，简洁。 事件回调，接受自定义接口作为回调接口传回事件数据。 看上面的基本功能，我们可以很清晰地知道，有了 Janus，我们就无需自己实现信令服务器。 Janus 高级功能看官网的第一眼我们就能够发现，整个首页最突出的一个单词 multistream，这也是 Janus 从 0.X 版本过渡到 1.X 版本的重要体现。这个突出功能允许客户端可以发送多个视频流给客户端，而不用局限于只能发送一个视频流造成需要频繁切换画面的窘境。 另一个重要的功能就是 simulcast，这个功能允许客户端在单个会话中同时发送多个不同分辨率的视频流。如此一来，接收端就可以根据实际需要动态选择要接收的视频流，提高视频通信的效率和质量。 大家可以畅想一下，在多人会议中，全部参会人员的网络状况是不是都稳定？和我们看视频一样，视频格式有高清、超清、蓝光、4K 等不同的分辨率，就是为了适应不同客户端、不同的网络状况。 好了，了解完 Janus 的大体功能，接下来就是实战搭建了。 网关服务搭建说明Janus 是使用 C++ 开发的，中间使用了很多其他的开源组件，因此环境配置也比较麻烦。但是流行的服务容器化趋势带给我们诸多便利，Janus 也一样有对应的容器版本。大家在 Docker Hub 上输入关键词 janus-webrtc-gateway-docker 就可以看到有很多不同用户构建的容器版本： 值得注意的是，前面两个下载量较多的已经是三年前的了，而 Janus 至今已经更新 N 多个版本了，老版本必然会和新版本不适配，请大家看下面官网说明： 当然大家无需担心新版本没有对应的容器版本，大家可以看看上面截图中的第三个，这个容器版本是我定期从官网拉取最新代码构建的，和 Janus 新版本对应（ DockerHub &amp; Github ）。如下图中左侧是我构建的容器版本，右侧是对应 Janus 的版本，每当它发版我都会去构建最新的容器。 服务器搭建 准备服务器，且下载安装 Docker 和 Docker Compose 环境（这个网上很多我就不再介绍）。 路径以及配置文件准备（网络不通畅的同学直接使用 GitHub1s打开拷贝内容即可），如果你下载下来了，那么建议你再检查下文件内容是否正确。 12345678910mkdir -p /home/janus-docker/confmkdir -p /home/janus-docker/sslmkdir -p /home/janus-docker/recordcd /home/janus-docker/conf## 下载下面配置文件 如果网络打不开可以尝试 github 替换为 github1s如上图https://github.com/meetecho/janus-gateway/blob/master/conf/janus.jcfg.sample.inhttps://github1s.com/meetecho/janus-gateway/blob/master/conf/janus.transport.http.jcfg.samplemv janus.jcfg.sample.in janus.jcfgmv janus.transport.http.jcfg.sample janus.transport.http.jcfg## 后面我们还会遇到各种插件同样的下载方法 最核心的就是上面俩个 docker-compose 文件创建以及路径挂载。 1234567891011121314cd /home/janus-docker &amp;&amp; touch docker-compose.yml-------------------yaml文件内容配置-------------------------------version: '1.1.0'services: janus-gateway: image: 'sucwangsr/janus-webrtc-gateway-docker:20221018' command: [&quot;/usr/local/bin/janus&quot;, &quot;-F&quot;, &quot;/usr/local/etc/janus&quot;] network_mode: &quot;host&quot; volumes: - &quot;/home/janus-docker/conf/janus.transport.http.jcfg:/usr/local/etc/janus/janus.transport.http.jcfg&quot; - &quot;/home/janus-docker/conf/janus.jcfg:/usr/local/etc/janus/janus.jcfg&quot; - &quot;/home/janus-docker/record:/home/janus-gateway/record&quot; - &quot;/home/janus-docker/ssl:/home/ssl&quot; restart: always 修改基础配置。 janus.jcfg 中找下面条目配置修改，一定要注意找到对应的位置哦。 api_secret 为我们后面常用的重点配置，Rest API 的通行证。 12345678910111213141516171819202122232425##新版本中下面这几个路径在配置文件中是@@变量赋值，这里大家可以直接写成下面的configs_folder = &quot;/usr/local/etc/janus&quot;plugins_folder = &quot;/usr/local/lib/janus/plugins&quot;transports_folder = &quot;/usr/local/lib/janus/transports&quot;events_folder = &quot;/usr/local/lib/janus/events&quot;loggers_folder = &quot;/usr/local/lib/janus/loggers&quot;-------------------------api_secret = &quot;sujanxxusrocks&quot; ## 客户端使用restApi用的token 请自行配置自己的(重点配置)token_auth_secret = &quot;sujanxxusrocks&quot; ## 使用ws使用的token 请自行配置自己的token_auth = true ## 使用开启校验wsadmin_secret = &quot;suaanusoverlord&quot; #管理员 请自行配置自己的---------------media: { #ipv6 = true #min_nack_queue = 500 rtp_port_range = &quot;17001-19001&quot; ## 请开放公网服务器的安全组(UDP) #dtls_mtu = 1200 #no_media_timer = 1 #slowlink_threshold = 4 #twcc_period = 100 #dtls_timeout = 500。。。。。}-----------------## 当然还有其他的配置 比如stun 、turn、nat_1_1_mapping等这里先不用管 janus.transport.http.jcfg 配置 12345general: { base_path = &quot;/janus&quot; #基础路径 http = true # http开启 port = 18088 #http端口 https = false #https是否启用配置；启用的话后面就要配置ssl证书。 启动。 1234567891011121314151617181920212223242526272829cd /home/janus-dockerdocker-compose up -d## 启动完毕后docker-compose logs -f------------------部分日志-------------------------janus-docker-janus-gateway-1 | Loading plugin 'libjanus_echotest.so'...janus-docker-janus-gateway-1 | JANUS EchoTest plugin initialized!janus-docker-janus-gateway-1 | Loading plugin 'libjanus_audiobridge.so'...janus-docker-janus-gateway-1 | Joining Janus requests handler threadjanus-docker-janus-gateway-1 | Sessions watchdog startedjanus-docker-janus-gateway-1 | JANUS AudioBridge plugin initialized!janus-docker-janus-gateway-1 | Loading plugin 'libjanus_recordplay.so'...janus-docker-janus-gateway-1 | JANUS Record&amp;Play plugin initialized!janus-docker-janus-gateway-1 | Loading plugin 'libjanus_sip.so'...janus-docker-janus-gateway-1 | JANUS SIP plugin initialized!janus-docker-janus-gateway-1 | Loading plugin 'libjanus_streaming.so'...janus-docker-janus-gateway-1 | JANUS Streaming plugin initialized!janus-docker-janus-gateway-1 | Transport plugins folder: /usr/local/lib/janus/transportsjanus-docker-janus-gateway-1 | Loading transport plugin 'libjanus_websockets.so'...janus-docker-janus-gateway-1 | libwebsockets logging: 0janus-docker-janus-gateway-1 | Websockets server started (port 8188)...janus-docker-janus-gateway-1 | JANUS WebSockets transport plugin initialized!janus-docker-janus-gateway-1 | Loading transport plugin 'libjanus_http.so'...janus-docker-janus-gateway-1 | WebSockets thread startedjanus-docker-janus-gateway-1 | HTTP webserver started (port 18088, /janus path listener)...janus-docker-janus-gateway-1 | Admin/monitor HTTP webserver started (port 18089, /adminsuc path listener)...janus-docker-janus-gateway-1 | JANUS REST (HTTP/HTTPS) transport plugin initialized!janus-docker-janus-gateway-1 | [WARN] libnice version outdated: 0.1.15.1 installed, at least 0.1.16 recommended. Notice the installed version was checked at build time: if you updated libnice in the meanwhile, re-configure and recompile to get rid of this warningjanus-docker-janus-gateway-1 | HTTP transport timer started 温馨提示 搭建过程中我们需要注意的几个点： rtp_port_range：RTP 端口配置，Janus 作为 WebRTC 的网关，最离不开的就是和 “流” 打交道，WebRTC 实现的视频音频通话，涉及到的所有的媒体流发送和接收，都是 通过 RTP 协议包。网关也一样，在每个客户端和网关服务器连接的过程中，这个流首先是要经过 Janus 的。因此，这个端口必须要放行，Janus 是自己配置了端口的，但是有些时候，我们不方便将该区间的端口开放，因此这个参数的目的就是让我们可以动态更改默认的 RTP 端口。 http/https：这俩参数大家可以同时启用，也可以只用其中一个，我建议是只开放 Http 即可，要想使用 Https ，则可以通过该服务器指定的域名搭配 Nginx 代理映射即可，这样就无需单独为 Janus 维护一份 Https 证书。 我在配置中注释的配置文件路径，这些路径在老版本中都是放行且固定的，无需自己配置。但是新版本中这些路径是要自己手动打开且自行配置的。 nat_1_1_mapping：这个参数在内网映射公网时是用的到的，比如你的内部地址：192.168.101.1，要映射到公网 x.x.x.x，那么你就要配置这个参数。尤其你的Janus部署在公网，那么这个地址填写公网 IP，当然一般私有化都是在内网的，可以不用处理 。 好了，这节课我们了解了WebRTC网关 Janus，同时也在服务器上搭建了该网关，下节课我们来学习如何将 Janus 用到我们的实际项目中。 课后题自己按照上面的步骤，完整部署一个 Janus 网关服务。","link":"/2023/02/01/webrtc/8.janus%E5%88%9D%E8%AF%86%E5%8F%8A%E6%90%AD%E5%BB%BA/"},{"title":"AST","text":"在初步尝试完第一个点对点音视频呼叫插件之后，这节课我们就要深入到会议系统实战了。既然是会议，那就肯定离不开 “多人” 和 “多房间” 这两个概念了。这两个概念和我们的 Janus 网关搭在一起的话，那必然是离不开 VideoRoom 插件的，因此我们这节课的目的就是使用VideoRoom 插件完成第二种架构的会议系统。 在正式开始之前，我们还要注意标题中提到的“第二种架构”这个关键词，我们在学第一种会议系统的时候，用的架构是 Mesh架构，而在本节课很明显就不再是 Mesh架构了，而是一种全新架构：SFU架构。 我们先回顾下在小册《09 |会议实战：WebRTC 实现多房间多用户的第一种架构会议系统》这一讲中已经学过的 Mesh 架构的大体架构图： 简述就是：你要和 N 个客户端通话，前提是你必须与这 N 个客户端都一一建立 WebRTC 关联。 而这节课的 SFU 架构图如下： 我们对着架构图，利用实际场景来解读下当前架构的工作流程。 前置条件： 有三个客户端浏览器 A、B、C ，一个 Janus 网关服务器，三个客户端要借助网关的能力达到视频会议的目的。 通话流程： A、B、C 三个客户端开始通话之前，并不是简简单单地在 Janus 网关中注册自己的信息就行了，对于 P2P 通话而言，进行注册后直接呼叫即可（上一节内容），但是在本节会议插件中是不行的。 要实现会议的功能，客户端在完成注册信息到网关之后，还要和 Janus 网关进行 RTC关联，对的你没看错，是和网关，而不是直接和别的客户端进行 RTC关联。这里网关担任的角色类似一个“房产中介”，所有要参会的客户端都可看作是“房东”，而客户端的媒体流可看作是“房东”的“房子”，这样类比下来，我们的网关是不是很形象了？ 等所有的客户端都和网关关联之后，这些客户端就可以自己去订阅和自己在同一个会议室的客户端媒体流了。这整个过程，实际上就是房东将房子挂在中介，然后想要房子的人去中介那里去购买一样。 再看架构图 A、B、C 在和 SFU 网关进行 RTC 关联之后，A 订阅 B、C 的媒体流并不需要再去和 B、C 去“打交道”，而是直接和网关交互，这就是 SFU 架构下媒体交互的基础流程。 SFU 架构优缺点： 节约宽带 。在当前架构中，可以很明显地看到，任意一个客户端只需要向网关发送一份媒体流即可。 扩展性更强 。服务端可容纳的客户端更多。 控制媒体 。因为涉及到了中间服务器，那么必然是可以对媒体流进行处理的，比如录制、参数调节、画面变更等。 安全 。同上条，在接收到媒体包之后，服务端可以动态进行加密等。 服务端压力大 。因为所有的媒体流的转发交互基本都在服务端，如果涉及到录制等，对服务器压力更大，同时服务端所需的宽带也有一定的要求。 讲完了 SFU 架构的相关概念后，我们通过 Janus 的会议插件去具体实战下，实现我们小册的第二个目标：第二种架构的会议系统。 会议插件初始化初始化的核心和上一节 videoCall插件一样，我们从开始就讲过了，Janus 的特性就是 “即插即拔”，videoCall插件的初始化也是一样的。 除了初始化之外，里面涉及的的回调方法也是通用的，但是回调的具体参数是做了区分的，这个我们后面仔细看下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647initVideoRoomPlugin(){ const that = this janus.attach({ plugin: &quot;janus.plugin.videoroom&quot;, opaqueId: opaqueId,//客户端唯一标识 success: function(pluginHandle) { //插件初始化成功后 pluginHandle 就是全局句柄，通过 pluginHandle可以操作当前 //会话的所有功能 videoRoomPluginHandle = pluginHandle console.log(&quot;会议插件初始化成功&quot;) }, error: function(cause) { //插件初始化失败 }, webrtcState: function(on) { console.log(&quot;WebRTC PeerConnection 状态 is &quot; + (on ? &quot;up&quot; : &quot;down&quot;) + &quot; now&quot;); }, slowLink: function(uplink, lost, mid) { console.warn(&quot;Janus 问题报告： &quot; + (uplink ? &quot;sending&quot; : &quot;receiving&quot;) + &quot; packets on mid &quot; + mid + &quot; (&quot; + lost + &quot; lost packets)&quot;); }, onmessage: function(msg, jsep) { console.log(&quot;msg&quot;,msg) //msg 交互信息包括挂断 接听等事件监听 // jsep 协商信令 that.onMessageForVideoRoom(msg,jsep) }, onlocaltrack: function(track, added) { console.log(&quot;本地媒体&quot;,track,added) if(added===true){ that.setDomVideoTrick(&quot;localDomId&quot;,track) } }, onremotetrack: function(track, mid, added) { }, oncleanup: function() { // PeerConnection 关闭监听 // 同时可以创建信的句柄(旧的可用)重新初始化 }, detached: function() { // PeerConnection 关闭监听 // 同时可以创建信的句柄（旧的不可用）重新初始化 } });}, 会议插件基本功能初始化完成之后就是使用了，而使用的具体细节就需要看看 videoRoom插件的具体功能了，下面我们来看看插件的基本功能和基础用法。 动态创建会议室 。要实现会议，前提条件就是可以动态提供不同的房间让不同的客户端去加入，videoRoom插件提供了对应创建房间的 API ，具体参数看下面代码注释： 12345678910111213141516171819202122232425createJanusRoom(roomId,roomUserCount,bitrate,pin,desc){ const that = this; let create = { request : 'create', room: parseInt(roomId),//房间号 必须为数字类型 bitrate: bitrate ? parseInt(bitrate)*1000: 300*1000,//比特率 限制房间内速率 publishers: roomUserCount? parseInt(roomUserCount) : 12,//参与人数 设置房间的最大容纳人数 description:desc,//房间描述 备注 自定义房间名称 record : false,//（是否要录制这个房间，默认=false） rec_dir : &quot;/home/janus-gateway/record/&quot;, //&lt;文件夹应存储录音，启用时&gt; permanent:false,//是否持久化 如果为true则服务重启后此房间还是存在，并不会因为服务重启而房间丢失 audiolevel_event:false, //向其他用户发送事件 audio_active_packets:50 //音频级别的数据包数量，默认=100，2秒 这个在语音激励有很大作用 } if(pin){ create.pin = pin; //加入房间所需的密码 create.secret = pin;//编辑/销毁房间所需的密码 } videoRoomPluginHandle.send({ &quot;message&quot; : create, success: function(result) { Janus.log(&quot;创建房间结果&quot;,result) } }) }, 房间用户获取和控制 。有了会议室，正常操作就是实时获取房间用户列表，并控制对应房间用户，比如踢出、静音等操作。 123456789101112131415161718192021//房间用户列表加载videoRoomPluginHandle.send({ message: { request: &quot;listparticipants&quot;, room: this.roomNumber, }, success: function (result) { Janus.log(result); },});//踢出房间videoRoomPluginHandle.send({ message: { request: &quot;kick&quot;, room: this.roomNumber, id: userId, }, success: function (result) { console.log(result); },}); 加入房间并实现视频通话功能 。这个功能也是目前这节课的核心功能了，videoRoom插件在实现多人视频通话的设计上很巧妙，它将用户分为发布者和订阅者两种大类，发布者即为媒体流的发布用户，而订阅者即为订阅发布者媒体流的用户。 看上图，仔细想想发布者和订阅者，如果取交集，那不就是我们会议中的参会人员吗？在发布自己的画面的同时也要获取其他用户的画面。而 videoRoom巧妙的设计，不仅仅可以让我们用该插件实现会议，同时也可以实现直播室（一个 pub，N 个 sub）。当然这个功能也让房间变得更加灵活，在众多人参会的情况下，我们可以选择自己想要订阅的媒体流，比如 30 个人都开了摄像头，但是你可以只订阅其中的指定用户。 实战会议通过前面基本功能概述，我们对videoRoom插件有了基本认识，而发布者订阅者角色的分离，也让我们业务代码处理更加灵活，接下来就看看具体实现会议的流程和细节吧！ 用户加入房间 。 123456789101112131415161718192021joinRooom(){ const join = { request: &quot;join&quot;, room: parseInt(this.roomNumber),//房间号 数字类型 // pin: &quot;123&quot;,//房间密码 id: this.userId,//用户ID 数字类型 ptype: &quot;publisher&quot;, //用户类型 发布者 display: this.username //展示昵称 }; //全局句柄 videoRoomPluginHandle.send({ 'message':join, success: function (res) { console.log(&quot;正在加入会议室：&quot;+that.roomNumber+&quot; 用户: &quot;+that.username) }, error: function (err){ console.log(&quot;加入过程中出错&quot;,err) } })} 发布自己媒体流 。加入成功后，可以自己选择是否发布媒体流，按照实际情况来即可，这里我按照常规的来。 12345678910111213141516171819publisherStream(){ const that = this //send offer 这里所有的协商都是和Janus服务器进行的 P2P协商，也就是你进行的会话网关服务器暂时替你完成 videoRoomPluginHandle.createOffer({ tracks: [ { type: 'audio', capture: true, recv: false }, { type: 'video', capture: true, recv: false }, { type: 'data' }, ], success: function(jsep) { console.log(&quot;发布者 SDP!&quot;, jsep); const publish = { request: &quot;configure&quot;, audio: true, video: true,restart:true} videoRoomPluginHandle.send({ message: publish, jsep: jsep }); }, error: function(error) { console.error(&quot;WebRTC error:&quot;, error); } })}, 监听服务器响应的事件 。在和网关服务器完成 P2P 连接后，其他用户加入的房间如果发布或暂停媒体信息网关服务器则会通知先前加入的用户，以让其他用户同步做出变更。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253onMessageForVideoRoom(msg,jsep){ const that = this const event = msg[&quot;videoroom&quot;] if(jsep) { //设置远程应答描述 videoRoomPluginHandle.handleRemoteJsep({ jsep: jsep }) } switch (event){ case 'joined': that.private_id = msg['private_id'] that.publisherStream() //媒体发布者 if(msg[&quot;publishers&quot;]) {//新加入房间获取媒体发布者(注意这里) const list = msg[&quot;publishers&quot;]; for(let u in list) { let publisher = list[u] that.localPubDomPush(publisher[&quot;id&quot;],publisher[&quot;display&quot;]) that.streamMap.set(publisher[&quot;id&quot;],publisher) that.subscriberMedia(publisher) } } break case 'event': if(msg['unpublished']){ console.log('用户'+msg['unpublished']+'停止发布流') }else if(msg['leaving']){ if(msg['reason'] &amp;&amp; msg['reason'] === 'kicked'){ console.log('您已被踢出房间') this.streamMap = new Map() }else if(!msg['reason']) { that.streamMap.delete(msg['leaving']) console.log('用户'+msg['leaving']+'主动离开房间'+msg['room']) } }else if(msg['moderation'] &amp;&amp; msg['moderation'] === 'muted' ){ console.log('用户'+msg['id']+' 已被禁言') }else if(msg['publishers']){//已在房间用户监听到媒体变更（注意这里） const list = msg[&quot;publishers&quot;]; for(let u in list) { let publisher = list[u] that.localPubDomPush(publisher[&quot;id&quot;],publisher[&quot;display&quot;]) that.streamMap.set(publisher[&quot;id&quot;],publisher) that.subscriberMedia(publisher) } }else if(msg['error_code']){ if(msg['error_code'] === 426){ } } break default: break } }, 请注意我在上面代码中标注的两个位置，这两个位置的代码都是一样的，都是订阅用户媒体流。第一个是用户刚加入房间时，订阅房间已存在发布媒体信息；而第二个则是当用户已经在开会过程中，监听到其他新的媒体发布者进来后再订阅媒体流。 订阅媒体流 。 订阅的步骤看起来代码很多，但是思路清晰了也没啥难度：第一发送订阅请求，第二和网关服务器完成 WebRTC 的基本会话流程，之后服务端就会转发媒体流到客户端。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 订阅当前房间媒体流 * @param user (publisher 媒体发布者)(id,display,audio,video) */subscriberMedia(user){ const that = this; var publisherPlugin = null janus.attach({ plugin: &quot;janus.plugin.videoroom&quot;, success: function(pluginHandle) { publisherPlugin = pluginHandle var subscribe = { request: &quot;join&quot;, room: that.roomNumber,//指定订阅房间 // pin: this.roomSecret,//房间密码 ptype: &quot;subscriber&quot;,//类型 订阅者 feed: user['id'],//被订阅用户ID 新版本API 更改为指定订阅数组 具体看课程后面仓库最新源代码 subscription.push({feed: user['id'],mid: stream.mid //这里是可选项 果不填则默认获取所有的流}); private_id: that.private_id,//Janus分配的用户ID }; publisherPlugin.send({ message: subscribe }); }, error: function(error) { console.error(&quot; 插件加载异常&quot;, error); }, consentDialog: function(on) { }, onmessage: function(msg, jsep) { console.log(&quot;订阅媒体发布者消息监听：&quot;,msg,jsep) const event = msg[&quot;videoroom&quot;]; if(jsep) { // Answer and attach publisherPlugin.createAnswer( { jsep: jsep, tracks: [ { type: 'data' } ], success: function(jsep) { Janus.debug(&quot;Got SDP!&quot;,jsep); //订阅成功后start 这个目的是完成 WebRTC的基础流程 var body = { request: &quot;start&quot;, room: that.roomNumber }; publisherPlugin.send({ message: body, jsep: jsep }); }, error: function(error) { Janus.error(&quot;WebRTC error:&quot;, error); } }); } switch (event){ case 'attached': console.log('订阅用户：'+user['display']+' 媒体信息成功') break default: break } }, onlocaltrack: function(track, added) { console.log('publisherOperator#onlocaltrack=&gt; ',track, added) }, onremotetrack: function(track, mid, added) { // The publisher stream is sendonly, we don't expect anything here let obj = { track:track, mid: mid, added: added, userId: user['id'],//被订阅用户ID display: user['display'],//被订阅用户昵称 trackKind: track['kind']//类型 video/audio } console.log(&quot;订阅媒体流变更信息 ：&quot;,obj) //挂在到指定的DOM即可 if(added){ that.setDomVideoTrick(user['id']+'-video',track) } }, oncleanup: function() { console.log(&quot; ::: Got a cleanup notification: we are unpublished now :::&quot;); } });}, 好了，以上就是利用 videoRoom 插件的巧妙设计（媒体发布和订阅交集）实现 SFU 架构会议系统的基本步骤，整个流程很简单，需要大家要注意的点也就是其中的媒体发布和媒体订阅代码逻辑。 项目操作指南 打开项目，打开下面模块：Janus 会议室。 先创建房间，然后点击加入房间。创建房间只需第一次访问的时候创建即可，之后会在网关服务器内存中保存，如果想要持久化，则可以看前面创建房间的配置。 用户 ID 不用更改，默认使用时间戳；修改用户名让不同用户加入到同一个房间。 代码仓库本接口代码仓库地址 课后题这节课我并没有将除了会议的其他功能写在 DEMO 中，课后大家在实现会议功能之后，尝试将踢人、麦克风控制、视频控制等操作加在上面，看看有没有难度。","link":"/2023/02/01/webrtc/9.%E5%A4%9A%E5%AF%B9%E5%A4%9A-sfu%E6%9E%B6%E6%9E%84/"},{"title":"联邦模块","text":"Webpack Module Federation 英文社区 Webpack Module Federation 的文章“A game-changer in JavaScript architecture”， MF 有不少实用性强的特性： 应用可按需导出若干模块，这些模块最终会被单独打成模块包，功能上有点像 NPM 模块； 应用可在运行时基于 HTTP(S) 协议动态加载其它应用暴露的模块，且用法与动态加载普通 NPM 模块一样简单； 与其它微前端方案不同，MF 的应用之间关系平等，没有主应用/子应用之分，每个应用都能导出/导入任意模块； 等等。 Webpack 5 之 模块联合（Module Federation）》 简单示例Module Federation 的基本逻辑是一端导出模块，另一端导入、使用模块，实现上两端都依赖于 Webpack 5 内置的 ModuleFederationPlugin 插件： 对于模块生成方，需要使用 ModuleFederationPlugin 插件的 expose 参数声明需要导出的模块列表； 对于模块使用方，需要使用 ModuleFederationPlugin 插件的 remotes 参数声明需要从哪些地方导入远程模块。 示例文件结构： 1234567891011121314151617181920MF-basic├─ app-1│ ├─ dist│ │ ├─ ...│ ├─ package.json│ ├─ src│ │ ├─ main.js│ │ ├─ foo.js│ │ └─ utils.js│ └─ webpack.config.js├─ app-2│ ├─ dist│ │ ├─ ...│ ├─ package.json│ ├─ src│ │ ├─ bootstrap.js│ │ └─ main.js│ ├─ webpack.config.js├─ lerna.json└─ package.json 其中，app-1、app-2 是两个独立应用，分别有一套独立的 Webpack 构建配置，类似于微前端场景下的“微应用”概念。在本示例中，app-1 负责导出模块 —— 类似于子应用；app-2 负责使用这些模块 —— 类似于主应用。 先看模块导出方 —— 也就是 app-1 的构建配置： 1234567891011121314151617181920212223242526272829303132const path = require(&quot;path&quot;);const { ModuleFederationPlugin } = require(&quot;webpack&quot;).container;module.exports = { mode: &quot;development&quot;, devtool: false, entry: path.resolve(__dirname, &quot;./src/main.js&quot;), output: { path: path.resolve(__dirname, &quot;./dist&quot;), // 必须指定产物的完整路径，否则使用方无法正确加载产物资源 publicPath: `http://localhost:8081/dist/`, }, plugins: [ new ModuleFederationPlugin({ // MF 应用名称 name: &quot;app1&quot;, // MF 模块入口，可以理解为该应用的资源清单 filename: `remoteEntry.js`, // 定义应用导出哪些模块 exposes: { &quot;./utils&quot;: &quot;./src/utils&quot;, &quot;./foo&quot;: &quot;./src/foo&quot;, }, }), ], // MF 应用资源提供方必须以 http(s) 形式提供服务 // 所以这里需要使用 devServer 提供 http(s) server 能力 devServer: { port: 8081, hot: true, },}; 提示：Module Federation 依赖于 Webpack5 内置的 ModuleFederationPlugin 实现模块导入导出功能。 作用模块导出方，app-1 的配置逻辑可以总结为： 需要使用 ModuleFederationPlugin 的 exposes 项声明哪些模块需要被导出；使用 filename 项定义入口文件名称； 需要使用 devServer 启动开发服务器能力。 使用 ModuleFederationPlugin 插件后，Webpack 会将 exposes 声明的模块分别编译为独立产物，并将产物清单、MF 运行时等代码打包进 filename 定义的 应用入口文件 (Remote Entry File)中。例如 app-1 经过 Webpack 编译后，将生成如下产物： 123456789MF-basic├─ app-1│ ├─ dist│ │ ├─ main.js│ │ ├─ remoteEntry.js│ │ ├─ src_foo_js.js│ │ └─ src_utils_js.js│ ├─ src│ │ ├─ ... main.js 为整个应用的编译结果，此处可忽略； src_utils_js.js 与 src_foo_js.js 分别为 exposes 声明的模块的编译产物； remoteEntry.js 是 ModuleFederationPlugin 插件生成的应用入口文件，包含模块清单、MF 运行时代码。 接下来继续看看模块导入方 —— 也就是 app-2 的配置方法： 12345678910111213141516171819202122232425262728const path = require(&quot;path&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const { ModuleFederationPlugin } = require(&quot;webpack&quot;).container;module.exports = { mode: &quot;development&quot;, devtool: false, entry: path.resolve(__dirname, &quot;./src/main.js&quot;), output: { path: path.resolve(__dirname, &quot;./dist&quot;), }, plugins: [ // 模块使用方也依然使用 ModuleFederationPlugin 插件搭建 MF 环境 new ModuleFederationPlugin({ // 使用 remotes 属性声明远程模块列表 remotes: { // 地址需要指向导出方生成的应用入口文件 RemoteApp: &quot;app1@http://localhost:8081/dist/remoteEntry.js&quot;, }, }), new HtmlWebpackPlugin(), ], devServer: { port: 8082, hot: true, open: true, },}; 作用远程模块使用方，app-2 需要使用 ModuleFederationPlugin 声明远程模块的 HTTP(S) 地址与模块名称(示例中的 RemoteApp)，之后在 app-2 中就可以使用模块名称异步导入 app-1 暴露出来的模块，例如： 12345// app-2/src/main.js(async () =&gt; { const { sayHello } = await import(&quot;RemoteApp/utils&quot;); sayHello();})(); 到这里，简单示例就算是搭建完毕了，之后运行页面，打开开发者工具的 Network 面板，可以看到： 其中： remoteEntry.js 即 app-1 构建的应用入口文件； src_utils_js.js 则是 import(&quot;RemoteApp/utils&quot;) 语句导入的远程模块。 总结一下，MF 中的模块导出/导入方都依赖于 ModuleFederationPlugin 插件，其中导出方需要使用插件的 exposes 项声明导出哪些模块，使用 filename 指定生成的入口文件；导入方需要使用 remotes 声明远程模块地址，之后在代码中使用异步导入语法 import(&quot;module&quot;) 引入模块。 这种模块远程加载、运行的能力，搭配适当的 DevOps 手段，已经足以满足微前端的独立部署、独立维护、开发隔离的要求，在此基础上 MF 还提供了一套简单的依赖共享功能，用于解决多应用间基础库管理问题。 依赖共享上例应用相互独立，各自管理、打包基础依赖包，但实际项目中应用之间通常存在一部分公共依赖 —— 例如 Vue、React、Lodash 等，如果简单沿用上例这种分开打包的方式势必会出现依赖被重复打包，造成产物冗余的问题，为此 ModuleFederationPlugin 提供了 shared 配置用于声明该应用可被共享的依赖模块。 例如，改造上例模块导出方 app-1 ，添加 shared 配置： 12345678910111213141516module.exports = { // ... plugins: [ new ModuleFederationPlugin({ name: &quot;app1&quot;, filename: `remoteEntry.js`, exposes: { &quot;./utils&quot;: &quot;./src/utils&quot;, &quot;./foo&quot;: &quot;./src/foo&quot;, }, // 可被共享的依赖模块+ shared: ['lodash'] }), ], // ...}; 接下来，还需要修改模块导入方 app-2，添加相同的 shared 配置： 12345678910111213141516module.exports = { // ... plugins: [ // 模块使用方也依然使用 ModuleFederationPlugin 插件搭建 MF 环境 new ModuleFederationPlugin({ // 使用 remotes 属性声明远程模块列表 remotes: { // 地址需要指向导出方生成的应用入口文件 RemoteApp: &quot;app1@http://localhost:8081/dist/remoteEntry.js&quot;, },+ shared: ['lodash'] }), new HtmlWebpackPlugin(), ], // ...}; 之后，运行页面可以看到最终只加载了一次 lodash 产物(下表左图)，而改动前则需要分别从导入/导出方各加载一次 lodash(下表右图)： 添加shared后 改动前 注意，这里要求两个应用使用 版本号完全相同 的依赖才能被复用，假设上例应用 app-1 用了 lodash@4.17.0 ，而 app-2 用的是 lodash@4.17.1，Webpack 还是会同时加载两份 lodash 代码，可以通过 shared.[lib].requiredVersion 配置项显式声明应用需要的依赖库版本来解决这个问题： 123456789101112131415module.exports = { // ... plugins: [ new ModuleFederationPlugin({ // ... // 共享依赖及版本要求声明+ shared: {+ lodash: {+ requiredVersion: &quot;^4.17.0&quot;,+ },+ }, }), ], // ...}; 上例 requiredVersion: &quot;^4.17.0&quot; 表示该应用支持共享版本大于等于 4.17.0 小于等于 4.18.0 的 lodash，其它应用所使用的 lodash 版本号只要在这一范围内即可复用。requiredVersion 支持 Semantic Versioning 2.0 标准，这意味着可以复用 package.json 中声明版本依赖的方法。 requiredVersion 的作用在于限制依赖版本的上下限，实用性极高。除此之外，还可以通过 shared.[lib].shareScope 属性更精细地控制依赖的共享范围，例如： 12345678910111213141516module.exports = { // ... plugins: [ new ModuleFederationPlugin({ // ... // 共享依赖及版本要求声明+ shared: {+ lodash: {+ // 任意字符串+ shareScope: 'foo'+ },+ }, }), ], // ...}; 在这种配置下，其它应用所共享的 lodash 库必须同样声明为 foo 空间才能复用。shareScope 在多团队协作时能够切分出多个资源共享空间，降低依赖冲突的概率。 除 requiredVersion/shareScope 外，shared 还提供了一些不太常用的 配置，简单介绍： singletong：强制约束多个版本之间共用同一个依赖包，如果依赖包不满足版本 requiredVersion 版本要求则报警告： version：声明依赖包版本，缺省默认会从包体的 package.json 的 version 字段解析； packageName：用于从描述文件中确定所需版本的包名称，仅当无法从请求中自动确定包名称时才需要这样做； eager：允许 webpack 直接打包该依赖库 —— 而不是通过异步请求获取库； import：声明如何导入该模块，默认为 shared 属性名，实用性不高，可忽略。 示例：微前端Module Federation 是一种非常新的技术，社区资料还比较少，接下来编写一个完整的微前端应用。微前端架构通常包含一个作为容器的主应用及若干负责渲染具体页面的子应用，分别对标到下面示例的 packages/host 与 packages/order 应用： 123456789101112131415161718192021222324MF-micro-fe├─ packages│ ├─ host│ │ ├─ public│ │ │ └─ index.html│ │ ├─ src│ │ │ ├─ App.js│ │ │ ├─ HomePage.js│ │ │ ├─ Navigation.js│ │ │ ├─ bootstrap.js│ │ │ ├─ index.js│ │ │ └─ routes.js│ │ ├─ package.json│ │ └─ webpack.config.js│ └─ order│ ├─ src│ │ ├─ OrderDetail.js│ │ ├─ OrderList.js│ │ ├─ main.js│ │ └─ routes.js│ ├─ package.json│ └─ webpack.config.js├─ lerna.json└─ package.json 先看看 order 对应的 MF 配置： 12345678910111213module.exports = { // ... plugins: [ new ModuleFederationPlugin({ name: &quot;order&quot;, filename: &quot;remoteEntry.js&quot;, // 导入路由配置 exposes: { &quot;./routes&quot;: &quot;./src/routes&quot;, }, }), ],}; 注意，order 应用实际导出的是路由配置文件 routes.js。而 host 则通过 MF 插件导入并消费 order 应用的组件，对应配置： 1234567891011121314module.exports = { // ... plugins: [ // 模块使用方也依然使用 ModuleFederationPlugin 插件搭建 MF 环境 new ModuleFederationPlugin({ // 使用 remotes 属性声明远程模块列表 remotes: { // 地址需要指向导出方生成的应用入口文件 RemoteOrder: &quot;order@http://localhost:8081/dist/remoteEntry.js&quot;, }, }), ], // ...}; 之后，在 host 应用中引入 order 的路由配置并应用到页面中： 123456789101112131415161718192021222324252627282930import localRoutes from &quot;./routes&quot;;// 引入远程 order 模块import orderRoutes from &quot;RemoteOrder/routes&quot;;const routes = [...localRoutes, ...orderRoutes];const App = () =&gt; ( &lt;React.StrictMode&gt; &lt;HashRouter&gt; &lt;h1&gt;Micro Frontend Example&lt;/h1&gt; &lt;Navigation /&gt; &lt;Routes&gt; {routes.map((route) =&gt; ( &lt;Route key={route.path} path={route.path} element={ &lt;React.Suspense fallback={&lt;&gt;...&lt;/&gt;}&gt; &lt;route.component /&gt; &lt;/React.Suspense&gt; } exact={route.exact} /&gt; ))} &lt;/Routes&gt; &lt;/HashRouter&gt; &lt;/React.StrictMode&gt;);export default App; 实用 MF 示例：Module Federation Examples。","link":"/2023/02/01/webpack/2.%E8%81%94%E9%82%A6%E6%A8%A1%E5%9D%97/"},{"title":"结构","text":"Webpack Hook 底层的 Tapable 框架 结构化理解 Webpack 配置项Webpack 原生提供了上百种配置项，这些配置最终都会作用于 Webpack 打包过程的不同阶段，因此从流程角度更框架性、结构化地了解各项配置的作用。 Webpack 的打包过程非常复杂，但大致上可简化为： 输入 ：从文件系统读入代码文件； 模块递归处理 ：调用 Loader 转译 Module 内容，并将结果转换为 AST，从中分析出模块依赖关系，进一步递归调用模块处理过程，直到所有依赖文件都处理完毕； 后处理 ：所有模块递归处理完毕后开始执行后处理，包括模块合并、注入运行时、产物优化等，最终输出 Chunk 集合； 输出 ：将 Chunk 写出到外部文件系统； 从上述打包流程角度，Webpack 配置项大体上可分为两类： 流程类 ：作用于打包流程某个或若干个环节，直接影响编译打包效果的配置项 工具类 ：打包主流程之外，提供更多工程化工具的配置项 流程类配置项综述 与打包流程强相关的配置项有： 输入输出： entry：用于定义项目入口文件，Webpack 会从这些入口文件开始按图索骥找出所有项目文件； context：项目执行上下文路径； output：配置产物输出路径、名称等； 模块处理： resolve：用于配置模块路径解析规则，可用于帮助 Webpack 更精确、高效地找到指定模块 module：用于配置模块加载规则，例如针对什么类型的资源需要使用哪些 Loader 进行处理 externals：用于声明外部资源，Webpack 会直接忽略这部分资源，跳过这些资源的解析、打包操作 后处理： optimization：用于控制如何优化产物包体积，内置 Dead Code Elimination、Scope Hoisting、代码混淆、代码压缩等功能 target：用于配置编译产物的目标运行环境，支持 web、node、electron 等值，不同值最终产物会有所差异 mode：编译模式短语，支持 development、production 等值，可以理解为一种声明环境的短语 这里的重点是，Webpack 首先需要根据输入配置(entry/context) 找到项目入口文件；之后根据按模块处理(module/resolve/externals 等) 所配置的规则逐一处理模块文件，处理过程包括转译、依赖分析等；模块处理完毕后，最后再根据后处理相关配置项(optimization/target 等)合并模块资源、注入运行时依赖、优化产物结构等。 这些配置项与打包流程强相关，建议学习时多关注它们对主流程的影响，例如 entry 决定了项目入口，而 output 则决定产物最终往哪里输出；resolve 决定了怎么找到模块，而 module 决定了如何解读模块内容，等等。 工具类配置项综述 除了核心的打包功能之外，Webpack 还提供了一系列用于提升研发效率的工具，大体上可划分为： 开发效率类： watch：用于配置持续监听文件变化，持续构建 devtool：用于配置产物 Sourcemap 生成规则 devServer：用于配置与 HMR 强相关的开发服务器功能 性能优化类： cache：Webpack 5 之后，该项用于控制如何缓存编译过程信息与编译结果 performance：用于配置当产物大小超过阈值时，如何通知开发者 日志类： stats：用于精确地控制编译过程的日志内容，在做比较细致的性能调试时非常有用 infrastructureLogging：用于控制日志输出方式，例如可以通过该配置将日志输出到磁盘文件 等等 逻辑上，每一个工具类配置都在主流程之外提供额外的工程化能力，例如 devtool 用于配置产物 Sourcemap 生成规则，与 Sourcemap 强相关；devServer 用于配置与 HMR 相关的开发服务器功能；watch 用于实现持续监听、构建。 工具类配置内聚性较强，通常一个配置项专注于解决一类工程问题，学习时建议先对配置项按其功能做个简单分类，例如上述开发效率类、性能优化类等，之后再展开研究其可选值与效果。 综上，虽然 Webpack 提供了上百项复杂配置，但大体上都可以归类为流程类配置或工具类配置，对于流程类配置应该多关注它们对编译主流程的影响；而工具类则更加内聚，基本上一种配置项解决一种工程化问题。 除了上面提到的属性外，Webpack 还提供了诸如 amd、bail、dependencies 等配置项，但使用频率较低，此处先不展开讨论。 配置逻辑综合解析接下来，构造一个简单示例，了解设计一个 Webpack 配置的过程，示例文件结构： 1234.├── src| └── index.js└── webpack.config.js 其中，src/index.js 为项目入口文件，webpack.config.js 为 Webpack 配置文件。在配置文件中，首先需要声明项目入口： 1234// webpack.config.jsmodule.exports = { entry: &quot;./src/index&quot;,}; 之后，还需要声明产物输出路径： 12345678910// webpack.config.jsconst path = require(&quot;path&quot;);module.exports = { entry: &quot;./src/index&quot;, output: { filename: &quot;[name].js&quot;, path: path.join(__dirname, &quot;./dist&quot;), },}; 至此，已经足够驱动一个最简单项目的编译工作。但是，在前端项目中经常需要处理 JS 之外的其它资源，包括 css、ts、图片等，此时需要为这些资源配置适当的加载器： 12345678910111213141516171819202122232425262728// webpack.config.jsconst path = require(&quot;path&quot;);module.exports = { entry: &quot;./src/index&quot;, output: { filename: &quot;[name].js&quot;, path: path.join(__dirname, &quot;./dist&quot;), }, module: { rules: [ { test: /\\.less$/i, include: { and: [path.join(__dirname, &quot;./src/&quot;)], }, use: [ &quot;style-loader&quot;, &quot;css-loader&quot;, // &quot;./loader&quot;, { loader: &quot;less-loader&quot;, }, ], }, ], },}; 到这里已经是一个简单但足够完备的配置结构了，接下来还可以根据需要使用其它工程化工具，例如使用 devtool 生成 Sourcemap 文件；使用 watch 持续监听文件变化并随之重新构建。 脚手架工具上述概览只是对从流程角度对 Webpack 配置项做了一个简单的分类总结，实际应用中往往需要牵涉更多Loader、Plugin，加之性能、效率方面的考虑，配置复杂度往往会随项目推进而极速膨胀，届时配置管理会变得比较困难。为此，社区提供了许多用于快捷管理配置的工具，包括： Vue CLI：用于帮助用户快速创建、运行 Vue.js 项目脚手架的命令行工具； create-react-app：用于创建 React 项目脚手架的命令行工具； @angular/cli：用于创建 angular 项目的命令行工具； webpack-cli：Webpack 官方提供的命令行工具，提供了一套交互式生成配置文件的指令集，以及项目编译、开发、迁移等功能； Neutrino：用于快速创建、运行现代 JavaScript 应用的工具，同时支持 React、Preact、Vue、Web、Node.js、Library 等场景； react-starter-kit：用于创建 React + Relay + GraphQL 应用的脚手架工具，内置 SSR 支持。 这些工具都内置了许多开箱即用的工程化能力，开发者无需从 0 开始学习 Webpack 与各种工程化组件，就可以直接使用工具一键生成足够应对中小型项目需求的工程化环境。下面逐一展开介绍 Vue CLI、create-react-app，你可根据技术栈需要侧重学习。 使用 Vue CLI 搭建项目脚手架Vue CLI 全称 Vue.js Command-Line Interface，是由 Vue 核心团队开发，用于帮助用户快速创建、运行 Vue.js 项目脚手架的命令行工具。实现上，Vue CLI 底层调用 Webpack 实现针对 .vue 等资源的编译打包功能；调用 webpack-dev-server 实现包含 HMR 功能的开发服务器功能；还能通过插件方式整合 ESLint、Babal、Less 等工具。 总之， Vue CLI 提供了全套开箱即用的 Vue 项目开发、调试环境，开发者可以跳过繁琐复杂的环境配置过程，而专注于业务代码开发上。 与其它工具类似，使用 Vue CLI 时首先需要安装依赖： 1234npm install -g @vue/cli# 或者使用 yarnyarn global add @vue/cli 安装完毕后，可以使用 vue -V 测试是否安装成功： 接下来，使用 vue create 命令创建项目： 1vue create [项目名] 提示：可使用 vue create --help 命令查看 create 的参数列表 执行 create 命令后，CLI 会进一步询问使用何种脚手架方案： 12345Vue CLI v4.5.15? Please pick a preset: (Use arrow keys)❯ Default ([Vue 2] babel, eslint) Default (Vue 3) ([Vue 3] babel, eslint) Manually select features 这里 Vue CLI 内置了为 Vue 2、Vue 3 分别定制的脚手架方案，对应上述第一、二项，不过这两种方案默认只会包含Babel、Eslint 工具，实用性不强。所以结合项目的实际需求，通常会选择第三个选项 “Manually select features”定制各项特性： 提示：具体用法，参考 Vue CLI 官网：cli.vuejs.org/ 经过上述步骤后，Vue CLI 最终都会生成对应的文件并自动安装依赖，之后就可以使用 serve 命令启动项目： 123npm run serve# 或者yarn serve 顺利的话，最终会运行起页面如： Vue CLI 底层依赖于 Webpack 实现编译打包等工程化能力，开发者可通过 configureWebpack 与 chainWebpack 配置项修改 Webpack 配置信息。 以 configureWebpack 为例，使用时需要在 vue.config.js 文件中写入配置： 123456// vue.config.jsmodule.exports = { configureWebpack: { plugins: [new MyAwesomeWebpackPlugin()], },}; configureWebpack 的配置规则与 Webpack 一致，同样支持 plugins/module/resolve 等配置项。实际上，Vue CLI 内部最终会调用 webpack-merge 将 configureWebpack 值与其它上下文配置合并，生成最终的 Webpack 配置信息。 chainWebpack 的用法与 configureWebpack 一致，区别仅在于此处支持 webpack-chain 语法 —— 即以函数方式链式修改 Webpack 配置： 123456789101112// vue.config.jsmodule.exports = { chainWebpack: (config) =&gt; { config.module .rule(&quot;vue&quot;) .use(&quot;vue-loader&quot;) .tap((options) =&gt; { // modify the options... return options; }); },}; 提示：更多信息可参考 Vue CLI 官网 Working with Webpack 一节。 Vue CLI 在 Webpack 基础上包装多一层更易用的功能结构，这确实能极速提升研发效率与体验，但代价则是完全不清楚其内部运作细节，这会导致开发者比较难做一些深度定制或者性能优化，此时可使用 inspect 命令生成完整的 Webpack 配置信息： 1vue inspect &gt; output.js inspect 命令执行完毕后，会生成内容如： 此外，inspect 还提供许多根据不同条件生成配置的参数，例如针对编译环境生成配置： 1vue inspect --mode production &gt; output.prod.js 更多用法，可查阅帮助文档：vue inspect --help。 使用 CRA 搭建项目脚手架CRA 全称 Create React Application，同样是用于帮助用户快速创建、运行 React 项目脚手架的命令行工具，功能、底层实现、用法都与 Vue CLI 相似，都提供了全套开箱即用的 React 项目开发、调试环境。 CRA 用法同样简单： 1npx create-react-app my-app 执行完毕后，生成项目文件： 123456789101112131415161718my-app├── README.md├── node_modules├── package.json├── .gitignore├── public│ ├── favicon.ico│ ├── index.html│ └── manifest.json└── src ├── App.css ├── App.js ├── App.test.js ├── index.css ├── index.js ├── logo.svg └── serviceWorker.js └── setupTests.js 之后，进入 my-app 目录执行 npm start 命令即可运行项目。 提示：更多用法，请参考 CRA 官网： github.com/facebook/cr… 默认规则创建的脚手架包含如下工程能力： JSX、ES6、TypeScript、Flow 语法支持 CSS 自动添加 --webkit-- 前缀 基于 Jest 的自动化测试能力 支持 HMR 的开发服务器 等等，具体可参考官网 必要时，读者也可以通过 npm run eject 命令导出完整的项目配置结构： 1234567891011121314151617181920212223my-app├─ .gitignore├─ README.md├─ config│ ├─ env.js│ ├─ getHttpsConfig.js│ ├─ jest│ │ ├─ babelTransform.js│ │ ├─ cssTransform.js│ │ └─ fileTransform.js│ ├─ modules.js│ ├─ paths.js│ ├─ webpack│ │ └─ persistentCache│ │ └─ createEnvironmentHash.js│ ├─ webpack.config.js│ └─ webpackDevServer.config.js├─ package-lock.json├─ package.json├─ node_modules├─ ...└─ src ├─ ... 导出配置后，直接修改 webpack.config.js 等相关配置文件即可控制各项功能行为。","link":"/2023/02/01/webpack/1.%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E9%80%BB%E8%BE%91/"},{"title":"SplitChunksPlugin","text":"SplitChunksPlugin 分包策略 Webpack 默认会将尽可能多的模块代码打包在一起，优点是能减少最终页面的 HTTP 请求数，但缺点也很明显： 页面初始代码包过大，影响首屏渲染性能； 无法有效应用浏览器缓存，特别对于 NPM 包这类变动较少的代码，业务代码哪怕改了一行都会导致 NPM 包缓存失效。 为此，Webpack 提供了 SplitChunksPlugin 插件，专门用于根据产物包的体积、引用次数等做分包优化，规避上述问题，特别适合生产环境使用。 不过，SplitChunksPlugin 的使用方法比较复杂，得从 Chunk 这个概念开始说起。 深入理解 ChunkChunk 是 Webpack 内部一个非常重要的底层设计，用于组织、管理、优化最终产物，在构建流程进入生成(Seal)阶段后： Webpack 首先根据 entry 配置创建若干 Chunk 对象； 遍历构建(Make)阶段找到的所有 Module 对象，同一 Entry 下的模块分配到 Entry 对应的 Chunk 中； 遇到异步模块则创建新的 Chunk 对象，并将异步模块放入该 Chunk； 分配完毕后，根据 SplitChunksPlugin 的启发式算法进一步对这些 Chunk 执行 裁剪、拆分、合并、代码调优 ，最终调整成运行性能(可能)更优的形态； 最后，将这些 Chunk 一个个输出成最终的产物(Asset)文件，编译工作到此结束。 可以看出，Chunk 在构建流程中起着承上启下的关键作用 —— 一方面作为 Module 容器，根据一系列默认 分包策略 决定哪些模块应该合并在一起打包；另一方面根据 splitChunks 设定的 策略 优化分包，决定最终输出多少产物文件。 Chunk 分包结果的好坏直接影响了最终应用性能 ，Webpack 默认会将以下三种模块做分包处理： Initial Chunk：entry 模块及相应子模块打包成 Initial Chunk； Async Chunk：通过 import('./xx') 等语句导入的异步模块及相应子模块组成的 Async Chunk； Runtime Chunk：运行时代码抽离成 Runtime Chunk，可通过 entry.runtime 配置项实现。 Runtime Chunk 规则比较简单，但 Initial Chunk 与 Async Chunk 这种略显粗暴的规则会带来两个明显问题： 模块重复打包： 假如多个 Chunk 同时依赖同一个 Module，那么这个 Module 会被不受限制地重复打包进这些 Chunk，例如对于下面的模块关系： 示例中 main/index 入口(entry)同时依赖于 c 模块，默认情况下 Webpack 不会对此做任何优化处理，只是单纯地将 c 模块同时打包进 main/index 两个 Chunk： 资源冗余 &amp; 低效缓存： Webpack 会将 Entry 模块、异步模块所有代码都打进同一个单独的包，这在小型项目通常不会有明显的性能问题，但伴随着项目的推进，包体积逐步增长可能会导致应用的响应耗时越来越长。归根结底这种将所有资源打包成一个文件的方式存在两个弊端： 资源冗余 ：客户端必须等待整个应用的代码包都加载完毕才能启动运行，但可能用户当下访问的内容只需要使用其中一部分代码 缓存失效 ：将所有资源达成一个包后，所有改动 —— 即使只是修改了一个字符，客户端都需要重新下载整个代码包，缓存命中率极低 这两个问题都可以通过更科学的分包策略解决，例如： 将被多个 Chunk 依赖的包分离成独立 Chunk，防止资源重复； node_modules 中的资源通常变动较少，可以抽成一个独立的包，业务代码的频繁变动不会导致这部分第三方库资源缓存失效，被无意义地重复加载。 为此，Webpack 专门提供了 SplitChunksPlugin 插件，用于实现更灵活、可配置的分包，提升应用性能。 SplitChunksPlugin 简介SplitChunksPlugin 是 Webpack 4 之后内置实现的最新分包方案，与 Webpack3 时代的 CommonsChunkPlugin 相比，它能够基于一些更灵活、合理的启发式规则将 Module 编排进不同的 Chunk，最终构建出性能更佳，缓存更友好的应用产物。 SplitChunksPlugin 的用法比较抽象，算得上 Webpack 的一个难点，主要能力有： SplitChunksPlugin 支持根据 Module 路径、Module 被引用次数、Chunk 大小、Chunk 请求数等决定是否对 Chunk 做进一步拆解，这些决策都可以通过 optimization.splitChunks 相应配置项调整定制，基于这些能力可以实现： 单独打包某些特定路径的内容，例如 node_modules 打包为 vendors； 单独打包使用频率较高的文件； SplitChunksPlugin 还提供了 optimization.splitChunks.cacheGroup 概念，用于对不同特点的资源做分组处理，并为这些分组设置更有针对性的分包规则； SplitChunksPlugin 还内置了 default 与 defaultVendors 两个 cacheGroup，提供一些开箱即用的分包特性： node_modules 资源会命中 defaultVendors 规则，并被单独打包； 只有包体超过 20kb 的 Chunk 才会被单独打包； 加载 Async Chunk 所需请求数不得超过 30； 加载 Initial Chunk 所需请求数不得超过 30。 提示：这里所说的请求数不能等价对标到 http 资源请求数，下面会细讲。 由于 Webpack4 开始已经内置支持 SplitChunksPlugin ，不需要额外安装依赖，直接修改 optimization.splitChunks 配置项即可实现自定义的分包策略： 12345678module.exports = { //... optimization: { splitChunks: { // ... }, },}; splitChunks 主要有两种类型的配置： minChunks/minSize/maxInitialRequest 等分包条件，满足这些条件的模块都会被执行分包； cacheGroup ：用于为特定资源声明特定分包条件，例如可以为 node_modules 包设定更宽松的分包条件。 下面展开细讲。 设置分包范围首先，SplitChunksPlugin 默认情况下只对 Async Chunk 生效，可以通过 splitChunks.chunks 调整作用范围，该配置项支持如下值： 字符串 'all' ：对 Initial Chunk 与 Async Chunk 都生效，建议优先使用该值； 字符串 'initial' ：只对 Initial Chunk 生效； 字符串 'async' ：只对 Async Chunk 生效； 函数 (chunk) =&gt; boolean ：该函数返回 true 时生效； 例如： 12345678module.exports = { //... optimization: { splitChunks: { chunks: &quot;all&quot;, }, },}; 设置为 all 效果最佳，此时 Initial Chunk、Async Chunk 都会被 SplitChunksPlugin 插件优化。 根据 Module 使用频率分包SplitChunksPlugin 支持按 Module 被 Chunk 引用的次数决定是否分包，借助这种能力可以轻易将那些被频繁使用的模块打包成独立文件，减少代码重复。 用法很简单，只需用 splitChunks.minChunks 配置项设定最小引用次数，例如： 123456789module.exports = { //... optimization: { splitChunks: { // 设定引用次数超过 2 的模块才进行分包 minChunks: 2, }, },}; 注意，这里“被 Chunk 引用次数”并不直接等价于被 import 的次数，而是取决于上游调用者是否被视作 Initial Chunk 或 Async Chunk 处理，例如： 123456789101112// common.jsexport default &quot;common chunk&quot;;// async-module.jsimport common from &quot;./common&quot;;// entry-a.jsimport common from &quot;./common&quot;;import(&quot;./async-module&quot;);// entry-b.jsimport common from &quot;./common&quot;; 上例包含四个模块，形成如下模块关系图： 其中，entry-a、entry-b 分别被视作 Initial Chunk 处理；async-module 被 entry-a 以异步方式引入，因此被视作 Async Chunk 处理。那么对于 common 模块来说，分别被三个不同的 Chunk 引入，此时引用次数为 3，配合下面的配置： 1234567891011121314// webpack.config.jsmodule.exports = { entry: { entry1: &quot;./src/entry-a.js&quot;, entry2: &quot;./src/entry-b.js&quot;, }, // ... optimization: { splitChunks: { minChunks: 2, //... }, },}; common 模块命中 optimization.splitChunks.minChunks = 2 规则，因此该模块可能会被单独分包，最终产物： entry1.js entry1.js async-module.js common.js 强调一下，上面说的是“ 可能 ”，minChunks 并不是唯一条件，此外还需要满足诸如 minSize、chunks 等限制条件才会真正执行分包，接着往下看。 限制分包数量在 minChunks 基础上，为防止最终产物文件数量过多导致 HTTP 网络请求数剧增，反而降低应用性能，Webpack 还提供了 maxInitialRequest/maxAsyncRequest 配置项，用于限制分包数量： maxInitialRequest：用于设置 Initial Chunk 最大并行请求数； maxAsyncRequests：用于设置 Async Chunk 最大并行请求数。 敲重点，”请求数” 这个概念有点复杂： 这里所说的“请求数”，是指加载一个 Chunk 时所需要加载的所有分包数。例如对于一个 ChunkA，如果根据分包规则(如模块引用次数、第三方包)分离出了若干子 Chunk A[¡]，那么加载 A 时，浏览器需要同时加载所有的A[¡]，此时并行请求数等于 ¡ 个分包加 A 主包，即 ¡+1。 提示：通过 emitAssets 等方式直接输出产物文件不在此范畴。 举个例子，对于上例所说的模块关系： 若 minChunks = 2 ，则 common 模块命中 minChunks 规则被独立分包，浏览器请求 entry-a 时，则需要同时请求 common 包，并行请求数为 1 + 1=2。 而对于下述模块关系： 若 minChunks = 2 ，则 common-1 、common-2 同时命中 minChunks 规则被分别打包，浏览器请求 entry-b 时需要同时请求 common-1 、common-2 两个分包，并行数为 2 + 1 = 3，此时若 maxInitialRequest = 2，则分包数超过阈值，SplitChunksPlugin 会 放弃 common-1、common-2 中体积较小的分包 。maxAsyncRequest 逻辑与此类似，不在赘述。 并行请求数关键逻辑总结如下： Initial Chunk 本身算一个请求； Async Chunk 不算并行请求； 通过 runtimeChunk 拆分出的 runtime 不算并行请求； 如果同时有两个 Chunk 满足拆分规则，但是 maxInitialRequests(或 maxAsyncRequest) 的值只能允许再拆分一个模块，那么体积更大的模块会被优先拆解。 限制分包体积除上面介绍的 minChunks —— 模块被引用次数，以及 maxXXXRequest —— 包数量，这两个条件外，Webpack 还提供了一系列与 Chunk 大小有关的分包判定规则，借助这些规则可以实现当包体过小时直接取消分包 —— 防止产物过”碎”；当包体过大时尝试对 Chunk 再做拆解 —— 避免单个 Chunk 过大。 这一规则相关的配置项有： minSize： 超过这个尺寸的 Chunk 才会正式被分包； maxSize： 超过这个尺寸的 Chunk 会尝试进一步拆分出更小的 Chunk； maxAsyncSize： 与 maxSize 功能类似，但只对异步引入的模块生效； maxInitialSize： 与 maxSize 类似，但只对 entry 配置的入口模块生效； enforceSizeThreshold： 超过这个尺寸的 Chunk 会被强制分包，忽略上述其它 Size 限制。 那么，结合前面介绍的两种规则，SplitChunksPlugin 的主体流程如下： SplitChunksPlugin 尝试将命中 minChunks 规则的 Module 统一抽到一个额外的 Chunk 对象； 判断该 Chunk 是否满足 maxInitialRequests 阈值，若满足则进行下一步； 判断该 Chunk 资源的体积是否大于上述配置项 minSize 声明的下限阈值； 如果体积小于 minSize 则取消这次分包，对应的 Module 依然会被合并入原来的 Chunk 如果 Chunk 体积大于 minSize 则判断是否超过 maxSize、maxAsyncSize、maxInitialSize 声明的上限阈值，如果超过则尝试将该 Chunk 继续分割成更小的部分 提示：虽然 maxSize 等阈值规则会产生更多的包体，但缓存粒度会更小，命中率相对也会更高，配合持久缓存与 HTTP2 的多路复用能力，网络性能反而会有正向收益。 以上述模块关系为例： 若此时 Webpack 配置的 minChunks 大于 2，且 maxInitialRequests 也同样大于 2，如果 common 模块的体积大于上述说明的 minxSize 配置项则分包成功，commont 会被分离为单独的 Chunk，否则会被合并入原来的 3 个 Chunk。 提示：注意，这些条件的优先级顺序为：maxInitialRequest/maxAsyncRequests &lt; maxSize &lt; minSize。而命中 enforceSizeThreshold 阈值的 Chunk 会直接跳过这些条件判断，强制进行分包。 缓存组 cacheGroups 简介上述 minChunks、maxInitialRequest、minSize 都属于分包条件，决定是否对什么情况下对那些 Module 做分包处理。此外， SplitChunksPlugin 还提供了 cacheGroups 配置项用于为不同文件组设置不同的规则，例如： 1234567891011121314module.exports = { //... optimization: { splitChunks: { cacheGroups: { vendors: { test: /[\\\\/]node_modules[\\\\/]/, minChunks: 1, minSize: 0, }, }, }, },}; 示例通过 cacheGroups 属性设置 vendors 缓存组，所有命中 vendors.test 规则的模块都会被归类 vendors 分组，优先应用该组下的 minChunks、minSize 等分包配置。 cacheGroups 支持上述 minSice/minChunks/maxInitialRequest 等条件配置，此外还支持一些与分组逻辑强相关的属性，包括： test：接受正则表达式、函数及字符串，所有符合 test 判断的 Module 或 Chunk 都会被分到该组； type：接受正则表达式、函数及字符串，与 test 类似均用于筛选分组命中的模块，区别是它判断的依据是文件类型而不是文件名，例如 type = 'json' 会命中所有 JSON 文件； idHint：字符串型，用于设置 Chunk ID，它还会被追加到最终产物文件名中，例如 idHint = 'vendors' 时，输出产物文件名形如 vendors-xxx-xxx.js ； priority：数字型，用于设置该分组的优先级，若模块命中多个缓存组，则优先被分到 priority 更大的组。 缓存组的作用在于能为不同类型的资源设置更具适用性的分包规则，一个典型场景是将所有 node_modules 下的模块统一打包到 vendors 产物，从而实现第三方库与业务代码的分离。 Webpack 提供了两个开箱即用的 cacheGroups，分别命名为 default 与 defaultVendors，默认配置： 123456789101112131415161718192021module.exports = { //... optimization: { splitChunks: { cacheGroups: { default: { idHint: &quot;&quot;, reuseExistingChunk: true, minChunks: 2, priority: -20, }, defaultVendors: { idHint: &quot;vendors&quot;, reuseExistingChunk: true, test: /[\\\\/]node_modules[\\\\/]/i, priority: -10, }, }, }, },}; 这两个配置组能帮助我们： 将所有 node_modules 中的资源单独打包到 vendors-xxx-xx.js 命名的产物 对引用次数大于等于 2 的模块 —— 也就是被多个 Chunk 引用的模块，单独打包 开发者也可以将默认分组设置为 false，关闭分组配置，例如： 12345678910module.exports = { //... optimization: { splitChunks: { cacheGroups: { default: false, }, }, },}; 配置项与最佳实践总结SplitChunksPlugin 支持的配置项： minChunks：用于设置引用阈值，被引用次数超过该阈值的 Module 才会进行分包处理； maxInitialRequest/maxAsyncRequests：用于限制 Initial Chunk(或 Async Chunk) 最大并行请求数，本质上是在限制最终产生的分包数量； minSize： 超过这个尺寸的 Chunk 才会正式被分包； maxSize： 超过这个尺寸的 Chunk 会尝试继续做分包； maxAsyncSize： 与 maxSize 功能类似，但只对异步引入的模块生效； maxInitialSize： 与 maxSize 类似，但只对 entry 配置的入口模块生效； enforceSizeThreshold： 超过这个尺寸的 Chunk 会被强制分包，忽略上述其它 size 限制； cacheGroups：用于设置缓存组规则，为不同类型的资源设置更有针对性的分包策略。 结合这些特性，业界已经总结了许多惯用的最佳分包策略，包括： 针对 node_modules 资源： 可以将 node_modules 模块打包成单独文件(通过 cacheGroups 实现)，防止业务代码的变更影响 NPM 包缓存，同时建议通过 maxSize 设定阈值，防止 vendor 包体过大； 更激进的，如果生产环境已经部署 HTTP2/3 一类高性能网络协议，甚至可以考虑将每一个 NPM 包都打包成单独文件； 针对业务代码： 设置 common 分组，通过 minChunks 配置项将使用率较高的资源合并为 Common 资源； 首屏用不上的代码，尽量以异步方式引入； 设置 optimization.runtimeChunk 为 true，将运行时代码拆分为独立资源。 总结Chunk 是 Webpack 实现模块打包的关键设计，Webpack 会首先为 Entry 模块、异步模块、Runtime 模块(取决于配置) 创建 Chunk 容器，之后按照 splitChunks 配置进一步优化、裁剪分包内容。 splitChunks 规则比较复杂，大致上可以分类为： 规则类：如 minSize/minChunks 等，匹配这些条件的 Module 都会被单独分包； cacheGroup：可以理解为针对特定资源的次级规则集合。 实践中，分包策略的好坏直接影响应用的运行性能，常用策略一是单独打包 node_modules 代码(习惯称为 vendor)，二是单独打包被频繁使用的模块(习惯称为 common)。","link":"/2023/02/01/webpack/4.splitChunks/"},{"title":"持久化缓存","text":"Webpack5 的 持久化缓存及原理 Webpack5 中的持久化缓存持久化缓存算得上是 Webpack 5最令人振奋的特性之一，它能够将首次构建的过程与结果数据持久化保存到本地文件系统，在下次执行构建时跳过解析、链接、编译等一系列非常消耗性能的操作，直接复用上次的Module/ModuleGraph/Chunk 对象数据，迅速构建出最终产物。 持久化缓存的性能提升效果非常出众！以 Three.js 为例，该项目包含 362 份 JS 文件，合计约 3w 行代码，算得上中大型项目： 配置 babel-loader、eslint-loader 后，测试，未使用 cache 特性时构建耗时大约在 11000ms 到 18000ms 之间；启动 cache 功能后，第二次构建耗时降低到 500ms 到 800ms 之间，两者相差接近 50 倍！ 而这接近 50 倍的性能提升，仅仅需要在 Webpack5 中设置 cache.type = 'filesystem' 即可开启： 1234567module.exports = { //... cache: { type: &quot;filesystem&quot;, }, //...}; 执行效果： 此外，cache 还提供了若干用于配置缓存效果、缓存周期的配置项，包括： cache.type：缓存类型，支持 'memory' | 'filesystem'，需要设置为 filesystem 才能开启持久缓存； cache.cacheDirectory：缓存文件路径，默认为 node_modules/.cache/webpack ； cache.buildDependencies：额外的依赖文件，当这些文件内容发生变化时，缓存会完全失效而执行完整的编译构建，通常可设置为各种配置文件，如： 1234567891011module.exports = { cache: { type: 'filesystem', buildDependencies: { config: [ path.join(__dirname, 'webpack.dll_config.js'), path.join(__dirname, '.babelrc') ], }, },}; cache.managedPaths：受控目录，Webpack 构建时会跳过新旧代码哈希值与时间戳的对比，直接使用缓存副本，默认值为 ['./node_modules']； cache.profile：是否输出缓存处理过程的详细日志，默认为 false； cache.maxAge：缓存失效时间，默认值为 5184000000 。 使用时通常关注上述配置项即可，其它如 idleTimeout、idleTimeoutAfterLargeChanges 等项均与 Webpack 内部实现算法有关，与缓存效果关系不大，此处不展开介绍。 缓存原理那么，为什么开启持久化缓存之后，构建性能会有如此巨大的提升呢？ 一言蔽之，Webpack5 会将首次构建出的 Module、Chunk、ModuleGraph 等对象序列化后保存到硬盘中，后面再运行的时候，就可以跳过许多耗时的编译动作，直接复用缓存数据。 回过头来看看 Webpack 的构建过程，大致上可划分为三个阶段。 初始化，主要是根据配置信息设置内置的各类插件。 Make - 构建阶段，从 entry 模块开始，执行： 读入文件内容； 调用 Loader 转译文件内容； 调用 acorn 生成 AST 结构； 分析 AST，确定模块依赖列表； 遍历模块依赖列表，对每一个依赖模块重新执行上述流程，直到生成完整的模块依赖图 —— ModuleGraph 对象。 Seal - 生成阶段，过程： 遍历模块依赖图，对每一个模块执行： 代码转译，如 import 转换为 require 调用； 分析运行时依赖。 合并模块代码与运行时代码，生成 chunk； 执行产物优化操作，如 Tree-shaking； 将最终结果写出到产物文件。 过程中存在许多 CPU 密集型操作，例如调用 Loader 链加载文件时，遇到babel-loader、eslint-loader、ts-loader 等工具时可能需要重复生成 AST；分析模块依赖时则需要遍历AST，执行大量运算；Seal 阶段也同样存在大量 AST 遍历，以及代码转换、优化操作，等等。假设业务项目中有 1000 个文件，则每次执行 npx webpack 命令时，都需要从 0 开始执行 1000 次构建、生成逻辑。 而 Webpack5 的持久化缓存功能则将构建结果保存到文件系统中，在下次编译时对比每一个文件的内容哈希或时间戳，未发生变化的文件跳过编译操作，直接使用缓存副本，减少重复计算；发生变更的模块则重新执行编译流程。缓存执行时机如下图： 如图，Webpack 在首次构建完毕后将 Module、Chunk、ModuleGraph三类对象的状态序列化并记录到缓存文件中；在下次构建开始时，尝试读入并恢复这些对象的状态，从而跳过执行 Loader 链、解析AST、解析依赖等耗时操作，提升编译性能。 Webpack4：使用 cache-loaderWebpack5 的持久化缓存用法简单，效果出众，但可惜在 Webpack4 及之前版本原生还没有相关实现，只能借助一些第三方组件实现类似效果，包括： 使用 [cache-loader](https://www.npmjs.com/package/cache-loader)； 使用 [hard-source-webpack-plugin](https://github.com/mzgoddard/hard-source-webpack-plugin)； 使用 Loader（如 babel-loader、eslint-loader)）自带的缓存能力。 先从 cache-loader 说起，cache-loader 能够将 Loader 处理结果保存到硬盘，下次运行时若文件内容没有发生变化则直接返回缓存结果，用法： 安装依赖： 1yarn add -D cache 修改配置，注意必须将 cache-loader 放在 loader 数组首位，例如： 12345678910module.exports = { // ... module: { rules: [{ test: /\\.js$/, use: ['cache-loader', 'babel-loader', 'eslint-loader'] }] }, // ...}; cache-loader 只缓存了 Loader 执行结果，缓存范围与精度不如 Webpack5 内置的缓存功能，所以性能效果相对较低，以 ThreeJS 为例，production 模式下构建耗时从 10602ms 降低到 1540ms；development 模式从 11130ms 降低到 4247ms，多次测试性能提升稳定在 60% ~ 80% 之间。虽然比不上 Webpack5 的持久化缓存，但在 Webpack4 中不失为一种简单而有效的性能优化手段。 此外，cache-loader 还提供了一系列控制缓存逻辑的配置属性，特别是 read/write 可以用于改变缓存数据的持久化逻辑，借助这两个属性甚至能够实现多台机器间的缓存共享： 123456789101112131415161718192021222324252627282930313233343536const redis = require(&quot;redis&quot;);const client = redis.createClient();// 读数据async function read(key, callback) { // ... const result = await client.get(key); const data = JSON.parse(result); callback(null, data);}// 写数据async function write(key, data, callback) { // ... await client.set(key, JSON.stringify(data)); callback();}module.exports = { // ... module: { rules: [ { test: /\\.js$/, use: [ { loader: &quot;cache-loader&quot;, // 传入 read、write 函数 options: { read, write }, }, &quot;babel-loader&quot;, ], }, ], },}; 借助这种能力，可以打通本地与线上 CI/CD 环境，实现开发与生产环境构建的构建性能优化。 Webpack4：使用 hard-source-webpack-pluginhard-source-webpack-plugin 也是一种实现缓存功能的第三方组件，与 cache-loader 不同的是，它并不仅仅缓存了 Loader 运行结果，还保存了 Webpack 构建过程中许多中间数据，包括：模块、模块关系、模块 Resolve 结果、Chunks、Assets 等，效果几乎与 Webpack5 自带的 Cache 对齐。用法： 安装依赖： 1yarn add -D hard-source-webpack-plugin 添加配置： 12345678const HardSourceWebpackPlugin = require(&quot;hard-source-webpack-plugin&quot;);module.exports = { // ... plugins: [ new HardSourceWebpackPlugin(), ],}; 首次运行时，hard-source-webpack-plugin 会在缓存文件夹 node_module/.cache 写入一系列日志文件： 下次运行时，hard-source-webpack-plugin 插件会复用缓存中记录的数据，跳过一系列构建步骤，从而提升构建性能。 hard-source-webpack-plugin 插件的底层逻辑与 Webpack5 的持久化缓存很相似，但优化效果稍微差一些，以 ThreeJS 为例，production 模式下构建耗时从 10602ms 降低到 1740ms；development 模式构建从 11130ms 降低到 3280ms，多次测试性能提升稳定在 62% ~ 88% 之间。 使用组件自带的缓存功能除了上面介绍的持久化缓存、cache-loader、hard-source-webpack-plugin 方案外，还可以使用 Webpack 组件自带的缓存能力提升特定领域的编译性能，这一类组件有： babel-loader； eslint-loader：旧版本 ESLint Webpack 组件，官方推荐使用 eslint-webpack-plugin 代替； eslint-webpack-plugin； stylelint-webpack-plugin。 例如使用 babel-loader 时，只需设置 cacheDirectory = true 即可开启缓存功能，例如： 12345678910111213module.exports = { // ... module: { rules: [{ test: /\\.m?js$/, loader: 'babel-loader', options: { cacheDirectory: true, }, }] }, // ...}; 以 Three.js 为例，开启缓存后生产环境构建耗时从 3500ms 降低到 1600ms；开发环境构建从 6400ms 降低到 4500ms，性能提升约 30% ~ 50% 。 默认情况下，缓存内容会被保存到 node_modules/.cache/babel-loader 目录，也可以通过 cacheDirectory = 'dir' 属性设置缓存路径。 此外，ESLint 与 Stylelint 这一类耗时较长的 Lint 工具也贴心地提供了相应的缓存能力，只需设置 cache = true 即可开启，如： 1234567// webpack.config.jsmodule.exports = { plugins: [ new ESLintPlugin({ cache: true }), new StylelintPlugin({ files: '**/*.css', cache: true }), ],}; 依然以 Three.js 为例，开启 ESLint 缓存后生产环境构建耗时从 6400ms 降低到 1400ms；开发环境构建从 7000ms 降低到 2100ms，性能提升达到 70% ~ 80%。 总结Webpack5 持久化缓存用法简单，且优化效果非常出色，甚至特定情况下能够让构建性能达到 Unbundle 方案的量级，妥妥的 Webpack 性能优化利器！ 而在 Webpack4 中，还可以借助下述组件实现缓存优化： cache-loader：针对 Loader 运行结果的通用缓存方案； hard-source-webpack-plugin：针对 Webpack 全生命周期的通用缓存方案； babel-loader：针对 Babel 工具的专用缓存能力； eslint-loader/eslint-webpack-plugin：针对 ESLint 的专用缓存方案； stylelint-webpack-plugin：针对 StyleLint 的专用缓存方案。","link":"/2023/02/01/webpack/3.%E6%8C%81%E4%B9%85%E5%8C%96%E7%BC%93%E5%AD%98/"},{"title":"性能优化","text":"更进一步的优化 优化还有不少普适、细碎的方法，能够有效降低应用体积，提升网络分发性能，包括： 使用动态加载，减少首屏资源加载量； 使用 externals、Tree-Shaking、Scope Hoisting 特性，减少应用体积； 正确使用 [hash] 占位符，优化 HTTP 资源缓存效率； 等等。 动态加载Webpack 默认会将同一个 Entry 下的所有模块全部打包成一个产物文件 —— 包括那些与页面 关键渲染路径 无关的代码，这会导致页面初始化时需要花费多余时间去下载这部分暂时用不上的代码，影响首屏渲染性能，例如： 12345import someBigMethod from &quot;./someBigMethod&quot;;document.getElementById(&quot;someButton&quot;).addEventListener(&quot;click&quot;, () =&gt; { someBigMethod();}); 逻辑上，直到点击页面的 someButton 按钮时才会调用 someBigMethod 方法，因此这部分代码没必要出现在首屏资源列表中，此时可以使用 Webpack 的动态加载功能将该模块更改为异步导入，修改上述代码： 12345document.getElementById(&quot;someButton&quot;).addEventListener(&quot;click&quot;, async () =&gt; { // 使用 `import(&quot;module&quot;)` 动态加载模块 const someBigMethod = await import(&quot;./someBigMethod&quot;); someBigMethod();}); 此时，重新构建将产生额外的产物文件 src_someBigMethod_js.js，这个文件直到执行 import 语句时 —— 也就是上例 someButton 被点击时才被加载到浏览器，也就不会影响到关键渲染路径了。 动态加载是 Webpack 内置能力之一，不需要做任何额外配置就可以通过动态导入语句(import、require.ensure)轻易实现。但请 注意，这一特性有时候反而会带来一些新的性能问题： 一是过度使用会使产物变得过度细碎，产物文件过多，运行时 HTTP 通讯次数也会变多 ，在 HTTP 1.x 环境下这可能反而会降低网络性能，得不偿失； 二是使用时 Webpack 需要在客户端注入一大段用于支持动态加载特性的 Runtime ： 这段代码即使经过压缩也高达 2.5KB 左右，如果动态导入的代码量少于这段 Runtime 代码的体积，那就完全是一笔赔本买卖了。 因此，多数情况下没必要为小模块使用动态加载能力！目前社区比较常见的用法是配合 SPA 的前端路由能力实现页面级别的动态加载，例如在 Vue 中： 12345678910111213141516171819import { createRouter, createWebHashHistory } from &quot;vue-router&quot;;const Home = () =&gt; import(&quot;./Home.vue&quot;);const Foo = () =&gt; import(/* webpackChunkName: &quot;sub-pages&quot; */ &quot;./Foo.vue&quot;);const Bar = () =&gt; import(/* webpackChunkName: &quot;sub-pages&quot; */ &quot;./Bar.vue&quot;);// 基础页面const routes = [ { path: &quot;/bar&quot;, name: &quot;Bar&quot;, component: Bar }, { path: &quot;/foo&quot;, name: &quot;Foo&quot;, component: Foo }, { path: &quot;/&quot;, name: &quot;Home&quot;, component: Home },];const router = createRouter({ history: createWebHashHistory(), routes,});export default router; 示例中，Home/Foo/Bar 三个组件均通过 import() 语句动态导入，这使得仅当页面切换到相应路由时才会加载对应组件代码。另外，Foo 与 Bar 组件的导入语句比较特殊： 1import(/* webpackChunkName: &quot;sub-pages&quot; */ &quot;./Bar.vue&quot;); webpackChunkName 用于指定该异步模块的 Chunk 名称，相同 Chunk 名称的模块最终会打包在一起，这一特性能帮助开发者将一些关联度较高，或比较细碎的模块合并到同一个产物文件，能够用于管理最终产物数量。 HTTP 缓存优化Webpack 只是一个工程化构建工具，没有能力决定应用最终在网络分发时的缓存规则，但可以调整产物文件的名称(通过 Hash)与内容(通过 Code Splitting)，使其更适配 HTTP 持久化缓存策略。 提示：Hash 是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数，不同明文计算出的摘要值不同，所以常常被用作内容唯一标识。 Webpack 提供了一种模板字符串(Template String)能力，用于根据构建情况动态拼接产物文件名称(output.filename)，规则稍微有点复杂，但从性能角度看，比较值得关注的是其中的几个 Hash 占位符，包括： [fullhash]：整个项目的内容 Hash 值，项目中任意模块变化都会产生新的 fullhash； [chunkhash]：产物对应 Chunk 的 Hash，Chunk 中任意模块变化都会产生新的 chunkhash； [contenthash]：产物内容 Hash 值，仅当产物内容发生变化时才会产生新的 contenthash，因此实用性较高。 用法很简单，只需要在 output.filename 值中插入相应占位符即可，如 &quot;[name]-[contenthash].js&quot;。假设对于下述源码结构： 1234src/├── index.css├── index.js└── foo.js 之后，使用下述配置： 123456789module.exports = { // ... entry: { index: &quot;./src/index.js&quot;, foo: &quot;./src/foo.js&quot; }, output: { filename: &quot;[name]-[contenthash].js&quot;, path: path.resolve(__dirname, &quot;dist&quot;), }, plugins: [new MiniCssExtractPlugin({ filename: &quot;[name]-[contenthash].css&quot; })],}; 示例包含 index.js 与 foo.js 两个入口，且分别在 ouput.filename 与 MiniCssExtractPlugin.filename 中使用 [contenthash] 占位符，最终构建结果： 提示：也可以通过占位符传入 Hash 位数，如 [contenthash:7] ，即可限定生成的 Hash 长度。 可以看到每个产物文件名都会带上一段由产物内容计算出的唯一 Hash 值，文件内容不变，Hash 也不会变化，这就很适合用作 HTTP 持久缓存 资源： 123# HTTP Response headerCache-Control: max-age=31536000 此时，产物文件不会被重复下载，一直到文件内容发生变化，引起 Hash 变化生成不同 URL 路径之后，才需要请求新的资源文件，能有效提升网络性能，因此，生产环境下应尽量使用 [contenthash] 生成有版本意义的文件名。 Hash 规则很好用，不过有一个边际 Case 需要注意： 异步模块变化会引起主 Chunk Hash 同步发生变化 ，例如对于下面这种模块关系： 构建后将生成入口 index.js 与异步模块 async-a.js 两个 Chunk 对应的产物： 此时，若异步模块 async-a 或其子模块 sync-c 发生变化，理论上应该只会影响 src_async-a 的 Hash 值，但实际效果却是： 父级 Chunk(index)也受到了影响，生成新的 Hash 值，这是因为在 index 中需要记录异步 Chunk 的真实路径： 异步 Chunk 的路径变化自然也就导致了父级 Chunk 内容变化，此时可以用 optimization.runtimeChunk 将这部分代码抽取为单独的 Runtime Chunk，例如： 1234567891011module.exports = { entry: { index: &quot;./src/index.js&quot; }, mode: &quot;development&quot;, devtool: false, output: { filename: &quot;[name]-[contenthash].js&quot;, path: path.resolve(__dirname, &quot;dist&quot;), }, // 将运行时代码抽取到 `runtime` 文件中 optimization: { runtimeChunk: { name: &quot;runtime&quot; } },}; 之后，async-a.js 模块的变更只会影响 Runtime Chunk 内容，不再影响主 Chunk。 综上，建议至少为生成环境启动 [contenthash] 功能，并搭配 optimization.runtimeChunk 将运行时代码抽离为单独产物文件。 使用外置依赖设想一个场景，假如有 10 个用 React 构建的 SPA 应用，这 10 个应用都需要各自安装、打包、部署、分发同一套相似的React 基础依赖，最终用户在访问这些应用时也需要重复加载相同基础包代码，那有没有办法节省这部分流量呢？有 —— 使用 Webpack 的 externals 特性。 externals 的主要作用是将部分模块排除在 Webpack 打包系统之外，例如： 123456module.exports = { // ... externals: { lodash: &quot;_&quot;, },}; 使用上述配置后，Webpack 会 预设 运行环境中已经内置 Lodash 库 —— 无论是通过 CDN 还是其它方式注入，所以不需要再将这些模块打包到产物中： 提示：externals 不仅适用于优化产物性能，在特定环境下还能用于跳过若干运行时模块，例如 Node 中的 fs/net 等，避免将这部分源码错误打包进 Bundle，详情可参考 webpack-node-externals 工具。 注意，使用 externals 时必须确保这些外置依赖代码已经被正确注入到上下文环境中，这在 Web 应用中通常可以通过 CDN 方式实现，例如： 12345678910111213141516171819202122232425module.exports = { // ... externals: { react: &quot;React&quot;, lodash: &quot;_&quot;, }, plugins: [ new HtmlWebpackPlugin({ templateContent: `&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Webpack App&lt;/title&gt; &lt;script defer crossorigin src=&quot;//unpkg.com/react@18/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;script defer crossorigin src=&quot;//unpkg.com/lodash@4.17.21/lodash.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot; /&gt;&lt;/body&gt;&lt;/html&gt; `, }), ],}; 示例中，externals 声明了 react 与 lodash 两个外置依赖，并在后续的 html-webpack-plugin 模板中注入这两个模块的 CDN 引用，以此构成完整 Web 应用。 虽然结果上看浏览器还是得消耗这部分流量，但结合 CDN系统特性，一是能够就近获取资源，缩短网络通讯链路；二是能够将资源分发任务前置到节点服务器，减轻原服务器 QPS负担；三是用户访问不同站点能共享同一份 CDN 资源副本。所以网络性能效果往往会比重复打包好很多。 使用 Tree-Shaking 删除多余模块导出Tree-Shaking 较早前由 Rich Harris在 Rollup 中率先实现，Webpack 自 2.0 版本开始接入，是一种基于 ES Module 规范的 Dead CodeElimination 技术，它会在运行过程中静态分析模块之间的导入导出，判断哪些模块导出值没有被其它模块使用 —— 相当于模块层面的 DeadCode，并将其删除。 在 Webpack 中，启动 Tree Shaking 功能必须同时满足两个条件： 配置 optimization.usedExports 为 true，标记模块导入导出列表； 启动代码优化功能，可以通过如下方式实现： 配置 mode = production 配置 optimization.minimize = true 提供 optimization.minimizer 数组 例如： 1234567// webpack.config.jsmodule.exports = { mode: &quot;production&quot;, optimization: { usedExports: true, },}; 之后，Webpack 会对所有使用 ESM 方案的模块启动 Tree-Shaking，例如对于下面的代码： 1234567// index.jsimport { bar } from &quot;./bar&quot;;console.log(bar);// bar.jsexport const bar = &quot;bar&quot;;export const foo = &quot;foo&quot;; bar.js 模块导出了 bar 、foo ，但只有 bar 值被 index 模块使用，经过 Tree Shaking 处理后，foo 变量会被视作无用代码删除，最终有效的代码结构： 123456// index.jsimport { bar } from &quot;./bar&quot;;console.log(bar);// bar.jsexport const bar = &quot;bar&quot;; 使用 Scope Hoisting 合并模块默认情况下 Webpack 会将模块打包成一个个单独的函数，例如： 123456// common.jsexport default &quot;common&quot;;// index.jsimport common from &quot;./common&quot;;console.log(common); 经过 Webpack 打包后会生成： 1234567891011121314&quot;./src/common.js&quot;: ((__unused_webpack_module, __webpack_exports__, __webpack_require__) =&gt; { const __WEBPACK_DEFAULT_EXPORT__ = (&quot;common&quot;); __webpack_require__.d(__webpack_exports__, { /* harmony export */ &quot;default&quot;: () =&gt; (__WEBPACK_DEFAULT_EXPORT__) /* harmony export */ }); }),&quot;./src/index.js&quot;: ((__unused_webpack_module, __webpack_exports__, __webpack_require__) =&gt; { var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./common */ &quot;./src/common.js&quot;); console.log(_common__WEBPACK_IMPORTED_MODULE_0__) }) 这种处理方式需要将每一个模块都包裹进一段相似的函数模板代码中，好看是好看，但浪费网络流量啊。为此，Webpack 提供了 Scope Hoisting 功能，用于 将符合条件的多个模块合并到同一个函数空间 中，从而减少产物体积，优化性能。例如上述示例经过 Scope Hoisting 优化后，生成代码： 123456(__unused_webpack_module, __webpack_exports__, __webpack_require__) =&gt; { // CONCATENATED MODULE: ./src/common.js /* harmony default export */ const common = &quot;common&quot;; // CONCATENATED MODULE: ./src/index.js console.log(common);}; Webpack 提供了三种开启 Scope Hoisting 的方法： 使用 mode = 'production' 开启生产模式； 使用 optimization.concatenateModules 配置项； 直接使用 ModuleConcatenationPlugin 插件。 1234567891011121314const ModuleConcatenationPlugin = require(&quot;webpack/lib/optimize/ModuleConcatenationPlugin&quot;);module.exports = { // 方法1： 将 `mode` 设置为 production，即可开启 mode: &quot;production&quot;, // 方法2： 将 `optimization.concatenateModules` 设置为 true optimization: { concatenateModules: true, usedExports: true, providedExports: true, }, // 方法3： 直接使用 `ModuleConcatenationPlugin` 插件 plugins: [new ModuleConcatenationPlugin()],}; 三种方法最终都会调用 ModuleConcatenationPlugin 完成模块分析与合并操作。 与 Tree-Shaking 类似，Scope Hoisting 底层基于 ES Module 方案的 静态特性，推断模块之间的依赖关系，并进一步判断模块与模块能否合并，因此在以下场景下会失效： 非 ESM 模块 遇到 AMD、CMD 一类模块时，由于导入导出内容的动态性，Webpack 无法确保模块合并后不会产生意料之外的副作用，因此会关闭Scope Hoisting 功能。这一问题在导入 NPM 包尤其常见，许多框架都会自行打包后再上传到 NPM，并且默认导出的是兼容性更佳的CommonJS 包，因而无法使用 Scope Hoisting 功能，此时可通过 mainFileds 属性尝试引入框架的 ESM 版本： 123456module.exports = { resolve: { // 优先使用 jsnext:main 中指向的 ES6 模块化语法的文件 mainFields: [&quot;jsnext:main&quot;, &quot;browser&quot;, &quot;main&quot;], },}; 模块被多个 Chunk 引用 如果一个模块被多个 Chunk 同时引用，为避免重复打包，Scope Hoisting 同样会失效，例如： 123456789// common.jsexport default &quot;common&quot;;// async.jsimport common from &quot;./common&quot;;// index.jsimport common from &quot;./common&quot;;import(&quot;./async&quot;); 示例中，入口 index.js 与异步模块 async.js 同时依赖 common.js 文件，common.js 无法被合并入任一 Chunk，而是作为生成为单独的作用域，最终打包结果： 123456789&quot;./src/common.js&quot;: (() =&gt; { var __WEBPACK_DEFAULT_EXPORT__ = (&quot;common&quot;); }), &quot;./src/index.js&quot;: (() =&gt; { var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./common */ &quot;./src/common.js&quot;); __webpack_require__.e( /*! import() */ &quot;src_async_js&quot;).then(__webpack_require__.bind(__webpack_require__, /*! ./async */ &quot;./src/async.js&quot;)); }), 监控产物体积结合 Code Splitting、压缩、缓存优化、Tree-Shaking 等技术，不难看出所谓的应用性能优化几乎都与网络有关，这是因为现代计算机网络环境非常复杂、不稳定，虽然有堪比本地磁盘吞吐速度的 5G 网络，但也还存在大量低速 2G、3G 网络用户，整体而言通过网络实现异地数据交换依然是一种相对低效的 IO 手段，有可能成为 Web 应用执行链条中最大的性能瓶颈。 因此，站在生产者角度有必要尽可能优化代码在网络上分发的效率，用尽可能少的网络流量交付应用功能。所幸 Webpack 专门为此提供了一套 性能监控方案，当构建生成的产物体积超过阈值时抛出异常警告，以此帮助我们时刻关注资源体积，避免因项目迭代增长带来过大的网络传输，用法： 123456789101112131415module.exports = { // ... performance: { // 设置所有产物体积阈值 maxAssetSize: 172 * 1024, // 设置 entry 产物体积阈值 maxEntrypointSize: 244 * 1024, // 报错方式，支持 `error` | `warning` | false hints: &quot;error&quot;, // 过滤需要监控的文件类型 assetFilter: function (assetFilename) { return assetFilename.endsWith(&quot;.js&quot;); }, },}; 若此时产物体积超过 172KB，则报错： 提示：这里的报错不会阻断构建功能， 依然能正常打包出应用产物。 具体设置多大的阈值，这取决于项目具体场景，不过，一个比较好的 经验法则 是确保 关键路径 资源体积始终小于 170KB，超过这个体积就应该使用上面介绍的若干方法做好裁剪优化。","link":"/2023/02/01/webpack/5.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"title":"流程","text":"init、make、seal 核心流程 Webpack 的功能集非常庞大：模块打包、代码分割、按需加载、Hot ModuleReplacement、文件监听、Tree-shaking、Sourcemap、Module Federation、DevServer、DLL、多进程打包、Persistent Cache 等等，但抛开这些花里胡哨的能力，最最核心的功能依然是：At its core, webpack is a static module bundler for modern JavaScript applications ，也就是所谓的 静态模块打包能力 。 Webpack 能够将各种类型的资源 —— 包括图片、音视频、CSS、JavaScript代码等，通通转译、组合、拼接、生成标准的、能够在不同版本浏览器兼容执行的 JavaScript 代码文件，这一特性能够轻易抹平开发 Web应用时处理不同资源的逻辑差异，使得开发者以一致的心智模型开发、消费这些不同的资源文件。 打包功能的底层实现逻辑很复杂，抛去大多数分支逻辑后，大致包含如下步骤： 把上述过程划分为三个阶段： 初始化阶段 ：修整配置参数，创建 Compiler、Compilation 等基础对象，并初始化插件及若干内置工厂、工具类，并最终根据 entry 配置，找到所有入口模块； 构建阶段 ：从 entry 文件开始，调用 loader 将模块转译为 JavaScript 代码，调用 Acorn 将代码转换为 AST 结构，遍历 AST 从中找出该模块依赖的模块；之后 递归 遍历所有依赖模块，找出依赖的依赖，直至遍历所有项目资源后，构建出完整的 模块依赖关系图 ； 生成阶段 ：根据 entry 配置，将模块组装为一个个 Chunk 对象，之后调用一系列 Template 工厂类翻译 Chunk 代码并封装为 Asset，最后写出到文件系统。 提示：单次构建过程自上而下按顺序执行，如果启动了 watch ，则构建完成后不会退出 Webpack 进程，而是持续监听文件内容，发生变化时回到「 构建 」阶段重新执行构建。 三个阶段环环相扣，「 初始化 」的重点是根据用户配置设置好构建环境；「 构建阶段 」则重在解读文件输入与文件依赖关系；最后在「 生成阶段 」按规则组织、包装模块，并翻译为适合能够直接运行的产物包。三者结合，实现 Webpack 最核心的打包能力，其它功能特性也几乎都是在此基础上，通过 Hook 介入、修改不同阶段的对象状态、流程逻辑等方式实现。 初始化阶段初始化阶段主要完成三个功能：修整 &amp; 校验配置对象、运行插件、调用 compiler.compile 方法开始执行构建操作，代码比较简单，如下图： 首先，校验用户参数，并合并默认配置对象： 启动时，首先将 process.args 参数与 webpack.config.js 文件合并成用户配置； 调用 validateSchema 校验配置对象（validateSchema 底层依赖于 schema-utils 库）； 调用 getNormalizedWebpackOptions + applyWebpackOptionsBaseDefaults 合并出最终配置。 之后，创建 Compiler 对象并开始启动插件： 调用 createCompiler 函数创建 compiler 对象。 遍历 配置中的 plugins 集合，执行插件的 apply 方法。 调用 new WebpackOptionsApply().process 方法，根据配置内容动态注入相应插件，包括： 调用 EntryOptionPlugin 插件，该插件根据 entry 值注入 DynamicEntryPlugin 或 EntryPlugin 插件； 根据 devtool 值注入 Sourcemap 插件，包括：SourceMapDevToolPlugin、EvalSourceMapDevToolPlugin 、EvalDevToolModulePlugin； 注入 RuntimePlugin ，用于根据代码内容动态注入 webpack 运行时。 最后，调用 compiler.compile 方法开始执行构建 ，这一步非常重要，源码： 1234567891011121314151617181920212223242526// webpack/lib/compiler.jscompile(callback) { const params = this.newCompilationParams(); this.hooks.beforeCompile.callAsync(params, err =&gt; { // ... const compilation = this.newCompilation(params); this.hooks.make.callAsync(compilation, err =&gt; { // ... this.hooks.finishMake.callAsync(compilation, err =&gt; { // ... process.nextTick(() =&gt; { compilation.finish(err =&gt; { // ... compilation.seal(err =&gt; { // ... this.hooks.afterCompile.callAsync(compilation, err =&gt; { if (err) return callback(err); return callback(null, compilation); }); }); }); }); }); }); }); } 虽然 compile 方法并没有任何实质的功能逻辑，但它搭建起了后续构建流程框架： 调用 newCompilation 方法创建 compilation 对象； 触发 make 钩子，紧接着 EntryPlugin 在这个钩子中调用 compilation 对象的 addEntry 方法创建入口模块，主流程开始进入「 构建阶段 」； make 执行完毕后，触发 finishMake 钩子； 执行 compilation.seal 函数，进入「 生成阶段 」，开始封装 Chunk，生成产物； seal 函数结束后，触发 afterCompile 钩子，开始执行收尾逻辑。 提示：compile 函数是后续所有功能逻辑的起点，非常重要，请务必前往阅读 源码。 调用 compile 函数触发 make 钩子后，初始化阶段就算是结束了，流程逻辑开始进入「 构建阶段 」。 构建阶段「 构建阶段 」从 entry 模块开始递归解析模块内容、找出模块依赖，按图索骥逐步构建出项目整体 module 集合以及 module 之间的 依赖关系图，这个阶段的主要作用就是读入并理解所有原始代码。 实现上，在上述「 初始化阶段 」的最后，compiler.compile 函数会触发 compiler.hook.make 钩子，EntryPlugin 监听该钩子并开始调用 compilation.addEntry 添加入口： 12345678910111213class EntryPlugin { apply(compiler) { const { entry, options, context } = this; // 创建入口 Dependency 对象 const dep = EntryPlugin.createDependency(entry, options); compiler.hooks.make.tapAsync(&quot;EntryPlugin&quot;, (compilation, callback) =&gt; { compilation.addEntry(context, dep, options, (err) =&gt; { callback(err); }); }); }} addEntry 之后的执行逻辑： 调用 handleModuleCreation，根据文件类型构建 module 子类 —— 一般是 NormalModule； 调用 loader-runner 转译 module 内容，将各类资源类型转译为 Webpack 能够理解的标准 JavaScript 文本； 调用 acorn 将 JavaScript 代码解析为 AST 结构； 在 JavaScriptParser 类中遍历 AST，触发各种钩子，其中最关键的： 遇到 import 语句时，触发 exportImportSpecifier 钩子； HarmonyExportDependencyParserPlugin 监听该钩子，将依赖资源添加为 Dependency 对象； 调用 module 对象的 addDependency， 将 Dependency 对象转换为 Module 对象并添加到依赖数组中。 AST 遍历完毕后，调用 module.handleParseResult 处理模块依赖数组； 对于 module 新增的依赖，调用 handleModuleCreate，控制流回到第一步； 所有依赖都解析完毕后，构建阶段结束。 过程中模块源码经历了 module =&gt; ast =&gt; dependences =&gt; module 的流转，先将源码解析为 AST 结构，再在 AST 中遍历 import 等模块导入语句，收集模块依赖数组 —— dependences，最后遍历 dependences 数组将 Dependency 转换为 Module 对象，之后递归处理这些新的 Module，直到所有项目文件处理完毕。 提示：这个过程会调用 acorn 将模块内容 —— 包括 JS、CSS，甚至多媒体文件，解析为 AST 结构，所以需要使用 loaders 将不同类型的资源转译为标准 JavaScript 代码。 这个递归处理流程是「 构建阶段 」的精髓，假设对于下图这种简单模块依赖关系： 其中 index.js 为 entry 文件，依赖于 a/b 文件；a 依赖于 c/d 文件。初始化编译环境之后，EntryPlugin 根据 entry 配置找到 index.js 文件，并调用 compilation.addEntry 函数将之添加为 Module 对象，触发构建流程，构建完毕后内部会生成这样的数据结构： 之后，调用 Acorn 将 index.js 代码解析为 AST，并遍历 AST 找到 index.js 文件的依赖： 得到两个新的依赖对象：dependence[a.js] 与 dependence[b.js] ，这是下一步操作的关键线索，紧接着调用 module[index.js] 的 handleParseResult 函数处理这两个依赖对象，得到 a、b 两个新的 Module 对象： 接着，又触发 module[a/b] 的 handleModuleCreation 方法，从 a.js 模块中又解析到 c.js/d.js 两个新依赖，于是再继续调用 module[a] 的 handleParseResult，递归上述流程： 最终得到 a/b/c/d 四个 Module 与对应的 Dependency 对象： 到这里解析完所有模块，没有新的依赖后就可以继续推进，进入「生成阶段」。 生成阶段「构建阶段」负责读入与分析源代码文件，将之一一转化为 Module、Dependency对象，解决的是资源“输入”问题；而「生成阶段」则负责根据一系列内置规则，将上一步构建出的所有 Module 对象拆分编排进若干 Chunk对象中，之后以 Chunk 粒度将源码转译为适合在目标环境运行的产物形态，并写出为产物文件，解决的是资源“输出”问题。 「生成阶段」发生在 make 阶段执行完毕，compiler.compile 调用 compilation.seal 函数时： 123456789// webpack/lib/compiler.jscompile(callback) { // ... const compilation = this.newCompilation(params); this.hooks.make.callAsync(compilation, err =&gt; { // ... compilation.seal(err =&gt; {/* */}); }); } 也就是说，compilation.seal 函数是「生成阶段」的入口函数，seal 原意密封、上锁，在 Webpack 语境下接近于“将模块装进 Chunk”，核心流程： 创建本次构建的 ChunkGraph 对象。 遍历 入口集合 compilation.entries： 调用 addChunk 方法为每一个入口 创建 对应的 Chunk 对象（EntryPoint Chunk）； 遍历 该入口对应的 Dependency 集合，找到 相应 Module 对象并 关联 到该 Chunk。 到这里可以得到若干 Chunk，之后调用 buildChunkGraph 方法将这些 Chunk 处理成 Graph 结构，方便后续处理。 之后，触发 optimizeModules/optimizeChunks 等钩子，由插件（如 SplitChunksPlugin）进一步修剪、优化 Chunk 结构。 一直到最后一个 Optimize 钩子 optimizeChunkModules 执行完毕后，开始调用 compilation.codeGeneration 方法生成 Chunk 代码，在 codeGeneration 方法内部： 遍历每一个 Chunk 的 Module 对象，调用 _codeGenerationModule； _codeGenerationModule 又会继续往下调用 module.codeGeneration 生成单个 Module 的代码，这里注意不同 Module 子类有不同 codeGeneration 实现，对应不同产物代码效果。 所有 Module 都执行完 codeGeneration，生成模块资产代码后，开始调用 createChunkAssets 函数，为每一个 Chunk 生成资产文件。 调用 compilation.emitAssets 函数“ 提交 ”资产文件，注意这里还只是记录资产文件信息，还未写出磁盘文件。 上述所有操作正常完成后，触发 callback 回调，控制流回到 compiler 函数。 最后，调用 compiler 对象的 emitAssets 方法，输出资产文件。 seal 很复杂，重点在于将 Module 按入口组织成多个 Chunk 对象，之后暴露 optimizeXXX 钩子，交由插件根据不同需求对 Chunk 做进一步修剪、整形、优化，最后按 Chunk 为单位做好代码合并与转换，输出为资产文件。 提示：上述 optimizeXXX 钩子常被用于优化最终产物代码，例如 SplitChunksPlugin 就可以在这里分析 Chunk、Module 关系，将使用率较高的 Module 封装进新的 Chunk，实现 Common Chunk 效果。 简单理解，Entry 与 Chunk 一一对应，而 Chunk 与最终输出的资源一一对应，假如有这样的配置： 12345678// webpack.config.jsmodule.exports = { entry: { a: &quot;./src/a.js&quot;, b: &quot;./src/b.js&quot;, }, // ...}; 实例配置中有两个入口，对应的文件结构： a 依赖于 c/e；b 依赖于 c/d；a/b 同时依赖于 c。最终生成的 Chunk 结构为： 也就是根据依赖关系，chunk[a] 包含了 a/c/e 三个模块，chunk[b] 包含了 b/c/d 三个模块。 seal 过程中会不断调用 compilation.emitAssets 提交资产记录，而直到 seal 结束后则调用 compiler.emitAssets 函数，函数内部调用 compiler.outputFileSystem.writeFile 方法将 assets 集合写入文件系统，Webpack 完成从源码到资产文件的转换，构建工作至此结束。 资源形态流转OK，上面把逻辑层面的构造主流程梳理完了，最后再结合资源形态流转的角度重新考察整个过程，加深理解： compiler.make 阶段： entry 文件以 dependence 对象形式加入 compilation 的依赖列表，dependence 对象记录了 entry 的类型、路径等信息； 根据 dependence 调用对应的工厂函数创建 module 对象，之后读入 module 对应的文件内容，调用 loader-runner 对内容做转化，转化结果若有其它依赖则继续读入依赖资源，重复此过程直到所有依赖均被转化为 module。 compilation.seal 阶段： 遍历 module 集合，根据 entry 配置及引入资源的方式，将 module 分配到不同的 Chunk； Chunk 之间最终形成 ChunkGraph 结构； 遍历 ChunkGraph，调用 compilation.emitAsset 方法标记 chunk 的输出规则，即转化为 assets 集合。 compiler.emitAssets 阶段： 将 assets 写入文件系统。 这个过程用到很多 Webpack 基础对象，包括： Entry：编译入口； Compiler：编译管理器，Webpack 启动后会创建 compiler 对象，该对象一直存活直到构建结束进程退出； Compilation：单次构建过程的管理器，比如 watch = true 时，运行过程中只有一个 compiler，但每次文件变更触发重新编译时，都会创建一个新的 compilation 对象； Dependence：依赖对象，记录模块间依赖关系； Module：Webpack 内部所有资源都会以 Module 对象形式存在，所有关于资源的操作、转译、合并都是以 Module 为单位进行的； Chunk：编译完成准备输出时，将 Module 按特定的规则组织成一个一个的 Chunk。 总结综上，Webpack 底层源码非常复杂，但撇除所有分支逻辑后，构建主流程可以简单划分为三个阶段： 初始化阶段 ：负责设置构建环境，初始化若干工厂类、注入内置插件等； 构建阶段 ：读入并分析 Entry 模块，找到模块依赖，之后递归处理这些依赖、依赖的依赖，直到所有模块都处理完毕，这个过程解决资源“输入”问题； 生成阶段 ：根据 Entry 配置将模块封装进不同 Chunk 对象，经过一系列优化后，再将模块代码翻译成产物形态，按 Chunk 合并成最终产物文件，这个过程解决资源“输出”问题。 这个过程串起资源「输入」到「输出」的关键步骤。","link":"/2023/02/01/webpack/6.init%E3%80%81make%E3%80%81seal,%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/"},{"title":"","text":"promise 回调的执行时机","link":"/2023/08/11/js/%E5%9F%BA%E7%A1%80/%E5%BC%82%E6%AD%A5/"},{"title":"原型","text":"原型、构造函数的基本原理 构造函数-constructor 命名以大写字母开头，只能由 new 操作符来执行，原型的 constructor 属性指向的是和原型关联的构造函数 是一种特殊的方法，主要用来创建对象时初始化对象，即为对象成员变量赋初始值，总与 new 运算符一起使用在创建对象的语句中，任何函数只要使用 new 就成了构造函数，不是用则为普通函数 个人理解就是模仿java/c++的构造 new 的过程发生的事件： 1234567function test() {}var testConstruct = new test(); //此时将函数作为class，实例化一个对象//下面是new的具体实现var obj = {}; //创建一个空对象obj.__proto__ = test.prototype; //空对象的__proto__指向构造函数对象的prototypetest.call(obj, `有参数就放这`); //将构造函数的作用域赋给新对象return obj; //返回修改后的对象，达到实例化效果 原型-prototype 函数访问原型：构造函数名.prototype js 原型也称 js 原型对象，是一种对象属性，每个构造函数在创建出来的时候系统会自动给这个构造函数创建并关联一个空对象（这个空对象就叫原型） 原型的意义，oop的静态方法/变量集合，只是js中可修改 根据上面的构造函数在每次实例化对象时，都会开辟一个新空间，如果只是传入的变量不同是合理的，如果不同实例都具有变量无关的共同方法就会造成空间浪费（这些方法都会挂在每个实例对象中，并且不会指向同一地址） 那将这种变量无关的公共方法提出来就完成优化了 最直观的自然是闭包方式，将公共方法定义在外部，内部引用即可（闭包问题多，只是引出一种方法） 因为闭包的缺点，所以设计了原型这个东西，突然在想原型是否能代替闭包，如果行的话，react hook 的闭包问题能不能用原型的设计方式进行代替 每个由构造函数创建出的对象，都会默认和构造函数的原型关联当使用一个方法进行属性或者 方法访问的时候，会现在当前对象查找，没有就去相关联的原型对象查 instance.attrs，如果只是获取实例化的某个属性，则会向上找，如果赋值（instance.attrs=1），则只会在 instance 对象中找，找不到则创建 __proto__ 实例化对象访问原型：instance.__proto__ = functionName.prototype 上面提到实例化对象创建时，该实例化对象会和构造函数的原型关联，那自然就需要一个变量来保存该指向，自然引出__proto__这不就是上面 new 实现的第二句吗 反正将原型的各种指向想简单点就行了，原型也能替换，替换后实例对象指向哪个，则获取哪个的内容，因为没修改实例对象的指向，也没有删除旧的原型对象","link":"/2023/01/05/js/%E5%9F%BA%E7%A1%80/%E5%8E%9F%E5%9E%8B/"},{"title":"AST","text":"理解 AST，并使用 api 分析代码生成 AST AST 是什么？ 抽象语法树 (Abstract Syntax Tree)，简称 AST，它是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。 代码中常见的字面量、标识符、表达式、语句、模块语法、class 语法等语句都有各自对应的 AST 节点类型。 常见节点类型 literal(字面量) : 本身语义代表了一个值。 1234let name = &quot;iceman&quot;; // iceman ---&gt; StringLiteral 字符串字面量let age = 30; // 30 ---&gt; NumberLiteral 数字字面量const isMan = true; // true ---&gt; BooleanLiteral 布林字面量const reg = /\\d/; // /\\d/ ---&gt; RegExpLiteral 正则字面量 Identifier(标识符) : 变量名、属性名、参数名等等一系列声明和引用的名字。 123456789import { request } form 'framework'; // request ---&gt; Identifier let name = 'iceman'; // name ---&gt; Identifier const age = 30; // age ---&gt; Identifier function talk(name) { // talk, name ---&gt; Identifier console.log(name); // console, log, name ---&gt; Identifier } const obj = { // obj ---&gt; Identifier name: 'guang' // name ---&gt; Identifier } Statement(语句) : 代码执行的最小单位。 1234567return &quot;iceman&quot;; // ReturnStatementif (age &gt; 35) {} // IfStatementthrow new Error(&quot;error&quot;); // ThrowStatementtry {} catch (e) {} // TryStatementfor (let i = 0; i &lt; 5; i++) {} // ForStatement Declaration(声明) : 声明语句是一种特殊的 Statement。 1234567891011121314const listlen = 1; // VariableDeclarationlet listName = &quot;user&quot;; // VariableDeclarationfunction getInfo(info) { // FunctionDeclaration if (info.isRun) { return info.name; } return &quot;&quot;;}class Car { // ClassDeclaration constructor() {} method() {}} Expression(表达式) : expression 的特点是执行完成后会有返回值，这也是它和语句的区别 12345678910111213[1, 2, 3]; // ArrayExpression 数组表达式age = 1; // AssignmentExpression 赋值表达式1 + 2; // BinaryExpression二元表达式var obj = { // ObjectExpression对象表达式 foo: &quot;foo&quot;, bar: function () {},};let getName = function () {}; // FunctionExpression函数表达式const getAge = (age) =&gt; { // ArrowFunctionExpression箭头函数表达式 return age;}; Import : 导入模块，属于一种特殊的声明语句，有三种类型 ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier。 1234import { environment } from &quot;framework&quot;; // named importimport { request as req } from &quot;framework&quot;; // namespaced importimport api from &quot;framework&quot;; // default importimport * as APP from &quot;framework&quot;; // namespaced imort Export : 导出模块，也属于一种特殊的声明，有三种类型 ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration。 123export * from &quot;./iceman&quot;;export default &quot;iceman&quot;;export const ice = &quot;iceman&quot;; 每个 AST 节点都有自己的属性，但是它们也有一些公共的属性： pos，AST 节点在代码字符串中索引的起始位置，配合 end 确定节点在代码字符串中的位置（用于唯一性判定）。 end，AST 节点在代码字符串中索引的结束位置，配合 pos 确定节点在代码字符串中的位置（用于唯一性判定）。 kind，用来标记当前 AST 节点的类型，上面列举的节点类型都可以通过 ts.SyntaxKind 的定义来查看。 这么多节点类型，肯定不可能都记住，我们可以通过一些可视化工具来帮助我们查看 AST 节点信息。 可视化工具AST explorer 是一个 AST 可视化工具，通过它可以查看各种编程语言代码解析后的 AST 结构，帮助开发者更直观地观察代码与 AST 节点树具体节点的对应关系，它支持切换各种 parser，可以修改 parse options。 查看 astexplorer 解析细节 TypeScript AST Viewer 与 AST explorer 不同，它只用于 TypeScript AST 对象的可视化，除了展示 AST 节点信息外，还会关联节点 TS 编译过程中的 type、symbol 等信息。 ts-ast-viewer 解析细节举个例子： 1234// 示例代码function add(num: number) { return 5 + num;} 上面是一段 TS 代码，内容是声明了一个名为 add 的函数，代码对应的 AST explorer URL，使用 TypeScript 编译器转化为 AST 对象以后，右侧的 AST 树信息如下图（关注标记点即可）： AST 对象简化为 JSON 对象的话： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546{ &quot;kind&quot;: 305, &quot;statements&quot;: [ { &quot;kind&quot;: 256, &quot;name&quot;: { &quot;kind&quot;: 79, // Identifier &quot;escapedText&quot;: &quot;add&quot; }, &quot;parameters&quot;: [ { &quot;kind&quot;: 164, // Identifier &quot;name&quot;: { &quot;kind&quot;: 79, // Identifier &quot;escapedText&quot;: &quot;num&quot; }, &quot;type&quot;: { &quot;kind&quot;: 147 // NumberKeyword } } ], &quot;body&quot;: { &quot;kind&quot;: 235, &quot;statements&quot;: [ { &quot;kind&quot;: 247, &quot;expression&quot;: { &quot;kind&quot;: 221, &quot;left&quot;: { &quot;kind&quot;: 8, &quot;text&quot;: &quot;5&quot; }, &quot;operatorToken&quot;: { &quot;kind&quot;: 39 }, &quot;right&quot;: { &quot;kind&quot;: 79, // Identifier &quot;escapedText&quot;: &quot;num&quot; } } } ] } } ]} SourceFile 可以理解成 AST Root 节点，如果把它命名为 ast，可以获取如下信息： 123456ast.statements[0].kind; // 节点类型为函数声明ast.statements[0].name.escapedText; // 函数名称ast.statements[0].parameters[0].name; // 函数的首个参数名ast.statements[0].parameters[0].type.kind; // 函数的首个参数类型为Numberast.statements[0].body.statements[0].kind; // 函数体内第一行是return语句ast.statements[0].body.statements[0].expression.kind; // 函数返回值为二元运算符表达式结果 既然代码的含义可以通过 AST 来表述，而 AST 又可以理解为一个 JS 对象，自然就能对代码进行分析了 AST 有什么用？代码编译 Babel，将 ES6 JavaScript 转化为 ES5 JavaScript。 TypeScript，将 TypeScript 转化为 JavaScript。 Sass，将 Sass 转化为 CSS。 代码加工 Prettier，代码美化，风格格式化。 ESLint, 修复语法错误。 uglifyJS，代码压缩，混淆。 @vue/compiler-dom，可以将 Vue 文件代码拆分成 template、script、style 三种代码类型片段。 代码分析 ESLint，代码语法检查。 Webpack，代码模块打包分析。 基于 AST 的代码处理工具工作流程一般可以概括为 4 个阶段： Parsing（解析） ：这个过程由编译器实现，会经过词法分析和语法分析两个过程，生成 AST 。 Traversing（遍历）： 深度优先遍历 AST ，访问树上各个节点的信息（Node）。 Transforming（修改）： 在遍历的过程中可对节点信息进行修改/转化，生成新的 AST 。 Printing（输出）： 将转化后新的 AST 输出成新的代码块。 代码编译，代码加工一般会经历 1，2，3，4 四个阶段，而代码分析因为不会去改变源代码，所以一般只经历 1，2 两个阶段。比如 ESLint 仅检查语法错误时，只需要对 AST 各级节点进行遍历，定位违反语法规则的节点信息并标记，返回修复建议即可，不需要对代码作出修改和再输出。 开发分析工具也属于代码分析类，核心工作也是对 AST 各级节点进行遍历分析并返回分析结果，首先获取AST AST 如何生成?生成 AST 包含两个步骤： 词法分析：将整个代码字符串分割成最小语法单元数组。 语法分析：在分词基础上建立分析语法单元之间的关系。 词法分析 将输入的源代码字符串，生成一系列词法单元 (Tokens)，这些词法单元包括数字，标点符号，运算符等，这些词法单元之间都是独立的。 词法分析的过程就是关键词（也包含各种名字）拆分，并不关心单词之间的具体联系。 语法分析 将词法分析出来的 Token 按照不同的语法结构如声明语句、赋值表达式等转化成有语法含义的抽象语法树结构。 举个例子： 1const iceman = &quot;good boy&quot;; const iceman = 'good boy'; 上面这一段源代码字符串，先把它按照单词的构成规则分成一个个不能再细分的单词（Token），也就是 const、iceman、=、 'good boy'，这个过程是词法分析。之后把 Tokens 按照声明语句、赋值表达式的语法结构如进行递归组装，生成 AST 对象，这个过程是语法分析。 编译器 ParserAST explorer可视化工具的实现原理是通过调用对应开发语言 Parser 的 CompilerAPI，将代码解析为 AST 对象再进而遍历展示。也就是说，这些 Parser 的 API 可以完成代码的词法分析与语法分析，并返回对应的 AST 对象，下面是常用的 JS Parser 与 TSParser。 JS Parser： esprima、 acorn、 espree、@babel/parser。 TS Parser：typescript TS Parser 可以同时解析 JS(X) 和 TS(X) 代码文件，所以代码分析工具选择的 Parser 是 typescript，生成 AST 的几个 API： createSourceFile：根据 TypeScript 代码字符串生成 AST 对象，AST explorer 的底层原理就是通过这个方法将代码片段字符串转化为 AST 做可视化处理。 1234567891011121314151617181920212223242526// TS编译器const tsCompiler = require(&quot;typescript&quot;);// 待分析代码片段字符串const tsCode = `import { app } from 'framework'; const dataLen = 3;let name = 'iceman';if(app){ console.log(name);}function getInfos (info: string) { const result = app.get(info); return result;}`;// 第一个参数为命名，可以随意填，// 第二个参数是需要生成AST的源代码字符串// 第三个参数表示TS编译器版本// 第四个参数表示是否添加parent节点信息const ast = tsCompiler.createSourceFile( &quot;xxx&quot;, tsCode, tsCompiler.ScriptTarget.Latest, true);console.log(ast); createProgram，getSourceFile：先创建 program 编译上下文，然后获取指定代码文件的 AST 对象，program 可以抽象成一次完整的 TS 编译过程，通过它可以获取编译过程的上下文信息。 123456789101112// TS编译器const tsCompiler = require(&quot;typescript&quot;);// 创建Program// fileNames参数表示文件路径列表，是一个数组// options参数是编译选项，可以理解成tsconfigconst program = tsCompiler.createProgram(fileNames, options);// 从 Program 中获取某个文件的 SourceFile// fileName表示某一个文件路径const ast = program.getSourceFile(fileName);console.log(ast); 上面两种方式都可以生成 AST，区别在于前者仅仅是将一段 TS 代码字符串解析成 AST，因为不存在 program，所以无法获取编译上下文信息，只能通过遍历 AST 实现一些简单分析场景。而后者通过 program 获取更多编译上下文信息，可以实现更细致的分析场景，代码分析工具采用后者来获取 AST。 扩展 JavaScript 抽象语法树 AST 深入理解 TS","link":"/2023/02/01/project/%E4%BE%9D%E8%B5%96%E6%B2%BB%E7%90%86/1.ast/"},{"title":"分析ts代码","text":"了解特征分析原理 分析一小段 TS 代码中的 API（从而扩展到整个项目，采用分而治之的思想） 下面是一段 TS 代码片段，它的 API 调用信息无非就是从依赖 framework 中引入了名为 app 的 API，并且在第 6 行和第 11 行中进行了调用。 12345678910111213import { app } from &quot;framework&quot;;const dataLen = 3;let name = &quot;iceman&quot;;if (app) { console.log(name);}function getInfos(info: string) { const result = app.get(info); return result;} 将待分析的代码解析为 AST第一步，将需要分析的代码解析为 AST，因为 AST 是代码分析的前提： 12345678910111213141516171819202122const tsCompiler = require(&quot;typescript&quot;); // TS编译器// 待分析代码片段字符串const tsCode = `import { app } from 'framework'; const dataLen = 3;let name = 'iceman';if(app){ console.log(name);}function getInfos (info: string) { const result = app.get(info); return result;}`;// 获取ASTconst ast = tsCompiler.createSourceFile( &quot;xxx&quot;, tsCode, tsCompiler.ScriptTarget.Latest, true);console.log(ast); 通过 createSourceFile 这个 Compiler API 来获取 AST，然后找特征（和分析加密字符，解析文件格式一样，都会有唯一的对应特征） 观察代码的 AST 结构及特征要分析代码，那肯定要先弄清楚代码对应的 AST 节点组成信息，把要分析的代码片段放到 AST explorer 中，结合可视化工具来观察节点及相关特征： 分析的代码片段总共包含 5 条语句，分别为 ImportDeclaration、VariableStatement、VariableStatement、IfStatement、FunctionDeclaration，然后这 5 个 AST 节点再继续派生出更详细的子节点，共同组成了映射这段 TS 代码的 AST 语法树结构，把所有的 AST 节点类型以树状图的形式展示，会看得更直观一些： 对所有的 Identifier 类型节点进行标注，Identifier 节点通常为变量名、属性名、参数名等等一系列声明和引用的名字，既然 Identifier 代表的是各种名字，而要寻找的是 app 这个 API 在代码中的调用情况，那直接通过遍历所有 Identifier 类型节点并判断它的名字是否为 app，再判断是否调用 遍历分析 AST 各级节点TypeScript 一个非常重要的 CompilerAPI : forEachChild，它可以实现对 AST 各层级节点的深度遍历，该方法第一个参数是指 AST 根节点或正在被遍历的子节点，第二个参数是一个回调函数，完善后的代码： 123456789101112131415161718192021222324252627282930const tsCompiler = require(&quot;typescript&quot;); // TS编译器// 待分析代码片段字符串const tsCode = `import { app } from 'framework'; const dataLen = 3;let name = 'iceman';if(app){ console.log(name);}function getInfos (info: string) { const result = app.get(info); return result;}`;// 获取ASTconst ast = tsCompiler.createSourceFile( &quot;xxx&quot;, tsCode, tsCompiler.ScriptTarget.Latest, true);console.log(ast);function walk(node) { // AST遍历函数 tsCompiler.forEachChild(node, walk); // 遍历AST节点 console.log(node); // 输出节点信息}walk(ast); // 执行遍历 TypeScript 提供了一系列判断节点类型的 CompilerAPI，可用来判断Identifier等节点： 12345678const tsCompiler = require(&quot;typescript&quot;);// 判断节点类型的函数，返回值类型为 booleantsCompiler.isFunctionDeclaration(node); // 判定是否为函数声明节点tsCompiler.isArrowFunction(node); // 判定是否为箭头函数tsCompiler.isTypeReferenceNode(node); // 判定是否为Type类型节点tsCompiler.isVariableDeclaration(node); // 判定是否为变量声明节点tsCompiler.isIdentifier(node); // 判定是否为Identifier节点 在 walk 函数中使用 tsCompiler.isIdentifier(node)来判定当前节点是否为 Identifier 类型节点，进而判断它的名字是否为 app，如果两个条件都满足的话，把这个节点的信息记录到一个Map 结构中，Map 结构非常适合需要统计信息的分析场景，以 API 名称作为 key，将 API 调用相关的信息以对象的形式写入 value，等遍历完 AST 的全部节点后，就可以得到 app 这个 API 在代码中真实的调用情况了。 可以通过 ast 对象上的 getLineAndCharacterOfPosition 方法获取当前遍历节点的代码行信息： 12// 获取当前node节点所在代码行ast.getLineAndCharacterOfPosition(node.getStart()).line + 1; 基于此，再完善一下分析脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const tsCompiler = require(&quot;typescript&quot;); // TS编译器// 待分析代码片段字符串const tsCode = `import { app } from 'framework'; const dataLen = 3;let name = 'iceman';if(app){ console.log(name);}function getInfos (info: string) { const result = app.get(info); return result;}`;// 获取ASTconst ast = tsCompiler.createSourceFile( &quot;xxx&quot;, tsCode, tsCompiler.ScriptTarget.Latest, true);console.log(ast);const apiMap = {}; // 记录API分析结果function walk(node) { // AST遍历函数 tsCompiler.forEachChild(node, walk); // 遍历AST节点 const line = ast.getLineAndCharacterOfPosition(node.getStart()).line + 1; // 获取节点所在行 if (tsCompiler.isIdentifier(node) &amp;&amp; node.escapedText === &quot;app&quot;) { // 判断isIdentifier节点名称是否为app if (Object.keys(apiMap).includes(node.escapedText)) { apiMap[node.escapedText].callNum++; apiMap[node.escapedText].callLines.push(line); } else { apiMap[node.escapedText] = {}; apiMap[node.escapedText].callNum = 1; apiMap[node.escapedText].callLines = []; apiMap[node.escapedText].callLines.push(line); } }}walk(ast);console.log(apiMap); // 输出分析结果// {// app: {// callNum: 3,// callLines: [1，6，11]// }// } 然后执行分析脚本，会发现输出的结果并不符合预期，因为遍历了所有的节点，这些节点里面自然也包含 import 节点中的 app，应该排除这个干扰，所以加一个判断条件后，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const tsCompiler = require(&quot;typescript&quot;); // TS编译器// 待分析代码片段字符串const tsCode = `import { app } from 'framework'; const dataLen = 3;let name = 'iceman';if(app){ console.log(name);}function getInfos (info: string) { const result = app.get(info); return result;}`;// 获取ASTconst ast = tsCompiler.createSourceFile( &quot;xxx&quot;, tsCode, tsCompiler.ScriptTarget.Latest, true);console.log(ast);const apiMap = {}; // 记录API分析结果function walk(node) { // AST遍历函数 tsCompiler.forEachChild(node, walk); // 遍历AST节点 const line = ast.getLineAndCharacterOfPosition(node.getStart()).line + 1; // 获取节点所在行 if (tsCompiler.isIdentifier(node) &amp;&amp; node.escapedText === &quot;app&quot;) { // 判断isIdentifier节点名称是否为app if (line != 1) { // 排除import导入自身 if (Object.keys(apiMap).includes(node.escapedText)) { apiMap[node.escapedText].callNum++; apiMap[node.escapedText].callLines.push(line); } else { apiMap[node.escapedText] = {}; apiMap[node.escapedText].callNum = 1; apiMap[node.escapedText].callLines = []; apiMap[node.escapedText].callLines.push(line); } } }}walk(ast); // 遍历ASTconsole.log(apiMap); // 输出分析结果// {// app: {// callNum: 2,// callLines: [6, 11]// }// } 执行 walk，得到了符合预期的分析结果，即这段 TS 代码中有引入 app 这个 API，且有 2 次调用，分别在代码第 6 行，第 11 行。 分析脚本存在的问题代码并没有先对 import 节点进行分析，如果代码中都不存在 import 导入语句，那么通过遍历所有 Identifier 类型节点名称是否为 app 这样的判定思路，它只能找到与 app 相同名称的 AST 节点而已，这并不能代表这些 app 都是从 framework 导入的 1234567891011121314import { app } from &quot;framework&quot;; // import app 定义const dataLen = 3;let name = &quot;iceman&quot;;function doWell() { const app = 4; // 局部常量 app 定义 return app; // 局部常量 app 调用}function getInfos(info: string) { const result = app.get(info); // import app 调用 return result;} 在要分析的代码片段中增加一个新的函数 doWell，并在它里面定义一个局部常量也叫 app，这个时候分析脚本是无法区分 doWell 方法中的 app 与 getInfos 方法中的 app 的，即无法判定同名 Identifier 节点是否属于同一语义上下文。 其它的问题： 无法判断 app 这个 API 的具体用途（类型、属性、方法、类…）； 无法区分 app.get 链式调用与 app 直接调用这两种场景； 排除 import 节点的判断方式不准确。 其实就是判断这些特殊的情况的特征，并记录下来即可 依赖调用分析到底要做些什么？ 简单来说，首先针对每一个需要分析的 TS(JS) 文件： 遍历其所有 import 节点（上图绿框区域），分析并记录从目标依赖引入的 API 信息，并排除非目标依赖项的干扰。 判定引入的 API 在具体代码中（上图红框区域）是否有调用，过程中还需要排除局部同名变量等一系列干扰。 根据分析指标如用途识别（类型、属性、方法）等对该 API 调用进行指标判定分析，命中则记录到指定 Map 中。 然后按照上面的步骤依次遍历所有项目中指定的 TS(JS) 文件，就可以得到全部应用对于特定依赖（如：framework）的 API 调用分析数据了，最后根据使用场景（告警、评分、代码报告、代码建议等）对分析数据进行标记，二次整理，即可输出最终的分析结果。","link":"/2023/02/01/project/%E4%BE%9D%E8%B5%96%E6%B2%BB%E7%90%86/2.%E5%88%86%E6%9E%90ts%E4%BB%A3%E7%A0%81/"},{"title":"扫描ts文件","text":"扫描 ts 文件 根据配置扫描所有需要分析的 TS 文件是代码分析的前提 扫描 TS 文件扫描代码文件就是遍历指定目录，找出目录及其子目录下所有特定类型的文件（如：TS 文件、Vue 文件），并返回这些文件的目录路径信息。 glob这是实现文件目录扫描常用的 node 工具库 glob，它支持配置通配符规则的方式来扫描文件目录，像在 shell 里执行命令一样，获取匹配对应规则的文件。 举个例子： 1const tsFiles = glob.sync(path.join(process.cwd(), `src/**/*.ts`)); 上述代码演示了如何寻找 src 目录及子目录下所有的 TS 文件，要注意的一点是，这里的 src 目录指的是执行上述脚本代码时所在的工作目录，node 环境中获取路径的两种方式： __dirname 表示当前被执行脚本文件所在的目录的绝对路径 ——脚本文件所在目录 process.cwd() 返回运行当前脚本的工作目录的路径 —— 脚本文件执行目录 分析工具是以 npm 包的形式对外提供，在被安装后通常是在项目的 node_modules 目录（脚本文件所在目录）下，但是需要分析的代码文件往往在项目的其他目录中，所以执行分析工具脚本的工作目录与安装目录并不一致。 举个例子：对于 d:\\dir\\index.js 12console.log(`cwd: ${process.cwd()}`);console.log(`dirname: ${__dirname}`); process.cwd() __dirname node index.js d:\\dir d:\\dir node dir\\index.js d: d:\\dir File 模块把扫描 TS 代码文件的方法封装成函数放在 file 模块中： 12345678// 扫描TS文件exports.scanFileTs = function (scanPath) { const tsFiles = glob.sync(path.join(process.cwd(), `${scanPath}/**/*.ts`)); const tsxFiles = glob.sync(path.join(process.cwd(), `${scanPath}/**/*.tsx`)); // console.log(tsFiles); // console.log(tsxFiles); return tsFiles.concat(tsxFiles);}; scanFileTs 函数以 scanPath 作为入参，用于扫描 scanPath 目录及其子目录下所有的 TS、TSX 文件，并返回它们的文件路径信息。 扫描文件是一种基础通用能力，它的实现方式也多种多样，封装在独立的 file 模块中，codeAnalysis 在需要扫描文件的时候只需要引入 file 模块并调用其相关方法就可以了，不需要了解其具体实现细节，单独修改它也不会影响到 codeAnalysis 的分析逻辑。 解析 TS 文件在扫描找到所有需要分析的 TS 代码文件后，接下来将代码文件中的 TS 代码解析为 AST 对象 TypeScript 编译原理TS 编译器相关源码位于 src/compiler ，主要包含 scanner 扫描器（scanner.ts），parser 解析器（parser.ts），binder 绑定器（binder.ts），checker 检查器（checker.ts），emitter 发射器（emitter.ts）这 5 部分。 编译流程可以简化为下图： 相关概念： Program : 在编译开始时创建为一个名为 Program 编译上下文对象，通过 编译选项 和 输入文件（ =1 个或多个，进行单文件分析时通常只传 1 个= ）这两部分配置，加载所有输入文件以及输入文件中 imports 导入的文件（ps : 加载很多文件是因为在编译过程中会进行类型检查，而类型信息可能需要结合多个文件得出）。 Tsconfig : TypeScript 编译配置信息，其实就是 TS 项目中的 tsconfig.json 配置文件。 Tokens : Scanner 扫描源代码进行词法分析后生成的 Token 流。 AST : Parser 将 Token 流进行语法分析，生成 AST 对象。 Symbol : Binder 会创建一个用来存储每个 AST 节点和对应符号 Symbol 的映射表，当初次定义或者从 import 导入一个变量、函数或类时，会为其创建一个符号（唯一标识符），当在其他地方使用相同名称时，就查表找出这个名称所代表的符号, 通过 symbol 可以判定 AST 节点的语义上下文。 Checker : Checker 用来检查代码中变量的类型信息，提供了一些 API 获取节点类型及关联信息。 Emitter : 处理 Node 节点，将 AST 转化为 js、d.ts、map 等编译产物。 上面的流程也可以概括为以下四个阶段： 1234567891011// 1.解析代码生成AST对象SourceCode（源码）~~ 扫描器 ~~&gt; Token 流 ~~ 解析器 ~~&gt; AST// 2.为AST节点绑定符号AST ~~ 绑定器 ~~&gt; Symbols// 3.语义检查，类型检查AST + Symbols ~~ 检查器 ~~&gt; 类型验证，语义上下文判断// 4.代码生成阶段（代码分析不需要关注这个阶段）AST + 检查器 ~~ 发射器 ~~&gt; JavaScript 代码 SymbolSymbol 正如其名就是一个标志。同一个文件中，两个不同的函数里面定义了名称相同的变量，它们属于不同的 Symbol，如果有两个文件， a.ts 导出的变量 app 在 b.ts 里使用，那这个 app 在两个文件中对应的是同一个 Symbol。 在实现分析脚本的时候，没法判断下面示例代码中 getInfos 函数中的 app 与 doWell 函数中的 app 有什么区别，有了 Symbol 就可以区分它们了。示例代码： 123456789101112131415// 待分析代码import { app } from &quot;framework&quot;; // import app 定义 (symbol1)const dataLen = 3;let name = &quot;iceman&quot;;function doWell() { const app = 4; // 局部常量 app 定义 (symbol2) return app; // 局部常量 app 调用(symbol2)}function getInfos(info: string) { const result = app.get(info); // import app 调用(symbol1) return result;} 在 Symbol Table 中，每个 AST 节点都有唯一对应的符号 Symbol，相同语义上下文的 AST 节点拥有相同 Symbol，并且该 Symbol 指向第一次声明该变量的 AST 节点。 把上面的示例代码放入 TypeScript AST Viewer，可以在右下角看到 AST 节点对应的 Symbol 信息，Symbol 对象的 declarations 属性中第一个元素指向的就是当前节点的声明节点。 （1）第 2 行中 app 节点的 Symbol 信息： （2）第 13 行中 app 节点的 Symbol 信息： （3）第 8 行中 app 节点的 Symbol 信息： （4）第 9 行中 app 节点的 Symbol 信息： 可以发现第 2 行中的 app 与 第 13 行中的 app 拥有相同 Symbol1，且 Symbol1 指向在第 2 行中由 import 语句引入的 app 声明节点。而第 8 行，第 9 行中的 app 拥有相同 Symbol2，且 Symbol2 指向第 8 行中的 app 声明节点，所以由此证明 doWell 中的 app 并非从 framework 中引入，属于局部常量，应该排除。 (上图绿框内的 pos，end 属性值可作为声明节点的唯一性表述信息) 可以通过 Compiler API 获取 AST 节点对应的 Symbol。createProgram、getSourceFiles 这 2 个 API： ts.createProgram，创建 Program 编译上下文，是 TS 代码分析的基础； program.getSourceFiles，通过 Program 获取代码文件对应的 SourceFile 对象，也就是 AST。 想获取 Symbol，需要通过 program 获取 Checker 对象，再由 Checker 获取 Symbol ，需要 2 个新 API： program.getTypeChecker，用于通过 program 获取 Checker 控制器，该控制器用来类型检查、语义检查等； typeChecker.getSymbolAtLocation，用于查询 Symbol table，获取指定 AST 节点相关联的 Symbol 信息。 获取 Symbol 的代码示例： 12345678910111213// TS编译器const tsCompiler = require(&quot;typescript&quot;);// 创建Program// fileNames参数表示文件路径列表，是一个数组，可以只传1个文件// options参数是编译选项，可以理解成tsconfigconst program = tsCompiler.createProgram(fileNames, options);// 从 Program 中获取 SourceFile 即 AST对象// fileName表示某一个文件路径const ast = program.getSourceFile(fileName);// 获取 TypeChecker控制器const checker = program.getTypeChecker();// 获取 AST node节点对应的symbolconst symbol = checker.getSymbolAtLocation(node); 可见想要进行代码分析，仅仅获取 AST 是不够的，还需要一些编译上下文信息，控制器对象等。 Parse 模块封装一个名为 parseTs 用于解析指定 TS 文件并返回 ast、checker 控制器（ 用于获取 Symbol ）的函数，并把它放在 parse 模块中。 123456789// 解析ts文件代码，获取ast，checkerexports.parseTs = function (fileName) { // 将ts代码转化为AST const program = tsCompiler.createProgram([fileName], {}); const ast = program.getSourceFile(fileName); const checker = program.getTypeChecker(); // console.log(ast); return { ast, checker };}; codeAnalysis 相关逻辑codeAnalysis 使用file 模块和 parse 模块。 扫描文件_scanFiles 函数是 codeAnalysis 基础类扫描代码文件的核心方法，它根据配置文件中的 scanSource 配置项扫描指定目录下的代码文件，返回满足条件的代码文件路径信息，下面是简化后的演示片段： 123456789101112131415161718192021222324252627const { scanFileTs } = require(path.join(__dirname, './file')); // 文件操作// 扫描文件_scanFiles(scanSource, type) { let entrys = []; scanSource.forEach((item)=&gt;{ ...... const entryObj = { name: item.name, httpRepo: item.httpRepo } let parse = []; const scanPath = item.path; scanPath.forEach((sitem)=&gt;{ ...... let tempEntry = []; tempEntry = scanFileTs(sitem); parse = parse.concat(tempEntry); ...... }) entryObj.parse = parse; entrys.push(entryObj); ...... }) // console.log(entrys); return entrys;} 项目代码脱敏后放 git 解析文件_scanCode 是 codeAnalysis 驱动扫描文件，分析代码相关逻辑的核心方法，它还会关联 step5 中的几个重要方法 _findImportItems，_dealAST： 123456789101112131415161718192021const { parseTs } = require(path.join(__dirname, './parse')); // 解析模块// 扫描文件，分析代码_scanCode(scanSource, type) { let entrys = this._scanFiles(scanSource, type); // console.log(entrys); entrys.forEach((item)=&gt;{ const parseFiles = item.parse; if(parseFiles.length&gt;0){ parseFiles.forEach((element, eIndex) =&gt; { ...... const { ast, checker } = parseTs(element); // 解析ts文件代码,将其转化为AST this._findImportItems(); // 遍历AST分析import节点 if(Object.keys(importItems).length &gt;0){ this._dealAST(importItems, ast, ...) // 遍历 AST 分析 API 调用 } ...... }); } })}","link":"/2023/02/01/project/%E4%BE%9D%E8%B5%96%E6%B2%BB%E7%90%86/3.%E6%89%AB%E6%8F%8F%E8%A7%A3%E6%9E%90ts%E6%96%87%E4%BB%B6/"},{"title":"import特征","text":"找出不同 import 方法的特征，并实现 Import 导入方式下面几种写法是我们业务代码中经常使用的 import 导入方式，这些语句对应的 AST 节点都是 ImportDeclaration 类型节点，但是因为导入方式不同，子节点的结构存在很大差异，不同导入方式的 API 表述存在差异，分析程序需要区分它们，不然无法获取准确的 API 导入信息。 1234import { environment } from &quot;framework&quot;; // named importimport api from &quot;framework&quot;; // default importimport { request as req } from &quot;framework&quot;; // namespaced importimport * as APP from &quot;framework&quot;; // namespaced imort 结合 TypeScript AST Viewer 观察一下上面几种 Import 语句的 AST 结构： （ps：可以点击左侧的语句节点，右侧会显示对应节点的详细信息，方便对照理解） 把 4 种类型的 AST 及子节点类型转化为树状图，可以更直观的观察它们的特征： 局部导入1import { environment } from &quot;framework&quot;; // named import TypeScript AST Viewer 中的 SourceFile 表示 AST Root 节点，把它命名为 ast，获取节点的相关信息： 12345678// AST节点信息ast.statements[0].moduleSpecifier.kind; // StringLiteralast.statements[0].moduleSpecifier.text; // frameworkast.statements[0].importClause.namedBindings.kind; // NamedImportsast.statements[0].importClause.namedBindings.elements[0].kind; // ImportSpecifierast.statements[0].importClause.namedBindings.elements[0].propertyName; // undefinedast.statements[0].importClause.namedBindings.elements[0].name.kind; // Identifierast.statements[0].importClause.namedBindings.elements[0].name.escapedText; // environment 通过 AST 各级节点的属性值，可以判定上面的 Import 语句表示从 framework 以局部导入方式导入了名为 environment 的 API。 AST 对象节点的属性名与其类型名在命名上并非一致，在节点树状图中展示的是各个节点的类型名而非属性名。例如，ast.statements[0].importClause.namedBindings 的节点类型是 NamedImports。可以通过 TypeScript AST Viewer 或者 AST explorer 工具来对应 属性名 与 类型名 。 接下来，以同样的方式将其它几种导入方式的 AST 节点进行拆解。 默认全局导入1import api from &quot;framework&quot;; // default import 12345// AST节点信息ast.statements[1].moduleSpecifier.kind; // StringLiteralast.statements[1].moduleSpecifier.text; // frameworkast.statements[1].importClause.name.kind; // Identifierast.statements[1].importClause.name.escapedText; // api 局部别名导入1import { request as req } from &quot;framework&quot;; // namespaced import 12345678910// AST节点信息ast.statements[2].moduleSpecifier.kind; // StringLiteralast.statements[2].moduleSpecifier.text; // frameworkast.statements[2].importClause.namedBindings.kind; // NamedImportsast.statements[2].importClause.namedBindings.elements[0].kind; // ImportSpecifierast.statements[2].importClause.namedBindings.elements[0].propertyName.kind; // Identifierast.statements[2].importClause.namedBindings.elements[0].propertyName .escapedText; // requestast.statements[2].importClause.namedBindings.elements[0].name.kind; // Identifierast.statements[2].importClause.namedBindings.elements[0].name.escapedText; // req 全局别名导入1import * as APP from &quot;framework&quot;; // namespaced imort 123456// AST节点信息ast.statements[3].moduleSpecifier.kind; // StringLiteralast.statements[3].moduleSpecifier.text; // frameworkast.statements[3].importClause.namedBindings.kind; // NamespaceImportast.statements[3].importClause.namedBindings.name.kind; // Identifierast.statements[3].importClause.namedBindings.name.escapedText; // APP 通过观察这 4 种导入方式的 AST 树状图以及子节点信息，总结出 4 条判定条件： Import 语句 AST 对象都有 importClause 属性以及 moduleSpecifier 属性，后者表示目标依赖名； importClause 对象如果只有 name 属性，没有 namedBindings 属性，那么可以判定为默认全局导入； importClause 对象存在 namedBindings 属性，且类型为 NamespaceImport，则可以判定为全局别名导入； importClause 对象存在 namedBindings 属性，并且类型为 NamedImports，并且 elements属性为数组，并且长度大于 0。遍历 elements 数组的每一个元素，如果该元素的类型为ImportSpecifier，则可以判定其属于局部导入。至于它是否存在 as 别名，则需要进一步判断其是否存在 propertyName属性与 name 属性。如果都存在，则说明其属于局部别名导入。如果只有 name 属性，就为常规局部导入。elements 对象是一个数组，对于多个局部导入的场景上述规则也适用。 既然每种导入类型都存在唯一的判定条件，就可以通过程序来区分它们。 Import 节点分析逻辑第一步：遍历 AST ，通过 isImportDeclaration API 判断各级节点类型，找到所有的 ImportDeclaration 类型节点。 第二步：通过判断节点的 moduleSpecifier.text 属性是否为分析目标（如：framework） 来过滤掉非目标依赖的 import 节点。 判定导入类型第三步：根据总结出的 4 条判定条件完善判定逻辑，相关代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142// 分析import导入 _findImportItems(ast, filePath, baseLine = 0) { // 遍历AST寻找import节点 function walk(node) { // console.log(node); tsCompiler.forEachChild(node, walk); const line = ast.getLineAndCharacterOfPosition(node.getStart()).line + baseLine + 1; // 分析导入情况 if(tsCompiler.isImportDeclaration(node)){ // 命中target if(node.moduleSpecifier &amp;&amp; node.moduleSpecifier.text &amp;&amp; node.moduleSpecifier.text == 'framework'){ // 存在导入项 if(node.importClause){ // default直接导入场景 if(node.importClause.name){ // 记录API相关信息 } if(node.importClause.namedBindings){ // 局部导入场景，包含as if (tsCompiler.isNamedImports(node.importClause.namedBindings)) { if(node.importClause.namedBindings.elements &amp;&amp; node.importClause.namedBindings.elements.length&gt;0) { // console.log(node.importClause.namedBindings.elements); const tempArr = node.importClause.namedBindings.elements; tempArr.forEach(element =&gt; { if (tsCompiler.isImportSpecifier(element)) { // 记录API相关信息 } }); } } // * 全量导入as场景 if (tsCompiler.isNamespaceImport(node.importClause.namedBindings) &amp;&amp; node.importClause.namedBindings.name){ // 记录API相关信息 } } } } } } walk(ast); } 区分各种导入方式是为了准确的记录 API 导入信息，只记录 api 名字是不准确的 ast 里面的 symbol 不知道会不会和 ida 分析时导入的符号表是同一个意思，如果是的话就合理了 记录 API 信息Import 节点是一种特殊的声明语句，导入的 API 相当于变量声明： 123456789101112131415// 示例代码import { app } from &quot;framework&quot;; // import app 定义 (symbol1)const dataLen = 3;let name = &quot;iceman&quot;;function doWell() { const app = 4; // 局部常量 app 定义 (symbol2) return app; // 局部常量 app 调用(symbol2)}function getInfos(info: string) { const result = app.get(info); // import app 调用(symbol1) return result;} 想要证明 13 行中的 app 是否真的来自 import 声明节点导入时，也需要用到 Symbol，所以分析 import 节点不光是为了记录代码文件从目标依赖中导入了 app 这个 API，还需要记录 app 对应的 Symbol 信息，便于后续步骤依据 Symbol 进行语义上下文判断。 除了 Symbol 信息外，还需要记录 as 别名的映射关系，举个例子： 1import { request as req } from &quot;framework&quot;; // 存在别名的局部API导入 上述 import 语句采用了别名导入方式，虽然知道从 framework 导入的 API 名叫 request，但是它在代码中实际是以 req 或 req.xxx 的形式被调用，在判定 API 调用时需要用 req 这个名称去做匹配，所以需要记录这层映射关系。 下面是导入 API 需要记录的信息示例： 123456789let temp = { name: &quot;req&quot;, // 导入后在代码中真实调用使用的 API 名 origin: &quot;request&quot;, // API 别名。null则表示该非别名导入，name就是原本名字 symbolPos: &quot;9&quot;, // symbol指向的声明节点在代码字符串中的起始位置 symbolEnd: &quot;22&quot;, // symbol指向的声明节点在代码字符串中的结束位置 identifierPos: &quot;20&quot;, // API 名字信息节点在代码字符串中的起始位置 identifierEnd: &quot;22&quot;, // API 名字信息节点在代码字符串中的结束位置 line: &quot;1&quot;, // 导入 API 的import语句所在代码行信息}; name：记录在代码中被调用时所用的 API 名，origin 为 null 时，name 也是 API 本名。 origin：从目标依赖导出的 API 本名，null 表示非别名导入，不需映射。 symbolPos，symbolEnd：API 声明节点在代码字符串中索引的起始 / 结束位置。 这里没有记录完整的 Symbol 对象，只记录了 Symbol 指向的声明节点的 pos 和 end 属性值，因为声明节点在代码字符流中的索引位置是唯一且确定的，所以后续步骤在判定代码中的节点是否由 Import 语句中导入的 API 声明时，只需要对比 Symbol 对象指向的声明节点 pos 和 end 属性值与这两个属性值是否一致就可以了。 identifierPos，identifierEnd： API 名称对应的 Identifier 节点在代码字符串中索引的起始 / 结束位置，记录这两个索引位置也是为了后续步骤在分析节点时做唯一性判定。 在搞清楚要收集哪些信息后，完善一下 _findImportItems 函数中收集节点信息的逻辑。这里需要注意的是，不同导入方式在收集这些信息时的获取方式也不同，这就是一定要区分它们的原因。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// 分析import导入 _findImportItems(ast, filePath, baseLine = 0) { let importItems = {}; let that = this; // this表示codeAnalysis实例 // 记录导入的API及相关信息 function dealImports(temp){ importItems[temp.name] = {}; importItems[temp.name].origin = temp.origin; importItems[temp.name].symbolPos = temp.symbolPos; importItems[temp.name].symbolEnd = temp.symbolEnd; importItems[temp.name].identifierPos = temp.identifierPos; importItems[temp.name].identifierEnd = temp.identifierEnd; ...... } // 遍历AST寻找import节点 function walk(node) { // console.log(node); tsCompiler.forEachChild(node, walk); const line = ast.getLineAndCharacterOfPosition(node.getStart()).line + baseLine + 1; // 分析导入情况 if(tsCompiler.isImportDeclaration(node)){ // 命中target if(node.moduleSpecifier &amp;&amp; node.moduleSpecifier.text &amp;&amp; node.moduleSpecifier.text == that._analysisTarget){ // 存在导入项 if(node.importClause){ // default直接导入场景 if(node.importClause.name){ let temp = { name: node.importClause.name.escapedText, origin: null, symbolPos: node.importClause.pos, symbolEnd: node.importClause.end, identifierPos: node.importClause.name.pos, identifierEnd: node.importClause.name.end, line: line }; dealImports(temp); } if(node.importClause.namedBindings){ // 拓展导入场景，包含as情况 if (tsCompiler.isNamedImports(node.importClause.namedBindings)) { if(node.importClause.namedBindings.elements &amp;&amp; node.importClause.namedBindings.elements.length&gt;0) { // console.log(node.importClause.namedBindings.elements); const tempArr = node.importClause.namedBindings.elements; tempArr.forEach(element =&gt; { if (tsCompiler.isImportSpecifier(element)) { let temp = { name: element.name.escapedText, origin: element.propertyName ? element.propertyName.escapedText : null, symbolPos: element.pos, symbolEnd: element.end, identifierPos: element.name.pos, identifierEnd: element.name.end, line: line }; dealImports(temp); } }); } } // * 全量导入as场景 if (tsCompiler.isNamespaceImport(node.importClause.namedBindings) &amp;&amp; node.importClause.namedBindings.name){ let temp = { name: node.importClause.namedBindings.name.escapedText, origin: '*', symbolPos: node.importClause.namedBindings.pos, symbolEnd: node.importClause.namedBindings.end, identifierPos: node.importClause.namedBindings.name.pos, identifierEnd: node.importClause.namedBindings.name.end, line: line }; dealImports(temp); } } } } } } walk(ast); // console.log(importItems); return importItems; } 上述代码中提取 ast 相关属性的逻辑结合 TypeScript AST Viewer 一起理解，用 importItems 这个 Map 结构来收集导入的 API 信息，收集的逻辑抽离在 dealImports 子函数中。 12345678910111213141516// 扫描代码文件 &amp; 分析代码 _scanCode() { ...... const entrys = this._scanFiles(); // 扫描所有需要分析的代码文件 // 遍历每个文件，依次（解析AST，分析import，分析API调用） entrys.forEach(()=&gt;{ ...... const { ast, ...} = parseTs(...) // 将TS代码文件解析为 AST const importItems = this._findImportItems(ast, ...) // 遍历 AST 分析 import 节点 if(Object.keys(importItems).length &gt;0){ this._dealAST(importItems, ast, ...) // 遍历 AST 分析 API 调用 } ...... }) ...... }","link":"/2023/02/01/project/%E4%BE%9D%E8%B5%96%E6%B2%BB%E7%90%86/4.import%E8%8A%82%E7%82%B9%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90/"},{"title":"代码lint&amp;项目构建","text":"lint lint 这块理解不够深，先把别人的搬过来，后面再多看 代码 lintLint 从狭义角度上看是代码语法规则，风格上的限制。但从广义上看，项目中涉及到的代码样式、缩进及 commit 规则的限制都属于 lint 的范畴，就针对这三个方向学习下，如何建立工程的统一规范。 代码语法类型 针对项目的代码语法类型的规范，通常会使用 eslint 来进行代码层面的约束，它是一个插件化的 JavaScript 代码检测工具，可以开箱即用，其中制定的规范也相对完善，可以作为团队统一的一个标准。 首先在空项目（可以npm init初始化一个）执行下面的命令来安装对应的依赖。 1npm install eslint eslint-plugin-react @typescript-eslint/eslint-plugin @typescript-eslint/parser --save-dev 然后执行npx eslint --init来初始化一下 eslint 的配置，因为是一个 SSR 的项目，所以在配置的选择上，需要考虑以下几点。 技术栈：React，相对于大项目，React 具备更高的上限和可定制化能力，对函数式编程的思想也更容易领悟，所以针对大型项目，用 React。 是否使用 TypeScript：是，可以有效解决 JS 弱类型导致的相关隐性 Bug。 运行环境：SSR 项目同时包括客户端和服务端，所以选用浏览器 + node 的环境。 模块导入类型：因为包含客户端和服务端，node 层很难避免使用 require,，所以建议选用 ES Modules + Commonjs，没必要对这部分进行 lint 了。 具体的选择可以参考下面。 执行完成后会得到一个 .eslintrc.js 的文件，这时候 eslint 的初始化就已经完成了，在它的基础上加一些调整。 123456789101112131415161718192021222324252627// .eslintrc.jsmodule.exports = { env: { browser: true, commonjs: true, // ADD, 支持对commonjs全局变量的识别 es2021: true, node: true, }, extends: [ &quot;eslint:recommended&quot;, &quot;plugin:react/recommended&quot;, &quot;plugin:@typescript-eslint/recommended&quot;, ], parser: &quot;@typescript-eslint/parser&quot;, parserOptions: { ecmaFeatures: { jsx: true, }, ecmaVersion: &quot;latest&quot;, }, plugins: [&quot;react&quot;, &quot;@typescript-eslint&quot;], rules: { &quot;react/jsx-uses-react&quot;: &quot;off&quot;, &quot;react/react-in-jsx-scope&quot;: &quot;off&quot;, &quot;@typescript-eslint/no-var-requires&quot;: &quot;off&quot;, },}; 在原来的基础上，在 env 的配置中加上了commonjs: true，这个是为了支持对 commonjs 全局变量的识别，然后移除了 lint 中的三个规则： react/jsx-uses-react：必须增加对import React from 'react';的引入，在 React 17 之后，jsx 的页面已经不再需要引入 React 了，所以去掉这条 lint 规则。 react/react-in-jsx-scope：同上。 @typescript-eslint/no-var-requires：禁用使用 require 来定义，node 很多相关的依赖没有对 es module 的定义，所以也去掉这条 lint 规则。 做到这里，eslint 相关的配置就可以了，可以简单试验一下。 commit lint 对于 commit 的 lint ，我们可以使用 commitlint 来实现，在项目终端中执行下面的脚本。 123npm install --save-dev @commitlint/config-conventional @commitlint/cliecho &quot;module.exports = {extends: ['@commitlint/config-conventional']};&quot; &gt; commitlint.config.js 如果是 Windows 系统的同学就不要执行echo &quot;module.exports = {extends: ['@commitlint/config-conventional']};&quot; &gt; commitlint.config.js命令了，可能会导致生成 UTF-16 LE 编码的文件运行报错，可以直接在 VsCode 中生成文件，如下： 12345678// commitlint.config.jsmodule.exports = { extends: [&quot;@commitlint/config-conventional&quot;], rules: { &quot;type-enum&quot;: [2, &quot;always&quot;, [&quot;feat&quot;, &quot;fix&quot;, &quot;revert&quot;]], &quot;subject-max-length&quot;: [1, &quot;always&quot;, 30], },}; 其中 type-enum 是指 commit 正文的前缀，通常我们会用到这三种： Feat：一个新的功能； Fix： 一次修复，之前已有问题的修复； Revert：一次回滚，书写异常代码后的撤销。 subject-max-length 则对应实际的 commit 长度（不包括前缀），这里我们设置为 30 到这里，commitlint 的配置就可以了，我们可以简单实验一下。 1echo 'add commitlint config' | npx commitlint 1echo 'feat: add commitlint config' | npx commitlint 可以看到已经可以进行 commit 的限制了，不过这个和我们的预期还有一些出入，在 commit 前每次手动执行 commitlint是很麻烦的，作为统一的规范也不现实，这里我们可以把 commitlint 加到 git 提供的 hook 中，作为 commit前自然会做的事情，有一个依赖 husky 可以帮助我们生成脚本文件，通过配置来自动做这个事情就不再需要去改动本地的 hook 了。 执行下面的脚本来对 husky 初始化一下，要注意 ， 用这个脚本的前提是 ， 这是一个 git 仓库，因为我们也是对 git hook 进行脚本绑定 。 123npm install husky --save-devnpx husky installnpx husky add .husky/pre-commit 执行完以后会生成一个钩子，目录结构是这样的： 其中 pre-commit 就是我们生成的钩子了，然后我们将 eslint 和 commitlint 的脚本替换 undefined。 12345#!/usr/bin/env sh. &quot;$(dirname -- &quot;$0&quot;)/_/husky.sh&quot;npx eslint src/**npx --no-install commitlint --edit $1 然后我们再提交一下 commit 试试。 1git commit -m &quot;test&quot; 可以看到如果其中有不符合预期的地方，将自动中断 commit 的进程，如果需要跳过这个检测，可以在脚本后面加上--no-verify，不过这样就失去 lint 的意义了，最好还是解决完相关的 error 阻塞问题再进行提交。 代码样式 一个多人合作的项目中，如果缺乏对代码样式的自动美化，那很可能出现下面的情况。 1234567const a = () =&gt; { return 1;}const b = () =&gt; { return 2;} 不同开发者的间隔或者是换行的习惯都不同，就导致项目代码百花齐放，对于维护同学来说，简直就是噩梦般的体验。解决这个问题，VsCode给我们提供了很多代码美化插件，我们只需要在 IDE 上进行对应的配置就行，下面我们以 Prettier - Code formatter来举例具体怎么操作。 首先我们到 VsCode 的应用商城里下载一下对应的插件。 然后我们进入 IDE 顶部栏的 File -&gt; Preferences -&gt; Settings，并勾选 format on save，让我们在保存的时候默认格式化即可。 最后一步我们随便打开一个文件，右键选择 Format Document With…，选择我们刚才下载的插件即可。 到这里，lint 相关的部分我们就配置完了，我们已经有了相对舒适的开发环境，爱捣鼓的同学也可以到 eslint、commitlint 等官网上阅读提供的更多字段，定制最符合自己习惯的 IDE。 项目构建配置完 lint，我们就该想办法让我们的项目跑起来了。我们先创建一个 index.js 作为入口文件，然后简单写一点服务端代码。 1npm install express --save 123456789101112131415161718192021// ./src/index.jsconst express = require(&quot;express&quot;);const childProcess = require(&quot;child_process&quot;);const app = express();app.get(&quot;*&quot;, (req, res) =&gt; { res.send(` &lt;html &lt;body&gt; &lt;div&gt;hello-ssr&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; `);});app.listen(3000, () =&gt; { console.log(&quot;ssr-server listen on 3000&quot;);});childProcess.exec(&quot;start http://127.0.0.1:3000&quot;); 我们用node src/index.js启动一下就可以看到： 但是因为我们要用 TS，Node 是不支持直接执行 TS 文件的，对于这个我们有两个方案去解决： 用 ts-node 去执行 TS 文件； 用 Webpack 打包后，然后执行打包后的 bundle.js 文件。 这里我们最后选用的是第二种方案，原因在于项目出于生产的考虑，Webpack（或是其他构建工具类似 Vite) 是一定要有的，因为有使用 Webpack 别名的需求，如果使用 ts-node 没办法编译别名的模块，后期也没办法执行。 对第一种方案感兴趣的同学也可以结合我们本节课的 github 仓库的 commit history 来调试了解，对应记录是 “ feat: ts-node 对 tsx 的相关配置 &amp; 使用 renderToString 在服务器渲染 JSX 页面 ” 。 在选好方案后，我们来对对应的文件进行打包，我们需要创建两个配置文件， webpack.base.js 和webpack.server.js，其中 webpack.base.js 是通用的 Webpack配置，因为后期还会新增对客户端的打包，其中有部分配置是相似的，所以这里我们抽出通用配置，用 merge 来进行合并。 12345678910111213141516171819202122232425262728// webpack.base.jsconst path = require(&quot;path&quot;);module.exports = { module: { rules: [ { test: /.js$/, loader: &quot;babel-loader&quot;, exclude: /node_modules/, options: { presets: [&quot;@babel/preset-env&quot;], }, }, { test: /.(ts|tsx)?$/, use: &quot;ts-loader&quot;, exclude: /node_modules/, }, ], }, resolve: { extensions: [&quot;.tsx&quot;, &quot;.ts&quot;, &quot;.js&quot;], alias: { &quot;@&quot;: path.resolve(process.cwd(), &quot;./src&quot;), }, },}; 1234567891011121314// webpack.server.jsconst path = require(&quot;path&quot;);const { merge } = require(&quot;webpack-merge&quot;);const baseConfig = require(&quot;./webpack.base&quot;);module.exports = merge(baseConfig, { mode: &quot;development&quot;, entry: &quot;./src/server/index.tsx&quot;, target: &quot;node&quot;, output: { filename: &quot;bundle.js&quot;, path: path.resolve(process.cwd(), &quot;server_build&quot;), },}); 编译的 loader 我们使用 babel-loader 和 ts-loader，分别用于构建 JS 和 TS 的代码。这里需要把我们上面配置的文件目录改到 entry 入口写的 src /server/index.tsx ，并且安装一下相关的依赖。 1npm install @babel/preset-env babel-loader ts-loader webpack webpack-merge webpack-cli --save-dev 换成 TS 后，我们需要调整一下 express 导入方式，使得可以读到. d.ts 中对应的依赖。 123456789101112131415161718192021// ./src/server/index.tsximport express from &quot;express&quot;;import childProcess from &quot;child_process&quot;;const app = express();app.get(&quot;*&quot;, (req, res) =&gt; { res.send(` &lt;html &lt;body&gt; &lt;div&gt;hello-ssr&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; `);});app.listen(3000, () =&gt; { console.log(&quot;ssr-server listen on 3000&quot;);});childProcess.exec(&quot;start http://127.0.0.1:3000&quot;); 做完这些，Webpack 的部分就已经完工了，我们只需要再配置一下 tsconfig.json 用于 TS 代码的编译即可。 123456789101112131415161718192021222324// tsconfig.json{ &quot;compilerOptions&quot;: { &quot;module&quot;: &quot;CommonJS&quot;, &quot;types&quot;: [&quot;node&quot;], // 声明类型，使得ts-node支持对tsx的编译 &quot;jsx&quot;: &quot;react-jsx&quot;, // 全局导入, 不再需要每个文件定义react &quot;target&quot;: &quot;es6&quot;, &quot;lib&quot;: [&quot;dom&quot;, &quot;dom.iterable&quot;, &quot;esnext&quot;], &quot;allowJs&quot;: true, &quot;skipLibCheck&quot;: true, &quot;esModuleInterop&quot;: true, &quot;allowSyntheticDefaultImports&quot;: true, &quot;strict&quot;: true, &quot;forceConsistentCasingInFileNames&quot;: true, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;resolveJsonModule&quot;: true, &quot;isolatedModules&quot;: true, &quot;baseUrl&quot;: &quot;./&quot;, &quot;paths&quot;: { &quot;@/*&quot;: [&quot;./src/*&quot;] } }, &quot;include&quot;: [&quot;src/**/*&quot;]} 这时候同学们可以在控制台中执行npx webpack build --config ./webpack.server.js --watch来进行编译， –watch 代表会监听入口文件的变化，有 diff 就会更新 build 内容进行热更新，这时候大家可能会遇到下面的报错： 是因为我们使用了 express，但是 express 是没有内置 .d.ts 的类型定义的，我们需要额外安装对应的类型定义依赖。 1npm install @types/express --save-dev 这时候我们再试试上面的构建命令： 成功了，可以看到目录下也会生成一个 server_build/bundle.js 的构建文件，我们尝试执行它。 1node server_build/bundle.js 发现可以打开和上面一样的页面，就说明我们已经配置构建成功了！ 不过现在还有一个问题，后面我们开发每次编辑以后都需要重新运行 node，来执行最新的代码，这样开发的效率无疑是很低效的，我们可以使用nodemon 来替代 node来运行这个脚本，它提供了对运行文件监听的能力，当我们的文件修改的时候，它也会同步进行热更新，不需要我们重新去启动了。 1npm install nodemon --save-dev 为了后面运行方便，每次不写这么长的脚本，可以在 package.json 中加入构建和启动的常用的命令。 12345// package.json&quot;scripts&quot;: { &quot;start&quot;: &quot;npx nodemon --watch src server_build/bundle.js&quot;, &quot;build:server&quot;: &quot;npx webpack build --config ./webpack.server.js --watch&quot;, } 后面我们启动项目，只需要执行下面的命令就可以了，很方便快捷。 12npm run build:servernpm run start","link":"/2023/03/05/ssr/%E5%8E%9F%E7%90%86/1.%E4%BB%A3%E7%A0%81lint&%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"},{"title":"AST","text":"上一节，我们搭建了代码的 lint，写了一个很简单的服务器端 demo，并通过运行构建产物的方式运行了项目，对于上次的页面，大家打开 network 可以看到它向服务器端的请求是一个完整的 HTML。 在前几节，我们介绍过服务器端渲染的特点就是所有 dom 、数据的拼接在服务器端完成，使得在客户端拿到的是一个完整的url，这个其实就是服务器端渲染，但是这里我们是通过 send 直接返回的 HTML字符串，和我们渲染静态页面的预期还有差距，那么我们应该怎么在现在的基础上去渲染一个静态页面呢？ 一个应用渲染静态页面的过程，其实可以分为以下三个步骤： 模板页面的渲染：即 HTML 中 body 标签下的 dom 内容，像我们平时写一个基于 React 或是 Vue 的前后端分离项目，首先我们会去编写对应页面的模板模块，再写相关的数据请求，最后统一导出进行页面的渲染。 路由的匹配：一个 Web 工程下可能会有多个模板页面需要渲染，我们会使用路由去对应指定的模板页面进行渲染，体现在浏览器中，也就是我们域名后的后缀。 header 标签的修改：模板页面本身是没办法去修改页面的 header 标签的，但是修改 header 标签的需求其实并不少见，类似修改站点的标题， 或是进行多媒体适配，可能都需要对 header 标签有一定修改。 包括上面三个能力的静态渲染才是完整的，这点对于 SSR 也是类似的，所以这小节我们将就三个方面来完成 SSR 的静态页面渲染。 模板页面的渲染我们先安装一下 React 模板相关的依赖， 然后在 src/pages 下创建一个简单的模板页面。这边是使用 React函数式的写法来搭建模板而不是创建类的形式，在大型项目中， React 函数式的写法不需要创建实例，可以按照实际的业务情形来拆分组件的粒度，加上有react hook 的帮助，我们已经不再需要去过多关注生命周期，相反更多是一种“组合大于继承”的思想，对大家理解函数式编程也会有大的帮助。 12npm install react react-dom --savenpm install @types/react @types/react-dom --save-dev 1234567891011121314151617// ./src/pages/Home/index.tsxconst Home = () =&gt; { return ( &lt;div&gt; &lt;h1&gt;hello-ssr&lt;/h1&gt; &lt;button onClick={(): void =&gt; { alert(&quot;hello-ssr&quot;); }} &gt; alert &lt;/button&gt; &lt;/div&gt; );};export default Home; 模板创建好了，现在我们需要思考，怎么才能把这个模板转换成 HTML 标签传递给服务器端呢？这里我们可以使用 react-dom 中暴露的renderToString 方法，这个方法可以把模板元素转换成 HTML 字符串返回。它的底层和客户端模板编译其实是一样的，都是根据 AST（也就是虚拟 DOM ）来转化成真实 DOM 的过程，React 在它的基础上，提供了更多流相关的能力，返回了一套 server 相关的api，感兴趣的同学可以阅读 React 官方文档对应的描述。 现在我们来通过 renderToString 改造一下我们的 server 入口文件。 123456789101112131415161718192021222324// ./src/server/index.tsximport express from &quot;express&quot;;import childProcess from &quot;child_process&quot;;import { renderToString } from &quot;react-dom/server&quot;;import Home from &quot;@/pages/Home&quot;;const app = express();const content = renderToString(&lt;Home /&gt;);app.get(&quot;*&quot;, (req, res) =&gt; { res.send(` &lt;html &lt;body&gt; &lt;div&gt;${content}&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; `);});app.listen(3000, () =&gt; { console.log(&quot;ssr-server listen on 3000&quot;);});childProcess.exec(&quot;start http://127.0.0.1:3000&quot;); 刷新一下页面： 可以看到，已经可以渲染出页面，不过按钮上的事件没绑定上去，点 alert 是没有反应的，因为 rendertoString 只是渲染页面，而事件相关的绑定是没办法在服务器端中进行的，那我们怎么才能把事件绑定到静态页面呢？ 之前我们有介绍过，掘金也是服务端渲染，我们看看它是怎么做的。 可以看到，掘金服务端返回的 HTML 文本中包括一组打包过后的 JS，这个其实就是这个页面所对应的相关事件和脚本，我们只需要打包过后将 JS 绑定在 HTML 中就可以。 这个也叫“同构”，是服务器端渲染的核心概念 ，同一套 React代码在服务器端渲染一遍，然后在客户端再执行一遍。服务端负责静态 dom的拼接，而客户端负责事件的绑定，不仅是模板页面渲染，后面的路由，数据的请求都涉及到同构的概念。可以理解成，服务器端渲染都是基于同构去展开的，大家这里关注一下这个概念，对后面的学习理解会有很大的帮助 现在我们就开始将模板中的脚本打包引入到 HTML 中，这里我们就要用到ReactDom.hydrateRoot了，这个在上面给到的 React 官网中也有相关的介绍： If you call ReactDOM.hydrateRoot() on a node thatalready has this server-rendered markup, React will preserve it and onlyattach event handlers, allowing you to have a very performantfirst-load experience. 在已经提供了服务器端静态渲染节点的情况下使用，它只会对模板中的事件进行处理，这样就可以满足我们的需求了，新增一个 src/client/index.tsx 作为我们客户端页面的构建入口： 123456// src/client/index.tsximport { hydrateRoot } from &quot;react-dom/client&quot;;import Home from &quot;@/pages/Home&quot;;hydrateRoot(document.getElementById(&quot;root&quot;) as Document | Element, &lt;Home /&gt;); ReactDom.hydrateRoot 需要指定一个绑定的真实 dom，我们给 server 入口 send 的页面加一个 id ： 123456789101112131415161718192021222324// src/server/index.tsximport express from &quot;express&quot;;import childProcess from &quot;child_process&quot;;import { renderToString } from &quot;react-dom/server&quot;;import Home from &quot;@/pages/Home&quot;;const app = express();const content = renderToString(&lt;Home /&gt;);app.get(&quot;*&quot;, (req, res) =&gt; { res.send(` &lt;html &lt;body&gt; &lt;div id=&quot;root&quot;&gt;${content}&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; `);});app.listen(3000, () =&gt; { console.log(&quot;ssr-server listen on 3000&quot;);});childProcess.exec(&quot;start http://127.0.0.1:3000&quot;); 这样客户端的部分就改造好了，我们也对应给它配一套 webpack 配置，加上对应的构建命令： 12345678910111213// webpack.client.jsconst path = require(&quot;path&quot;);const { merge } = require(&quot;webpack-merge&quot;);const baseConfig = require(&quot;./webpack.base&quot;);module.exports = merge(baseConfig, { mode: &quot;development&quot;, entry: &quot;./src/client/index.tsx&quot;, output: { filename: &quot;index.js&quot;, path: path.resolve(process.cwd(), &quot;client_build&quot;), },}); 123456// package.json&quot;scripts&quot;: { &quot;start&quot;: &quot;npx nodemon --watch src server_build/bundle.js&quot;, &quot;build:client&quot;: &quot;npx webpack build --config ./webpack.client.js --watch&quot;, &quot;build:server&quot;: &quot;npx webpack build --config ./webpack.server.js --watch&quot;,}, 我们执行一下npm run build:client 看看构建结果： 可以看到构建成功了，并且页面目录下会生成对应的 build_client/index.js 的构建文件，下一步我们将 index.js 加入到返回的 HTML 中： 12345678910111213141516171819202122232425262728// ./src/server/index.tsximport express from &quot;express&quot;;import childProcess from &quot;child_process&quot;;import { renderToString } from &quot;react-dom/server&quot;;import Home from &quot;@/pages/Home&quot;;import path from &quot;path&quot;;const app = express();const content = renderToString(&lt;Home /&gt;);app.use(express.static(path.resolve(process.cwd(), &quot;client_build&quot;)));app.get(&quot;*&quot;, (req, res) =&gt; { res.send(` &lt;html &lt;body&gt; &lt;div id=&quot;root&quot;&gt;${content}&lt;/div&gt; &lt;script src=&quot;/index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; `);});app.listen(3000, () =&gt; { console.log(&quot;ssr-server listen on 3000&quot;);});childProcess.exec(&quot;start http://127.0.0.1:3000&quot;); 在上面的代码中，app.use(express.static(path.resolve(process.cwd(), &quot;client_build&quot;)));我们将对应的打包文件作为静态文件导入，然后在 script 中引入对应的路由访问即可，这时候大家可以运行npm run start看一下结果了： 可以看到，已经有对应静态资源的请求了，页面也已经可以绑定事件了，到这里模板页面的渲染就已经完成了。 路由的匹配上面我们只加入了 Home 页面的访问，但是事实上咱们站点不可能只有一个页面，所以我们需要再加上路由的匹配，那我们应该怎么做呢？ 上个小标题我们介绍了同构的概念，同构有一个原因是，客户端和服务端的返回需要保持一致，不然会有客户端的报错，页面也没办法正常匹配。所以我们需要同时为客户端和服务端的入口都加上对应的路由配置。 首先我们先安装一下路由相关的依赖： 1npm install react-router-dom --save 再创建一个简单的 demo 模板页面，光只有一个模板页面，路由咱也不太好试验： 12345678// ./src/pages/Demo/index.tsximport { FC } from &quot;react&quot;;const Demo: FC = (data) =&gt; { return &lt;div&gt;这是一个demo页面&lt;/div&gt;;};export default Demo; 然后我们创建一个 router.tsx 来存放路由相关的配置，现在总共有两个路由： 123456789101112131415161718192021// ./src/router.tsximport Home from &quot;@/pages/Home&quot;;import Demo from &quot;@/pages/Demo&quot;;interface IRouter { path: string; element: JSX.Element;}const router: Array&lt;IRouter&gt; = [ { path: &quot;/&quot;, element: &lt;Home /&gt;, }, { path: &quot;/demo&quot;, element: &lt;Demo /&gt;, },];export default router; 接着我们来改造客户端，我们将上面路由的配置遍历一下，塞到对应 Route 节点中： 123456789101112131415161718// ./src/client/index.tsximport { hydrateRoot } from &quot;react-dom/client&quot;;import { BrowserRouter, Route, Routes } from &quot;react-router-dom&quot;;import router from &quot;@/router&quot;;const Client = (): JSX.Element =&gt; { return ( &lt;BrowserRouter&gt; &lt;Routes&gt; {router?.map((item, index) =&gt; { return &lt;Route {...item} key={index} /&gt;; })} &lt;/Routes&gt; &lt;/BrowserRouter&gt; );};hydrateRoot(document.getElementById(&quot;root&quot;) as Document | Element, &lt;Client /&gt;); 服务端也相同，我们用路由的部分来替换上面固定的&lt;Home /&gt;： 123456789101112131415161718192021222324252627282930313233343536373839// ./src/server/index.tsximport express from &quot;express&quot;;import childProcess from &quot;child_process&quot;;import { renderToString } from &quot;react-dom/server&quot;;import path from &quot;path&quot;;import router from &quot;@/router&quot;;import { Route, Routes } from &quot;react-router-dom&quot;;import { StaticRouter } from &quot;react-router-dom/server&quot;;const app = express();app.use(express.static(path.resolve(process.cwd(), &quot;client_build&quot;)));app.get(&quot;*&quot;, (req, res) =&gt; { const content = renderToString( &lt;StaticRouter location={req.path}&gt; &lt;Routes&gt; {router?.map((item, index) =&gt; { return &lt;Route {...item} key={index} /&gt;; })} &lt;/Routes&gt; &lt;/StaticRouter&gt; ); res.send(` &lt;html &lt;body&gt; &lt;div id=&quot;root&quot;&gt;${content}&lt;/div&gt; &lt;script src=&quot;/index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; `);});app.listen(3000, () =&gt; { console.log(&quot;ssr-server listen on 3000&quot;);});childProcess.exec(&quot;start http://127.0.0.1:3000&quot;); 其中StaticRouter 是无状态的路由，因为服务器端不同于客户端，客户端中，浏览器历史记录会改变状态，同时将屏幕更新，但是服务器端是不能改动到应用状态的，所以我们这里采用无状态路由。 做完这些路由的改造就完成了，还是很简单的，只是在客户端和服务器端都进行路由配置即可，这时候大家可以重新运行，打开 http://127.0.0.1:3000/demo，可以看到已经可以进行路由匹配了。 因为存在客户端路由和服务端路由，所以服务器端渲染通过不同的方式跳转也会采用不同的渲染方式，当使用 React内置的路由跳转的时候，会进行客户端路由的跳转，采用客户端渲染；而通过 a标签，或者原生方式打开一个新页面的时候，才会进行服务器端路由的跳转，使用服务器端渲染。 我们可以做个小实验来验证一下，改造 home 页面如下： 1234567891011121314151617181920212223242526272829// ./src/pages/Home/index.tsximport { useNavigate } from &quot;react-router-dom&quot;;const Home = () =&gt; { const navigate = useNavigate(); return ( &lt;div&gt; &lt;h1&gt;hello-ssr&lt;/h1&gt; &lt;button onClick={(): void =&gt; { alert(&quot;hello-ssr&quot;); }} &gt; alert &lt;/button&gt; &lt;a href=&quot;http://127.0.0.1:3000/demo&quot;&gt;链接跳转&lt;/a&gt; &lt;span onClick={(): void =&gt; { navigate(&quot;/demo&quot;); }} &gt; 路由跳转 &lt;/span&gt; &lt;/div&gt; );};export default Home; 我们加上了两个跳转，刷新页面，当点击“链接跳转 ” 的时候，可以看到 network 中会有对服务器端的请求，所以是通过服务器端渲染的页面。 当我们点击“路由跳转 ” 的时候，走的是客户端路由，这时候打开的页面将不是服务器端渲染，而是会走客户端渲染兜底，可以看到 network 中是没有对服务器端的 HTML 请求的。 Header 标签的修改上面我们一起来实践了 SSR 的模板页面的渲染和路由匹配，不过这个还不能满足我们所有静态页面的需求，因为模板页面只是影响到 body 的部分，修改不同路由下对应的标题，多媒体适配或是 SEO 时加入的相关 meta 关键字，都需要加入相关的 header。 我们进入正题，服务器端渲染怎么才能修改到对应的 header 呢？可以使用 react-helmet 来实现我们的需求，这个依赖支持对文档头进行调整，我们先来安装一下依赖： 12npm install react-helmet --savenpm install @types/react-helmet --save-dev 同样，这个调整是需要同构的，客户端和服务端都要针对性调整，我们先对客户端进行改造，以 Home 页举例： 12345678910111213141516171819202122232425262728293031323334353637// ./src/pages/Home/index.tsximport { useNavigate } from &quot;react-router-dom&quot;;import { Fragment } from &quot;react&quot;;import { Helmet } from &quot;react-helmet&quot;;const Home = () =&gt; { const navigate = useNavigate(); return ( &lt;Fragment&gt; &lt;Helmet&gt; &lt;title&gt;简易的服务器端渲染 - HOME&lt;/title&gt; &lt;meta name=&quot;description&quot; content=&quot;服务器端渲染&quot;&gt;&lt;/meta&gt; &lt;/Helmet&gt; &lt;div&gt; &lt;h1&gt;hello-ssr&lt;/h1&gt; &lt;button onClick={(): void =&gt; { alert(&quot;hello-ssr&quot;); }} &gt; alert &lt;/button&gt; &lt;a href=&quot;http://127.0.0.1:3000/demo&quot;&gt;链接跳转&lt;/a&gt; &lt;span onClick={(): void =&gt; { navigate(&quot;/demo&quot;); }} &gt; 路由跳转 &lt;/span&gt; &lt;/div&gt; &lt;/Fragment&gt; );};export default Home; 然后我们对服务器端也进行相同的同构，保证服务器端的返回也是相同的 header，这一点很重要，因为大部分搜索引擎的爬虫关键词爬取都是根据服务器返回内容进行关键词检索的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import express from &quot;express&quot;;import childProcess from &quot;child_process&quot;;import { renderToString } from &quot;react-dom/server&quot;;import path from &quot;path&quot;;import router from &quot;@/router&quot;;import { Route, Routes } from &quot;react-router-dom&quot;;import { StaticRouter } from &quot;react-router-dom/server&quot;;import { Helmet } from &quot;react-helmet&quot;;const app = express();app.use(express.static(path.resolve(process.cwd(), &quot;client_build&quot;)));app.get(&quot;*&quot;, (req, res) =&gt; { const content = renderToString( &lt;StaticRouter location={req.path}&gt; &lt;Routes&gt; {router?.map((item, index) =&gt; { return &lt;Route {...item} key={index} /&gt;; })} &lt;/Routes&gt; &lt;/StaticRouter&gt; ); const helmet = Helmet.renderStatic(); res.send(` &lt;html &lt;head&gt; ${helmet.title.toString()} ${helmet.meta.toString()} &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;${content}&lt;/div&gt; &lt;script src=&quot;/index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; `);});app.listen(3000, () =&gt; { console.log(&quot;ssr-server listen on 3000&quot;);});childProcess.exec(&quot;start http://127.0.0.1:3000&quot;); Helmet.renderStatic()可以提供渲染时添加的所有内容，这样我们就已经完成 header 标签的修改了，可以刷新一下页面看一下效果： 小结这一节课，我们学习了如何实现 SSR 的静态页面渲染，包括模板页面的渲染、路由的匹配和 Header标签的修改，同时也介绍了服务器端渲染中一个很重要的概念 –同构，相信大家学习后对服务器端渲染已经有了一个相对深刻的了解，同学们也可以结合下面画的思维导图回忆温习一下今天的内容，加深对整个过程的理解。 现在我们已经实现了静态页面的部分，但是实际上，并不是所有的数据都是静态的，往往需要通过接口的请求来拿到预期的数据。所以在下节课，我们将来学习，如何支持 SSR 的数据请求。","link":"/2023/02/01/ssr/%E5%8E%9F%E7%90%86/2.%E5%AE%9E%E7%8E%B0ssr%E7%9A%84%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93/"},{"title":"stencil原理","text":"stencil 本质也就是基于 Web Components Web ComponentsWeb Components 的基本概念， Web Component 是指一系列加入 w3c 的 HTML 与 DOM 的特性，目的是为了从原生层面实现组件化，可以使开发者开发、复用、扩展自定义组件，实现自定义标签。 例如： 123456// 假如已经构建好一个 Web Components 组件 &lt;hello-world&gt;并导出// 在 html 页面，就可以直接引用组件&lt;script src=&quot;/my-component.js&quot;&gt;&lt;/script&gt;// 而在 html 可以这样使用&lt;hello-world&gt;&lt;/hello-word&gt; 而且跟任何框架无关，代表着它不需要任何外部 runtime 的支持，也不需要复杂的 Vnode 算法映射到实际 DOM，只是浏览器 api 本身对标签内部逻辑进行一些编译处理，性能必定会比一些 MV*框架要好一些。 三个核心 API1. Custom elements（自定义元素）这个是 web component 的基础。 自定义元素挂载方法 自定义元素通过 CustomElementRegistry 来自定义可以直接渲染的 html 元素，挂载在 window.customElements.define 来供开发者调用，demo 如下： 123456789101112131415161718192021222324// 假如已经构建好一个 Web Components 组件 &lt;hello-world&gt;并导出class HelloWorld extends HTMLElement { constructor() { super(); this.attachShadow({ mode: 'open' }); this.shadowRoot.innerHTML = ` &lt;style&gt; :host { display: block; padding: 10px; background-color: #eee; } &lt;/style&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; `; }}// 挂载window.customElements.define('hello-world', HelloWorld)// 然后就可以在 html 中使用&lt;hello-world&gt;&lt;/hello-world&gt; 注意：自定义元素必须用’-‘连接符连接，来作为特定的区分，如果没有检测到自定义元素，则浏览器会作为空 div 处理。 渲染结果： 自定义元素的类 由上面的例子 “class HelloWorld extends HTMLElement { xxx } “ 发现，自定义元素的构造都是基于 HTMLElement，所以它继承了 HTML 元素特性，当然，也可以继承 HTMLElement 的派生类，如：HTMLButtonElement 等，来作为现有标签的扩展。 自定义元素的生命周期 类似于现有 MV*框架的生命周期，自定义元素的基类里面也包含了完整的生命周期 hook 来提供给开发者实现一些业务逻辑的应用： 123456789101112131415161718class HelloWorld extends HTMLElement { constructor() { // 1 构建组件的时候的逻辑 hook super(); } // 2 当自定义元素首次被渲染到文档时候调用 connectedCallback(){ } // 3 当自定义元素在文档中被移除调用 disconnectedCallback(){ } // 4 当自定义组件被移动到新的文档时调用 adoptedCallback(){ } // 5 当自定义元素的属性更改时调用 attributeChangedCallback(){ }} 添加自定义方法和属性 由于自定义元素由一个类来构造，所以添加自定义属性和方法就如同平常开发类的方法一致。 1234567891011121314151617class HelloWorld extends HTMLElement { constructor() { super(); } tag = &quot;hello-world&quot;; say(something: string) { console.log(`hello world, I want to say ${this.tag} ${something}`); }}// 调用方法如下const hw = document.querySelector(&quot;hello-world&quot;);hw.say(&quot;good&quot;);// 控制台打印效果如下 2. Shadow DOM（影子 DOM）顾名思义，影子 DOM 就是用来隔离自定义元素不受到外界样式或者一些副作用的影响，或者内部的一些特性不会影响外部。使自定义元素保持一个相对独立的状态。 日常开发 html 页面的时候也会接触到一些使用 Shadow DOM 的标签，比如：audio 和 video等；在具体 dom 树中它会一一个标签存在，会隐藏内部的结构，但是其中的控件，比如：进度条、声音控制等，都会以一个 Shadow DOM 存在于标签内部， chrome 的控制台 -&gt; Preferences -&gt; Show（user agent Shadow DOM） 查看具体的 DOM 结构，可以查看到内部的结构构成。 如果组件使用 Shadow host，常规 document 中会存在一个 Shadow host 节点用来挂载 ShadowDOM，Shadow DOM 内部也会存在一个 DOM 树：Shadow Tree，根节点为 Shadowroot，外部可以用伪类:host 来访问，Shadow boundary 其实就是 Shadow DOM 的边界。具体架构图如下： Shadow DOM 的实际用处： 12// Shadow DOM 开启方式为this.attachShadow({ mode: &quot;open&quot; }); 不使用 Shadow DOM 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Web Components&lt;/title&gt; &lt;style&gt; h1 { font-size: 20px; color: yellow; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;hello-world&gt;&lt;/hello-world&gt; &lt;h1&gt;Hello World! 外部&lt;/h1&gt; &lt;script type=&quot;module&quot;&gt; class HelloWorld extends HTMLElement { constructor() { super(); // 关闭 shadow DOM // this.attachShadow({ mode: 'open' }); const d = document.createElement(&quot;div&quot;); const s = document.createElement(&quot;style&quot;); s.innerHTML = `h1 { display: block; padding: 10px; background-color: #eee; }`; d.innerHTML = ` &lt;h1&gt;Hello World! 自定义组件内部&lt;/h1&gt; `; this.appendChild(s); this.appendChild(d); } tag = &quot;hello-world&quot;; say(something) { console.log(`hello world, I want to say ${this.tag} ${something}`); } } window.customElements.define(&quot;hello-world&quot;, HelloWorld); const hw = document.querySelector(&quot;hello-world&quot;); hw.say(&quot;good&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 渲染效果如下，样式已经互相污染： 使用 Shadow DOM 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Web Components&lt;/title&gt; &lt;style&gt; h1 { font-size: 20px; color: yellow; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;hello-world&gt;&lt;/hello-world&gt; &lt;h1&gt;Hello World! 外部&lt;/h1&gt; &lt;script type=&quot;module&quot;&gt; class HelloWorld extends HTMLElement { constructor() { super(); this.attachShadow({ mode: &quot;open&quot; }); this.shadowRoot.innerHTML = ` &lt;style&gt; h1 { font-size: 30px; display: block; padding: 10px; background-color: #eee; } &lt;/style&gt; &lt;h1&gt;Hello World! 自定义组件内部&lt;/h1&gt; `; } tag = &quot;hello-world&quot;; say(something) { console.log(`hello world, I want to say ${this.tag} ${something}`); } } window.customElements.define(&quot;hello-world&quot;, HelloWorld); const hw = document.querySelector(&quot;hello-world&quot;); hw.say(&quot;good&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 渲染结果为： 样式直接互相隔离无污染，这就是 Shadow DOM 的好处。 3. HTML templates（HTML 模板）template也是 Web Components API 提供的一个标签，特性就是包裹在 template 中的 HTML 片段不会在页面加载的时候解析渲染，但是可以被 js 访问到，进行一些插入显示等操作。所以它作为自定义组件的核心内容，用来承载 HTML 模板，是不可或缺的一部分。 使用场景如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Web Components&lt;/title&gt; &lt;style&gt; h1 { font-size: 20px; color: yellow; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;hello-world&gt;&lt;/hello-world&gt; &lt;template id=&quot;hw&quot;&gt; &lt;style&gt; .box { padding: 20px; } .box &gt; .first { font-size: 24px; color: red; } .box &gt; .second { font-size: 14px; color: #000; } &lt;/style&gt; &lt;div class=&quot;box&quot;&gt; &lt;p class=&quot;first&quot;&gt;Hello&lt;/p&gt; &lt;p class=&quot;second&quot;&gt;World&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script type=&quot;module&quot;&gt; class HelloWorld extends HTMLElement { constructor() { super(); const root = this.attachShadow({ mode: &quot;open&quot; }); root.appendChild( document.getElementById(&quot;hw&quot;).content.cloneNode(true) ); } } window.customElements.define(&quot;hello-world&quot;, HelloWorld); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 渲染结果为： Slot 相当于一个连接组件内部和外部的一个占位机制，可以用来传递 HTML 代码片段。 原生的 Web Component 处理封装组件并不流畅（用起来比较复杂），需要大量的特殊处理对于数据的监听、DOM 的渲染等等，所以针对这些不符合现在开发模式的情况，提高开发效率的 “轮子” Stencil 应运而生。 StencilStencil 可以理解为一个用于快速构建 Web Components 的工具集。也可以理解为一个编译器，这意味着，当组件一旦经过 build 完成后，就会脱离 Stencil，不再依赖。并且 Stencil 相对原生 Web Components 提供了完善的项目目录架构和配置，并提供了诸多的语法糖和封装函数。 Stencil 官方所描述的自身的优点： Virtual DOM Async rendering (inspired by React Fiber) fiber 的性能优势 像 Fiber 一样的调度模式 Reactive data-binding 单向数据流 TypeScript 组件懒加载 JSX 支持 无依赖性组件 虚拟 DOM 静态网站生成(SSG) 这个虚拟 dom 我自己有点没懂，框架都提供了更新算法，这个功能在框架中应该是无意义的，可能只是为了原生开发而增加，后续要查下资料 Demo ： 123456789101112import { Component, Prop, h } from &quot;@stencil/core&quot;;@Component({ tag: &quot;my-first-component&quot;,})export class MyComponent { @Prop() name: string; render() { return &lt;p&gt;My name is {this.name}&lt;/p&gt;; }} 完善的文档。可以在 Stencil 的官网上查阅到详细且完备的文档，从项目初始化、开发、部署、各个框架的接入方法，FAQ 等等，很完整。可以解决在具体开发中遇到的很多问题。这就可以看出官网真的很用心在维护这个框架。 Stencil 提供完整的入门设置项和 cli 工具，从 “npm init stencil” 开始，Stencil 会提供保姆式的选项配置： 经过配置后，Stencil 会提供一套完整的项目目录，包含各种初始化配置，做到了真正的开箱即用。 由上面 Web Components 使用 DOM 的例子可以看出，原生 Web Components 操作 DOM 并不是很流畅，类似于原生的写法并不高效，例如： 123456789101112const d = document.createElement(&quot;div&quot;);const s = document.createElement(&quot;style&quot;);s.innerHTML = `h1 { display: block; padding: 10px; background-color: #eee; }`;d.innerHTML = ` &lt;h1&gt;Hello World! 自定义组件内部&lt;/h1&gt;`;this.appendChild(s);this.appendChild(d); 而 Stencil 为了解决这一个问题加入了 JSX 语法，使操作 DOM 有了 React 的体验。 12345678910render() { return ( &lt;div&gt; {this.name ? &lt;p&gt;Hello {this.name}&lt;/p&gt; : &lt;p&gt;Hello World&lt;/p&gt; } &lt;/div&gt; );} Stencil 提供的”@”语法糖装饰器可以提供单选数据流、数据变动 hook 等，结合 JSX。具体如下： @Component() declares a new web component @Prop() declares an exposed property/attribute @State() declares an internal state of the component @Watch() declares a hook that runs when a property or state changes @Element() declares a reference to the host element @Method() declares an exposed public method @Event() declares a DOM event the component might emit @Listen() listens for DOM events 12345678910// 定义 props name// 传入值有变化时，触发重新渲染@Prop() name: string;render() {return ( &lt;p&gt; My name is {this.name} &lt;/p&gt;);} Virtual DOM 提供了一种到真实 dom 的映射，从虚拟 dom 之间的 diff，并将 diff info patch 到 real dom，类似于 React 和 Vue，这样的虚拟 DOM 映射，会使追踪数据变动，重新渲染的流程更加高效。 Stencil 还提供了更加完善的生命周期。 内置完善的 单元测试 和 e2e 测试框架，在生成组件时，使用组件生成指令时，提供配套的 unit 和 e2e 模板文件。 提供 custom elements polyfill 给予低版本框架更多支持。 还有一些其他的特性，比如 Async rendering 类似于 fiber、组件懒加载等等，也是日常开发中比较实用的技能。 从以上的种种特性可以看出，Stencil 对比原生 Web Components 更方便，并且提供了完毕的语法糖和生命周期。 配套的基础架构工具， 可以无痛进行技术栈的转换。","link":"/2023/03/05/stencil/%E5%8E%9F%E7%90%86/WebComponent/"},{"title":"stencil安装及初始化","text":"stencil 开启项目 Stencil 安装用 lerna 初始化目录结构 123456├── lerna.json├── package.json└── packages│ ├── sten-components│ ├── sten-icons│ └── sten-themes 其中 icons 用于存放 icons 相关的组件信息，themes 存放主题样式 scss 相关，components主要存放组件的基本逻辑。在 sten-components 这个 package 下来安装初始化的 Stencil 框架。 安装Stencil 可以用 npm init 指令进行安装初始化，但是你的 npm 版本必须大于 6。 12// npm &gt;= 6npm init stencil packages 目录下初始化即可，stencil 会帮助创建文件夹。 12// 初始化 Stencilpnpm init stencil 然后 Stencil 会有一些交互性的指令，帮助初始化项目： 123? Pick a starter › - Use arrow-keys. Return to submit.❯ component Collection of web components that can be used anywhere app Minimal starter for building a Stencil app or website 选择第一个组件库类型，第二个是构建一个应用。 接下来就是输入名称，以 sten-components 命名这个 package。 12345678910111213141516✔ Pick a starter › component✔ Project name › sten-components✔ All setup in 22 ms $ npm start Starts the development server. $ npm run build Builds your components/app in production mode. $ npm test Starts the test runner. We suggest that you begin by typing: $ cd sten-components $ npm install $ npm start Further reading: - https://github.com/ionic-team/stencil-component-starter Happy coding! 🎈 此时，初始化安装完成，sten-components 文件夹已经被重新生成。内部目录结构如下： 1234567891011121314├── LICENSE├── package.json├── readme.md├── src│ ├── components│ │ └── my-component│ ├── components.d.ts│ ├── index.html│ ├── index.ts│ └── utils│ ├── utils.spec.ts│ └── utils.ts├── stencil.config.ts└── tsconfig.json 重新构建依赖安装完成后，需要重新构建一下依赖，但不是在当前文件夹执行，需要回到项目的根目录，或者直接使用lerna bootstrap来执行依赖的重新构建和分析。 执行完后会发现 pnpm 已经把需要的 npm 包进行连接，但是不会有二级依赖添加。 如果没有识别到 packages 文件夹内的 package.json 文件，则需要添加 pnpm-workspace.yaml 文件声明 pnpm 的 workspace： 1packages: -&quot;packages/**&quot; - &quot;!packages/__mocks__&quot; - docs - &quot;!**/__tests__/**&quot;; 接下来修改下默认的 package.json 里面的 name 属性，使其保持统一： 123{ &quot;name&quot;: &quot;@sten-design/components&quot;} 此时执行 lerna list 就可以看到当前 lerna 仓库中已经注册的 package 有哪些了。 12345678➜ sten-design git:(master) ✗ lerna listinfo cli using local version of lernalerna notice cli v4.0.0lerna info versioning independent@sten-design/components@sten-design/icons@sten-design/themeslerna success found 3 packages 启动Stencil 初始化和 Lerna bootstrap 执行完毕后，就可以根据指令来启动项目，但是在根目录下，启动子 package 的命令还需要反复进行目录的切换，比较繁琐，根据 lerna 提供的指令来在根目录 package.json 里面定义 script 来启动子目录的 script。具体设置如下： 123456// package.json&quot;scripts&quot;: { &quot;commit&quot;: &quot;git cz&quot;, &quot;release&quot;: &quot;standard-version&quot;, &quot;start:components&quot;: &quot;lerna run start --scope=@sten-design/components&quot;,}, 接下来启动 Stencil： 1pnpm start:components 启动完毕 可以看到，默认初始化的项目下会有一个测试的 components 为 “my-component” ，可以根据这个测试修改。 12345678910├── components│ └── my-component│ ├── my-component.css│ ├── my-component.e2e.ts│ ├── my-component.spec.ts│ ├── my-component.tsx│ └── readme.md├── components.d.ts├── index.html├── index.ts 定义一个变量 num，加一个按钮使每次点击都+1。 1234567891011{ ... @State() num: number = 0; private getText(): string { return format(this.first, this.middle, this.last); } render() { return &lt;div&gt;&lt;button onClick={() =&gt; this.num += 1}&gt;add&lt;/button&gt;Hello, World! I'm {this.getText()}, number is {this.num}&lt;/div&gt;; }} 然后在浏览器看下效果： 新增组件Stencil 提供了脚本 generate 可以用来快速新增组件，并可选择的初始化配套的 e2e 文件和 unit 文件。老规矩，为了更快执行，在根目录的 package.json 文件新增一个脚本，用于执行 generate 命令： 123456&quot;scripts&quot;: { &quot;commit&quot;: &quot;git cz&quot;, &quot;release&quot;: &quot;standard-version&quot;, &quot;start:components&quot;: &quot;lerna run start --scope=@sten-design/components&quot;, &quot;generate:components&quot;: &quot;lerna run generate --scope=@sten-design/components&quot; }, 然后执行 pnpm generate:components： 1234$ stencil generate[48:40.4] @stencil/core[48:40.7] v2.13.0 🍣? Component tag name (dash-case): › 注意：component 的文件名必须以 “-” 连接，比如 sten-tooltip、sten-tab 等。 12345678910✔ Component tag name (dash-case): … sten-button? Which additional files do you want to generate? ›Instructions: ↑/↓: Highlight option ←/→/[space]: Toggle selection a: Toggle all enter/return: Complete answer◉ Stylesheet (.css)◉ Spec Test (.spec.tsx)◉ E2E Test (.e2e.ts) 输入完毕组件名后，会有一个交互性指令说明是是否需要配套的文件，暂时都选是。 最后会发现一个新的组件文件夹会被添加： 123456$ stencil generate sten-buttonThe following files have been generated: - ./src/components/sten-button/sten-button.tsx - ./src/components/sten-button/sten-button.css - ./src/components/sten-button/test/sten-button.spec.tsx - ./src/components/sten-button/test/sten-button.e2e.ts 包含了 tsx 主要逻辑、css 文件、还有两个测试文件。随便在 tsx 文件中写点东西： 12345678910111213141516171819// sten-button.tsximport { Component, Host, h } from &quot;@stencil/core&quot;;@Component({ tag: &quot;sten-button&quot;, styleUrl: &quot;sten-button.css&quot;, shadow: true,})export class StenButton { render() { return ( &lt;Host&gt; &lt;button class=&quot;sten-button&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/button&gt; &lt;/Host&gt; ); }} 123456789101112// sten-button.css:host { display: block;}.sten-button { width: 100px; height: 40px; border-radius: 20px; background-color: #00bcd4; color: #fff; border: none;} 然后修改下 index.html 把刚新建的组件添加： 1234&lt;body&gt; &lt;my-component first=&quot;Stencil&quot; last=&quot;'Don't call me a framework' JS&quot;&gt;&lt;/my-component&gt; &lt;sten-button&gt;你好&lt;/sten-button&gt;&lt;/body&gt; 运行可以看到效果","link":"/2023/03/05/stencil/%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/1.%E5%AE%89%E8%A3%85%E5%8F%8A%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"title":"AST","text":"上一节课我们学习了怎么实现 SSR 的静态页面渲染，但是一个页面不可能只有静态的部分，那么 SSR 中我们应该怎么进行数据的请求和注入呢？我们先做下简单尝试，看能不能直接用平常我们开发的方式来请求。 hook 请求是否可行？我们先启一个路由，用来作为一个简单接口，因为 express 没办法直接读取请求的 body，所以我们需要用 body-parser 对请求进行一个解析： 1npm install body-parser --save 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// ./src/server/index.tsx// ./src/server/index.tsximport express from &quot;express&quot;;import childProcess from &quot;child_process&quot;;import { renderToString } from &quot;react-dom/server&quot;;import path from &quot;path&quot;;import router from &quot;@/router&quot;;import { Route, Routes } from &quot;react-router-dom&quot;;import { StaticRouter } from &quot;react-router-dom/server&quot;;import { Helmet } from &quot;react-helmet&quot;;const app = express();const bodyParser = require(&quot;body-parser&quot;);app.use(express.static(path.resolve(process.cwd(), &quot;client_build&quot;)));// 请求body解析app.use(bodyParser.json());app.use(bodyParser.urlencoded({ extended: true }));// 启一个post服务app.post(&quot;/api/getDemoData&quot;, (req, res) =&gt; { res.send({ data: req.body, status_code: 0, });});app.get(&quot;*&quot;, (req, res) =&gt; { const content = renderToString( &lt;StaticRouter location={req.path}&gt; &lt;Routes&gt; {router?.map((item, index) =&gt; { return &lt;Route {...item} key={index} /&gt;; })} &lt;/Routes&gt; &lt;/StaticRouter&gt; ); const helmet = Helmet.renderStatic(); res.send(` &lt;html &lt;head&gt; ${helmet.title.toString()} ${helmet.meta.toString()} &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;${content}&lt;/div&gt; &lt;script src=&quot;/index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; `);});app.listen(3000, () =&gt; { console.log(&quot;ssr-server listen on 3000&quot;);});childProcess.exec(&quot;start http://127.0.0.1:3000&quot;); 然后咱们在 Demo 页面中直接用 hook 来请求，这个过程需要装一下 axios 的依赖： 1npm install axios --save 123456789101112131415161718192021// ./src/pages/Demo/index.tsximport { FC, useState, useEffect } from &quot;react&quot;;import axios from &quot;axios&quot;;const Demo: FC = (data) =&gt; { const [content, setContent] = useState(&quot;&quot;); useEffect(() =&gt; { axios .post(&quot;/api/getDemoData&quot;, { content: &quot;这是一个demo页面&quot;, }) .then((res: any) =&gt; { setContent(res.data?.data?.content); }); }, []); return &lt;div&gt;{content}&lt;/div&gt;;};export default Demo; 然后我们刷新一下 Demo 页面看看： 数据请求成功了，不过，不对的是，我们可以在 network 中看到对应的请求，数据也没在服务器端请求的时候塞入 HTML，也就是说走的是客户端渲染，而不是服务端渲染，和我们预期的不一样，看来是不能直接用 hook 来常规请求的。 我们来回忆之前静态页面的思路，是在服务器端拼凑好 HTML并返回，所以请求的话，咱们应该也是获取到每个模板页面初始化的请求，并在服务器端请求好，进行 HTML 拼凑，在这之前我们需要建立一个全局的store，使得服务端请求的数据可以提供到模板页面来进行操作。确认好思路，咱们就根据这个思路先来解决试试。 全局 store 的建立store 的建立我们可以基于 redux 去做，redux 是一个可以对 state 进行统一管理的库。全局 store 的核心在于上一章节提到的“同构”，服务器端和客户端都需要建立 store，我们先装一下相关的依赖： 1npm install @reduxjs/toolkit redux-thunk react-redux --save 其中 @reduxjs/toolkit 是 redux 最新提供的工具包，可以用于状态的统一管理，提供了更多 hook的能力，相对代码更为简易，至于 redux-thunk 是一个 redux 的中间件，提供了 dispatch 和 getState与异步方法交互的能力。 然后我们在 Demo 页面下创建一个 store 目录，用来存放对应的 reducer，将之前客户端请求的逻辑加进去，并且设置一个默认值“默认数据”，如果请求成功的话，咱们就把传入参数返回一下。 12345678910111213141516171819202122232425262728293031323334353637// ./src/pages/Demo/store/demoReducer.tsimport { createSlice, createAsyncThunk } from &quot;@reduxjs/toolkit&quot;;import axios from &quot;axios&quot;;const getDemoData = createAsyncThunk( &quot;demo/getData&quot;, async (initData: string) =&gt; { const res = await axios.post(&quot;http://127.0.0.1:3000/api/getDemoData&quot;, { content: initData, }); return res.data?.data?.content; });const demoReducer = createSlice({ name: &quot;demo&quot;, initialState: { content: &quot;默认数据&quot;, }, // 同步reducer reducers: {}, // 异步reducer extraReducers(build) { build .addCase(getDemoData.pending, (state, action) =&gt; { state.content = &quot;pending&quot;; }) .addCase(getDemoData.fulfilled, (state, action) =&gt; { state.content = action.payload; }) .addCase(getDemoData.rejected, (state, action) =&gt; { state.content = &quot;rejected&quot;; }); },});export { demoReducer, getDemoData }; createSlice 这个函数我们着重讲一下，因为是 redux 比较新的版本，很多同学可能还是比较陌生的。 reducers：可以存放同步的 reducers（不需要请求参数）； initialState：可以理解成原来的 state； name： 是这个 reducer 的空间，后面取 store 的时候会根据这个进行区分； extraReducers：这个是我们这里需要的异步 reducer，其中包含三个状态，pending、fulfilled 和 rejected，分别对应到请求的三种状态。 这种函数式的写法可以即用即配，是个不错的改进版本。因为只是一个状态管理的方式，并不是我们这章的重点，更详细的参数和部分大家可以在 @reduxjs/toolkit 的官网学习了解。 我们还可以创建一个 index.ts 来作为统一导出，因为一个页面可能不只有一个 reducer，这样引用的时候就不用每一个都写一个 import 了，都从 index.ts 中统一导出就可以： 1234// ./src/pages/Demo/store/index.tsimport { demoReducer } from &quot;./demoReducer&quot;;export { demoReducer }; 然后我们分别创建一下客户端和服务器端的 store，将 reducer 导入一下，并且接入一下 thunk 的中间件，使得 dispatch 相关的函数支持异步函数的入参： 12345678910111213141516// ./src/store/index.tsimport { configureStore } from &quot;@reduxjs/toolkit&quot;;import thunk from &quot;redux-thunk&quot;;import { demoReducer } from &quot;@/pages/Demo/store&quot;;const clientStore = configureStore({ reducer: { demo: demoReducer.reducer }, middleware: (getDefaultMiddleware) =&gt; getDefaultMiddleware().concat(thunk),});const serverStore = configureStore({ reducer: { demo: demoReducer.reducer }, middleware: (getDefaultMiddleware) =&gt; getDefaultMiddleware().concat(thunk),});export { clientStore, serverStore }; 接下来我们将创建好的 store 分别在客户端和服务器端的路由处注入一下就可以： 1234567891011121314151617181920212223// ./src/client/index.tsximport { hydrateRoot } from &quot;react-dom/client&quot;;import { BrowserRouter, Route, Routes } from &quot;react-router-dom&quot;;import router from &quot;@/router&quot;;import { clientStore } from &quot;@/store&quot;;import { Provider } from &quot;react-redux&quot;;const Client = (): JSX.Element =&gt; { return ( &lt;Provider store={clientStore}&gt; &lt;BrowserRouter&gt; &lt;Routes&gt; {router?.map((item, index) =&gt; { return &lt;Route {...item} key={index} /&gt;; })} &lt;/Routes&gt; &lt;/BrowserRouter&gt; &lt;/Provider&gt; );};// 将事件处理加到ID为root的dom下hydrateRoot(document.getElementById(&quot;root&quot;) as Document | Element, &lt;Client /&gt;); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// ./src/server/index.tsximport express from &quot;express&quot;;import childProcess from &quot;child_process&quot;;import { renderToString } from &quot;react-dom/server&quot;;import path from &quot;path&quot;;import router from &quot;@/router&quot;;import { Route, Routes } from &quot;react-router-dom&quot;;import { StaticRouter } from &quot;react-router-dom/server&quot;;import { Helmet } from &quot;react-helmet&quot;;import { serverStore } from &quot;@/store&quot;;import { Provider } from &quot;react-redux&quot;;const app = express();const bodyParser = require(&quot;body-parser&quot;);app.use(express.static(path.resolve(process.cwd(), &quot;client_build&quot;)));// 请求body解析app.use(bodyParser.json());app.use(bodyParser.urlencoded({ extended: true }));// 启一个post服务app.post(&quot;/api/getDemoData&quot;, (req, res) =&gt; { res.send({ data: req.body, status_code: 0, });});app.get(&quot;*&quot;, (req, res) =&gt; { const content = renderToString( &lt;Provider store={serverStore}&gt; &lt;StaticRouter location={req.path}&gt; &lt;Routes&gt; {router?.map((item, index) =&gt; { return &lt;Route {...item} key={index} /&gt;; })} &lt;/Routes&gt; &lt;/StaticRouter&gt; &lt;/Provider&gt; ); const helmet = Helmet.renderStatic(); res.send(` &lt;html &lt;head&gt; ${helmet.title.toString()} ${helmet.meta.toString()} &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;${content}&lt;/div&gt; &lt;script src=&quot;/index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; `);});app.listen(3000, () =&gt; { console.log(&quot;ssr-server listen on 3000&quot;);});childProcess.exec(&quot;start http://127.0.0.1:3000&quot;); 到这里 store 就已经注入好了，我们只需要在 Demo 中与 store 连接就行。connect 暴露了两个参数，一个state，一个 dispatch，它会根据你的需要拼接成指定的参数，以装饰器的形式包装你定义的函数，这样我们的 Demo就可以接收到我们定义的 content 和 getDemoData 参数了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// ./src/pages/Demo/index.tsximport { FC, useState, useEffect, Fragment } from &quot;react&quot;;import axios from &quot;axios&quot;;import { connect } from &quot;react-redux&quot;;import { getDemoData } from &quot;./store/demoReducer&quot;;import { Helmet } from &quot;react-helmet&quot;;interface IProps { content?: string; getDemoData?: (data: string) =&gt; void;}const Demo: FC&lt;IProps&gt; = (data) =&gt; { // const [content, setContent] = useState(&quot;&quot;); // // 客户端异步请求 // useEffect(() =&gt; { // axios // .post(&quot;/api/getDemoData&quot;, { // content: &quot;这是一个demo&quot;, // }) // .then((res) =&gt; { // setContent(res.data?.data?.content); // }); // }, []); return ( &lt;Fragment&gt; &lt;Helmet&gt; &lt;title&gt;简易的服务器端渲染框架 - DEMO&lt;/title&gt; &lt;meta name=&quot;description&quot; content=&quot;服务器端渲染框架&quot;&gt;&lt;/meta&gt; &lt;/Helmet&gt; &lt;div&gt; &lt;h1&gt;{data.content}&lt;/h1&gt; &lt;button onClick={(): void =&gt; { data.getDemoData &amp;&amp; data.getDemoData(&quot;刷新过后的数据&quot;); }} &gt; 刷新 &lt;/button&gt; &lt;/div&gt; &lt;/Fragment&gt; );};const mapStateToProps = (state: any) =&gt; { // 将对应reducer的内容透传回dom return { content: state?.demo?.content, };};const mapDispatchToProps = (dispatch: any) =&gt; { return { getDemoData: (data: string) =&gt; { dispatch(getDemoData(data)); }, };};const storeDemo: any = connect(mapStateToProps, mapDispatchToProps)(Demo);export default storeDemo; 到这里我们的全局 store 就建立了，我们可以刷新一下页面试试。 可以看到展示的是默认数据，那是因为我们并没有进行初始化的请求，所以它走了默认的 state 兜底，然后我们点击刷新试试。 可以看到新增了对应的请求，对应展示的内容也切换为了刷新过后的数据，那这就意味着咱们 store 的部分已经走通了，接下来咱们只需要考虑，应该怎样在服务器端进行请求，使得在 html 拼接的时候就可以拿到初始化的数据呢？ 建立服务器端请求数据体系需要在服务器端进行初始化，我们先来捋捋思路，首先我们肯定得先在服务器端拿到所有需要请求的函数，怎么透传过去呢？我们应该可以使用路由，因为客户端和服务端咱们都有配置路由，如果加一个参数通过路由把参数透传，然后在服务器端遍历，最后把结果对应分发是不是就可以了。 思路捋好咱们就可以开始做了，不过这里有个小细节大家要注意一下，服务器端不同于客户端，它是拿不到请求的域名的，所以服务器端下的 axios 请求应该是包含域名的绝对路径，而不是使用相对路径，很多 SSR 的初学者在开发过程中很容易遇到类似问题 。 好了，进入正题，咱们先给 Demo 定义一个初始化的函数，两个入参，一个透传 store，另一个 data，对应页面展示的内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// ./src/pages/Demo/index.tsximport { FC, useState, useEffect, Fragment } from &quot;react&quot;;import axios from &quot;axios&quot;;import { connect } from &quot;react-redux&quot;;import { getDemoData } from &quot;./store/demoReducer&quot;;import { Helmet } from &quot;react-helmet&quot;;interface IProps { content?: string; getDemoData?: (data: string) =&gt; void;}const Demo: FC&lt;IProps&gt; = (data) =&gt; { // const [content, setContent] = useState(&quot;&quot;); // // 客户端异步请求 // useEffect(() =&gt; { // axios // .post(&quot;/api/getDemoData&quot;, { // content: &quot;这是一个demo&quot;, // }) // .then((res) =&gt; { // setContent(res.data?.data?.content); // }); // }, []); return ( &lt;Fragment&gt; &lt;Helmet&gt; &lt;title&gt;简易的服务器端渲染框架 - DEMO&lt;/title&gt; &lt;meta name=&quot;description&quot; content=&quot;服务器端渲染框架&quot;&gt;&lt;/meta&gt; &lt;/Helmet&gt; &lt;div&gt; &lt;h1&gt;{data.content}&lt;/h1&gt; &lt;button onClick={(): void =&gt; { data.getDemoData &amp;&amp; data.getDemoData(&quot;刷新过后的数据&quot;); }} &gt; 刷新 &lt;/button&gt; &lt;/div&gt; &lt;/Fragment&gt; );};const mapStateToProps = (state: any) =&gt; { // 将对应reducer的内容透传回dom return { content: state?.demo?.content, };};const mapDispatchToProps = (dispatch: any) =&gt; { return { getDemoData: (data: string) =&gt; { dispatch(getDemoData(data)); }, };};const storeDemo: any = connect(mapStateToProps, mapDispatchToProps)(Demo);storeDemo.getInitProps = (store: any, data?: string) =&gt; { return store.dispatch(getDemoData(data || &quot;这是初始化的demo&quot;));};export default storeDemo; 咱们先对路由进行一下改造，将初始化的方法给路由带上： 1234567891011121314151617181920212223// ./src/router/index.tsximport Home from &quot;@/pages/Home&quot;;import Demo from &quot;@/pages/Demo&quot;;interface IRouter { path: string; element: JSX.Element; loadData?: (store: any) =&gt; any;}const router: Array&lt;IRouter&gt; = [ { path: &quot;/&quot;, element: &lt;Home /&gt;, }, { path: &quot;/demo&quot;, element: &lt;Demo /&gt;, loadData: Demo.getInitProps, },];export default router; 接下来咱们就该在服务器端拉取对应的初始化方法，并统一请求注入它们了，这个过程很简单，我们只需要改造 get 方法就可以，遍历所有的初始化方法，然后统一请求塞进 store 里。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// ./src/server/index.tsximport express from &quot;express&quot;;import childProcess from &quot;child_process&quot;;import path from &quot;path&quot;;import { Route, Routes } from &quot;react-router-dom&quot;;import { renderToString } from &quot;react-dom/server&quot;;import { StaticRouter } from &quot;react-router-dom/server&quot;;import { matchRoutes, RouteObject } from &quot;react-router-dom&quot;;import router from &quot;@/router&quot;;import { serverStore } from &quot;@/store&quot;;import { Provider } from &quot;react-redux&quot;;import { Helmet } from &quot;react-helmet&quot;;const app = express();const bodyParser = require(&quot;body-parser&quot;);// 请求body解析app.use(bodyParser.json());app.use(bodyParser.urlencoded({ extended: true }));// 注入事件处理的脚本app.use(express.static(path.resolve(process.cwd(), &quot;client_build&quot;)));// demo apiapp.post(&quot;/api/getDemoData&quot;, (req, res) =&gt; { res.send({ data: req.body, status_code: 0, });});app.get(&quot;*&quot;, (req, res) =&gt; { const routeMap = new Map&lt;string, () =&gt; Promise&lt;any&gt;&gt;(); // path - loaddata 的map router.forEach((item) =&gt; { if (item.path &amp;&amp; item.loadData) { routeMap.set(item.path, item.loadData(serverStore)); } }); // 匹配当前路由的routes const matchedRoutes = matchRoutes(router as RouteObject[], req.path); const promises: Array&lt;() =&gt; Promise&lt;any&gt;&gt; = []; matchedRoutes?.forEach((item) =&gt; { if (routeMap.has(item.pathname)) { promises.push(routeMap.get(item.pathname) as () =&gt; Promise&lt;any&gt;); } }); Promise.all(promises).then((data) =&gt; { // 统一放到state里 // 编译需要渲染的JSX, 转成对应的HTML STRING const content = renderToString( &lt;Provider store={serverStore}&gt; &lt;StaticRouter location={req.path}&gt; &lt;Routes&gt; {router?.map((item, index) =&gt; { return &lt;Route {...item} key={index} /&gt;; })} &lt;/Routes&gt; &lt;/StaticRouter&gt; &lt;/Provider&gt; ); const helmet = Helmet.renderStatic(); res.send(` &lt;html &lt;head&gt; ${helmet.title.toString()} ${helmet.meta.toString()} &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;${content}&lt;/div&gt; &lt;script&gt; window.context = { state: ${JSON.stringify(serverStore.getState())} } &lt;/script&gt; &lt;script src=&quot;/index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; `); });});app.listen(3000, () =&gt; { console.log(&quot;ssr-server listen on 3000&quot;);});childProcess.exec(&quot;start http://127.0.0.1:3000&quot;); 到这里服务器端请求就走通了，我们重启项目访问一下 Demo 页面试试： 但是很奇怪的是，可以看到服务器端的返回其实是符合预期的，是“这是初始化的 demo”，但是页面展示的时候却是默认数据，这是为什么呢？ 其实很简单，因为客户端和服务器端的 store 是不同步的，服务器端请求完成填充 store 后，客户端的 JS 又执行了一遍 store，取了默认的值，所以导致数据不能同步。要解决这个问题，就需要使用脱水和注水的方式。 脱水和注水水在这里其实就是数据层，也就是 store，这里对客户端页面进行脱“水”，移除其数据层的部分，仅仅保留 dom的部分，然后在服务器端请求拿到 store以后，对数据进行注入，也就是注“水”，使得客户端的数据与服务端请求的数据保持一致，就可以解决掉不同步的问题了。 我们首先在服务器端，将“水”注入到客户端脚本中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// ./src/server/index.tsximport express from &quot;express&quot;;import childProcess from &quot;child_process&quot;;import path from &quot;path&quot;;import { Route, Routes } from &quot;react-router-dom&quot;;import { renderToString } from &quot;react-dom/server&quot;;import { StaticRouter } from &quot;react-router-dom/server&quot;;import { matchRoutes, RouteObject } from &quot;react-router-dom&quot;;import router from &quot;@/router&quot;;import { serverStore } from &quot;@/store&quot;;import { Provider } from &quot;react-redux&quot;;import { Helmet } from &quot;react-helmet&quot;;const app = express();const bodyParser = require(&quot;body-parser&quot;);// 请求body解析app.use(bodyParser.json());app.use(bodyParser.urlencoded({ extended: true }));// 注入事件处理的脚本app.use(express.static(path.resolve(process.cwd(), &quot;client_build&quot;)));// demo apiapp.post(&quot;/api/getDemoData&quot;, (req, res) =&gt; { res.send({ data: req.body, status_code: 0, });});app.get(&quot;*&quot;, (req, res) =&gt; { const routeMap = new Map&lt;string, () =&gt; Promise&lt;any&gt;&gt;(); // path - loaddata 的map router.forEach((item) =&gt; { if (item.path &amp;&amp; item.loadData) { routeMap.set(item.path, item.loadData(serverStore)); } }); // 匹配当前路由的routes const matchedRoutes = matchRoutes(router as RouteObject[], req.path); const promises: Array&lt;() =&gt; Promise&lt;any&gt;&gt; = []; matchedRoutes?.forEach((item) =&gt; { if (routeMap.has(item.pathname)) { promises.push(routeMap.get(item.pathname) as () =&gt; Promise&lt;any&gt;); } }); Promise.all(promises).then((data) =&gt; { // 统一放到state里 // 编译需要渲染的JSX, 转成对应的HTML STRING const content = renderToString( &lt;Provider store={serverStore}&gt; &lt;StaticRouter location={req.path}&gt; &lt;Routes&gt; {router?.map((item, index) =&gt; { return &lt;Route {...item} key={index} /&gt;; })} &lt;/Routes&gt; &lt;/StaticRouter&gt; &lt;/Provider&gt; ); const helmet = Helmet.renderStatic(); // 注水 res.send(` &lt;html &lt;head&gt; ${helmet.title.toString()} ${helmet.meta.toString()} &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;${content}&lt;/div&gt; &lt;script&gt; window.context = { state: ${JSON.stringify(serverStore.getState())} } &lt;/script&gt; &lt;script src=&quot;/index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; `); });});app.listen(3000, () =&gt; { console.log(&quot;ssr-server listen on 3000&quot;);});childProcess.exec(&quot;start http://127.0.0.1:3000&quot;); 接下来我们在客户端处，Demo 的初始值中注入服务器端的值，这里需要做一个判断，因为服务器端下访问的时候是没有 window 等 BOM 的，所以需要用 typeof 来判断。这也是 SSR 中常常遇到的问题，当有对 BOM 的调用时，需要进行判空，否则在服务器端执行的时候将会报错。 12345678910111213141516171819202122232425262728293031323334353637383940// ./src/pages/Demo/store/demoReducer.tsimport { createSlice, createAsyncThunk } from &quot;@reduxjs/toolkit&quot;;import axios from &quot;axios&quot;;const getDemoData = createAsyncThunk( &quot;demo/getData&quot;, async (initData: string) =&gt; { const res = await axios.post(&quot;http://127.0.0.1:3000/api/getDemoData&quot;, { content: initData, }); return res.data?.data?.content; });const demoReducer = createSlice({ name: &quot;demo&quot;, initialState: typeof window !== &quot;undefined&quot; ? (window as any)?.context?.state?.demo : { content: &quot;默认数据&quot;, }, // 同步reducer reducers: {}, // 异步reducer extraReducers(build) { build .addCase(getDemoData.pending, (state, action) =&gt; { state.content = &quot;pending&quot;; }) .addCase(getDemoData.fulfilled, (state, action) =&gt; { state.content = action.payload; }) .addCase(getDemoData.rejected, (state, action) =&gt; { state.content = &quot;rejected&quot;; }); },});export { demoReducer, getDemoData }; 然后我们再重新刷新一下页面看看效果，应该就可以了： 小结这一章节我们学习了 SSR 如何针对数据进行请求，在建立了一个全局的 store后，将对应的初始化方法透传给服务端进行统一请求，最后再进行数据脱水和注水的操作，使得客户端初始化能和服务器端保持相同的store，整个过程还是有很多细节的，到这里我们 SSR 的实现篇就结束了。 对一个成熟的 SSR 框架还会有更多的处理，类似 CSS、中间件以及注入函数的装饰器包装，不过这些和基础的原理并没有太大的关系，所以在小册中并不会涉及，感兴趣的同学可以下来了解，对整体的代码风格也是有帮助的。 设立实现篇的初衷，是希望大家可以清楚其中页面渲染到数据请求的过程中是怎么流转的，这样在后期开发中，面对路由跳转，或是请求等不同于客户端的地方时，能知道原理以及为什么产生这些区别，如果三节课学习下来有一点不太理解，大家也不用着急，可以沉下心来多看几遍，涉及的知识点的确不少，如果能完全理解这三节的原理，对大家后面实战的学习会有很大帮助。 从下一节课开始，我们将进入实战的学习，如何使用业内比较成熟的框架 Next.js 来开发一个官网项目？","link":"/2023/02/01/ssr/%E5%8E%9F%E7%90%86/3.%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81ssr%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AF%B7%E6%B1%82/"},{"title":"","text":"","link":"/2023/08/07/stencil/%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/2.%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"title":"effect runner","text":"effect 接收方法后可以通过 runner 执行，执行副作用 12345678910111213//reactivity/__test__/effect.spec.ts...it('should return renner when call effect', () =&gt; { let foo = 10 const runner = effect(() =&gt; { foo++ return 'foo' }) expect(foo).toBe(11) const r = runner() expect(foo).toBe(12) expect(r).toBe('foo')}) 实现 runner 1234567891011121314151617//reactivity/effect.ts...class ReactiveEffect { private _fn: any //私有变量 constructor(fn) { this._fn = fn } run() { activeEffect = this return this._fn() //新增返回fn的值 }}const effect = fn =&gt; { const _effect = new ReactiveEffect(fn) _effect.run() return _effect.run.bind(_effect) //新增修改this指针}","link":"/2023/08/05/vue/effect/runner/"},{"title":"stencil项目结构","text":"stencil 项目结构 初始项目结构概览Stencil 在 init 的时候，会初始化好文件项目目录，并提供一个 demo 组件供测试。 12345678910// /sten-design/packages/sten-components// 最外层结构├── dist├── loader├── package.json├── readme.md├── src├── stencil.config.ts├── tsconfig.json└── www 最外层的结构： dist、loader 文件夹是用来存放编译文件。 src 文件夹主要工程文件。 stencil.config.ts 也是比较重要的，它承载了 stencil 编译过程中的配置项。 tsconfig.json 是用来配置 ts 的一些 config。 www 文件夹是在开发过程中启动调试所用到的资源文件，也就是在启动本地 dev 环境后，经过 stencil 编译后的 js 文件和 src 中的 index.html 会被执行 copy 过程，移动到 www 文件夹中去，而启动的热服务器（live server）访问就会被映射到此文件夹，从而进行渲染和调试。 下面是一些核心的部分。 SRC - 主要逻辑存放文件夹src 是用来存放项目的主要代码逻辑的文件夹，初始结构： 12345678910111213141516171819// src├── components│ ├── my-component│ │ ├── my-component.css│ │ ├── my-component.e2e.ts│ │ ├── my-component.spec.ts│ │ ├── my-component.tsx│ │ └── readme.md│ └── sten-button│ ├── sten-button.css│ ├── sten-button.tsx│ └── test├── components.d.ts├── index.html├── index.ts└── utils ├── utils.spec.ts └── utils.ts 从上到下依次看： Components 文件夹很显然是用来存放每一个组件的内容。 PS：stencil 的编译还是会按照 components/.来匹配组件的路径，所以还是需要把组件放到 components 里面才可以让 stencil 的编译脚本识别，正确编译。 项目初始化自带的组件 my-component 和通过命令行添加的 sten-button 项目结构略微有差异，此处是因为 stencil 默认初始化的结构未更新同步所导致，所以还是以命令行生成的 stencil 组件结构为准。 components.d.ts 这是所有组件的命名空间，是由编译脚本自动生成，了解即可： 123456789101112131415161718192021222324252627282930export class MyComponent { /*** The first name*/ @Prop() first: string; /*** The middle name*/ @Prop() middle: string; /*** The last name*/ @Prop() last: string; @State() num: number = 0; private getText(): string { return format(this.first, this.middle, this.last); } render() { return &lt;div&gt;&lt;button onClick={() =&gt; this.num += 1}&gt;add&lt;/button&gt;Hello, World! I'm {this.getText()}, number is {this.num}&lt;/div&gt;; }}// 编译后的命名空间...export namespace Components { interface MyComponent { /*** The first name*/ &quot;first&quot;: string; /*** The last name*/ &quot;last&quot;: string; /*** The middle name*/ &quot;middle&quot;: string; } interface StenButton { }}... 以上可以看出，它会根据组件的 class 自动生成命名空间，并添加公共属性的定义，像 first、last、middle 这种继承属性就会以直接添加到命名空间，而像 num 和 getText 这种私有属性，就不会被定义到里面。 PS：此文件不建议直接更改，会被脚本编译自动覆盖 index.html 是用来启动本地 dev 环境时候的一个入口文件，在初始化过程中，它会默认添加需要的 js 产物的路径，如下： 12&lt;script type=&quot;module&quot; src=&quot;/build/sten-components.esm.js&quot;&gt;&lt;/script&gt;&lt;script nomodule src=&quot;/build/sten-components.js&quot;&gt;&lt;/script&gt; 在启动后，会被 copy 到 www 文件夹提供给服务器访问，而上面依赖的 js 文件也会被拷贝到相应的 build 同级文件夹。这样就相当于进行了 dist 文件的引入。可以使文件正确的注册到浏览器当前的运行环境中，可以在 html 直接以标签的形式引入，并正确渲染。如下： 1234&lt;body&gt; &lt;my-component first=&quot;Stencil&quot; last=&quot;'Don't call me a framework' JS&quot;&gt;&lt;/my-component&gt; &lt;sten-button&gt;你好&lt;/sten-button&gt; &lt;/body&gt; index.ts 作为一个命名空间的导出入口，其作用为编译脚本编译生成 type 文件提供入口，最后用来整合所有的 *.d.ts 文件。 utils 文件夹用来存放一些公共的函数和 class，也是构建组件库一个比较重要的地方。 www 本地调式资源文件夹启动本地测试命令 stencil build --dev --watch --serve 后，试着改动下组件的内容后会发现，www 文件夹内的资源文件也随之更新，然后浏览器相应界面的也会随之更新，整体的逻辑可以梳理为： 所以 www 文件夹承载的是调式过程中 一些资源文件的整合，看下结构可以看出：build文件夹里是编译的产物；host.config.json 会存放一些本地热更新服务器的配置，比如缓存的配置等；而 index.html 则是经过压缩的 src/index.html 文件。 12345678910├── build│ ├── index.esm.js│ ├── p-14bff9af.entry.js│ ├── p-250f505a.js│ ├── p-ddc47192.js│ ├── sten-button.entry.js│ ├── sten-components.esm.js│ └── sten-components.js├── host.config.json└── index.html stencil.config.ts 配置中心stencil.config.ts 文件几乎是整个 stencil 工具链的配置中心，可以在此个性化的配置所有想要的功能，比如： globalScript 全局脚本的路径，可以用来实现在初始化组件，进行挂载的时候进行一些逻辑的处理。 globalStyle 全局的样式路径。 plugins 插件集合，可以配置一些编译过程中的额外功能，比如 sass 插件可以用来适配 scss 文件的编译，postcss 可以用来压缩、增加一些兼容性的代码来适配各种浏览器等等，官方还提供了以下插件：@stencil/less@stencil/postcss@stencil/sass@stencil/stylus outputTargets 也是一个比较重要的配置项，可以根据配置 target 进行打包。 等等，还有其他一些配置项。 dist / loader 打包产物既然 Stencil 作为一个「编译工具」或者可以称为 「工具链」，编译产物 自然而然是最重要的部分，也是必须去了解的一个重点。接下来就执行一下 pnpm run build 命令来分析下它的编译产物： 12345678910111213141516171819// dist├── cjs├── collection├── components├── esm├── index.cjs.js├── index.js├── sten-components└── types// loader├── cdn.js├── index.cjs.js├── index.d.ts├── index.es2017.js├── index.js└── package.json 通过观察 stencil 默认生成的 package.json 文件中 files 自动的配置： 1234&quot;files&quot;: [ &quot;dist/&quot;, &quot;loader/&quot; ], 可以看出 stencil 经过编译后，最终输出的文件资源就是 dist 和 loader，先看下 loader 文件夹 package.json 的内容和其他文件的内容 loader1234567891011121314151617{ &quot;name&quot;: &quot;sten-components-loader&quot;, &quot;typings&quot;: &quot;./index.d.ts&quot;, &quot;module&quot;: &quot;./index.js&quot;, &quot;main&quot;: &quot;./index.cjs.js&quot;, &quot;jsnext:main&quot;: &quot;./index.es2017.js&quot;, &quot;es2015&quot;: &quot;./index.es2017.js&quot;, &quot;es2017&quot;: &quot;./index.es2017.js&quot;, &quot;unpkg&quot;: &quot;./cdn.js&quot;}// index.es2017.jsexport * from '../dist/esm/polyfills/index.js';export * from '../dist/esm/loader.js';// index.cjs.jsmodule.exports = require('../dist/cjs/loader.cjs.js');module.exports.applyPolyfills = function() { return Promise.resolve() }; loader 文件夹其实相当于一个中转站，作用是根据当前的使用环境，分别引入 dist 的不同的文件夹产物内，比如 cjs 的引入类型会加载 ../dist/cjs/loader.cjs.js ；es6+ 的引入会加载 polyfills 文件和 esm 模式的资源文件../dist/esm/loader.js 。这样可以在任何情况下都能动态加载一些补丁文件和组件的编译产物。 distdist 文件可以说是组件库最终的“归宿”。它是可以根据配置变动，在默认的 stencil.config.ts 配置下，打包结果为： 12345678├── cjs├── collection├── components├── esm├── index.cjs.js├── index.js├── sten-components└── types 其中 cjs 和 esm 的逻辑几乎相同，esm 只是多了一些兼容性的代码，它们都是为了适配不同的环境所构造的不同产物，具体的逻辑可以梳理为： types 是所有类型的导出集合。 因为 stencil 初始化配置里面默认包含了 dist-custom-elements，意思就是可以单独打包出符合 web components 规范的组件 class， 所以打包的文件夹里会有 components 文件夹，里面包含了自定义组件的所有 class，可以以下面这种形式进行单独的引用： 12import { HelloWorld } from &quot;my-library/dist/components/hello-world&quot;;customElements.define(&quot;hello-world&quot;, HelloWorld); Sten-components 文件夹的内容可以看到与 www/build 文件内容相同，因为 stencil 也默认开启了 www 编译的 outTarget，所以也会编译出一份可以直接用于部署的文件 bundle。","link":"/2023/03/05/stencil/%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/4.%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/"},{"title":"装饰器","text":"stencil 装饰器使用 demo： 123456789101112131415161718export class MyComponent { @Prop() first: string; @Prop() middle: string; @Prop() last: string; @State() num: number = 0; private getText(): string { return format(this.first, this.middle, this.last); } render() { return ( &lt;div&gt; &lt;button onClick={() =&gt; (this.num += 1)}&gt;add&lt;/button&gt;Hello, World! I'm{&quot; &quot;} {this.getText()}, number is {this.num} &lt;/div&gt; ); }} @Prop()、@State()是 Stencil 组件 class 类中特有的一种装饰器 Decorators： Stencil 的各种装饰器就是为了收集当前组件的一些特性和数据，是一个纯编译时的特性，也就是说在收集到各个特性后，会经过编译逻辑处理对应的元数据，但最终输出是没有这些特性的。 所以可以这么理解：装饰器就是一个特殊的代理，链接着自定义书写的元数据和 Stencil 的编译逻辑，也可以理解它为一个语法糖。 装饰器的种类和作用Stencil 提供的装饰器种类有 8 种： @Component() @Component() 是用来定义 Stencil 组件的装饰器，每个 Stencil 组件必须声明这个装饰器，一般存在于组件 class 上方，示例为： 12345@Component({ tag: 'my-component', styleUrl: 'my-component.css', shadow: true,}) @Component() 一般会带有 options 来声明一些组件的特性和配置。必填的是 tag 字段，必须是一个由‘-’连接的字符串，用于声明当前组件应该匹配到那个 tag 标签下。其他字段可选，比较常见的有： shadow 当前组件是否启用 shadow-dom。 styleUrl 当前组件引用的 css 文件路径。 … 其他字段查阅 Stencil 装饰器官方文档。 可以看出 @Component 装饰器是用来声明当前 class 是一个 Stencil 组件的关键装饰器，只有声明后，编译脚本才会正确识别编译，是一个必需的装饰器。 @Prop() @Prop() 是用来定义声明当前 Stencil 组件 element 元素上的属性和继承数据。它可以自动解析出这些数据，并声明成当前组件 class 的一个变量，允许开发使用，其实类似于 Vue 和 React。它的作用就是用来获取继承的数据并加以使用。比如 demo ： 1234567891011121314151617export class MyComponent { @Prop() first: string; @Prop() middle: string; @Prop() last: string; private getText(): string { return format(this.first, this.middle, this.last); } render() { return &lt;div&gt;World! I'm {this.getText()}&lt;/div&gt;; }}// index.html&lt;my-component first=&quot;Stencil&quot; last=&quot;'Don't call me a framework' JS&quot;&gt;&lt;/my-component&gt;; 如上：在组件里面声明了三个属性 first、middle、last，在组件初始化的过程中，会把 &lt;my-componen``&gt; 标签的三个 attr 数据与组件 @Prop() 声明的变量进行一一对应，所以在 class 里面就可以通过 this 访问到这三个变量。通过 render 函数，就可以在页面上渲染出完整的 div。 并且，@Prop() 支持的类型包含布尔、字符串、number，甚至是对象和数组。并且可以通过 @Prop() aString = 'defaultValue' 这种形式来定义默认值，或者通过 @Prop() thingToDo!: string 这种形式来声明属性是必需的。 @Prop() 也可以携带配置来进行对相关 props 的预处理。例如： 123456789// 把 tag 里面的 complete 映射到组件里的 isComplete@prop ( { attribute: &quot;complete&quot;;})iscomplete: boolean;// 声明当前 props 不可变更@prop ({ mutable: true }) thingToDo: string;// reflect 可以决定当前的属性是不是在 tag 上可访问@prop ({ reflect: true }) timesCompletedInPast: number = 2; 可以看出 @Prop() 是数据传输的关键，也是组件传参的最核心的部分。 @State() @State() 是用来管理组件的内部数据，在 Stencil 组件 class 里，它类似 private的特性，所以在组件外部是无法进行更改和访问的，但是在组内部是可以的。而且它还关系到了组件的状态渲染，只要@State()声明的属性有值的变更，就会触发组件的 render 函数最终导致重新渲染。 1234567@State() num: number = 0;....render() { return &lt;div&gt;&lt;button onClick={() =&gt; this.num += 1}&gt;add&lt;/button&gt;Hello, World! I'm {this.getText()}, number is {this.num}&lt;/div&gt;; } 如上示例。在声明 num 为一个 State 的时候，在触发 button，导致 num 的值+1，因为 num 的 state 进行了变更，即 oldValue !== newValue 的时候。render 函数就会重新进行渲染。 PS：如果定义变量不为重新触发渲染，可以在组件 class 里面直接定义： 1234class Component { cacheData = SOME_BIG_DATA; // 这样数据变更不会触发渲染 @State() value; // 这样会触发} 注意：如果要把一个数组 Array 定义为一个 State。一些 push 和 pop 等方法是无法触发 Stencil 组件的 render 函数的，需要返回一个新的数组，使用 ES6 的结构写法： 12345678@State() items: string[]; // our original arraythis.items = ['ionic', 'stencil', 'webcomponents']; // update the arraythis.items = [ ...this.items, 'awesomeness'] Object 也类似，需要使用结构返回一个新的 object。 @Watch() @Watch() 的使用也是比较直观，用于监控 prop/state 的更新，从而执行一些副作用。类似于 Vue 的 watch。它的用法是直接把要监听的字段以 string 的格式传进来： 1234567891011121314export class LoadingIndicator { @Prop() activated: boolean; @State() busy: boolean; @Watch(&quot;activated&quot;) watchPropHandler(newValue: boolean, oldValue: boolean) { console.log(&quot;The new value of activated is: &quot;, newValue); } @Watch(&quot;busy&quot;) watchStateHandler(newValue: boolean, oldValue: boolean) { console.log(&quot;The new value of busy is: &quot;, newValue); }} 所以说，@Watch 也是一个很常用的装饰器，在监控 props 传值的变化去做一些不影响主要流程的副作用，可以分离核心逻辑与副作用。 @Element() @Element() 其实是为了提供在组件内访问当前 host element 示例的能力。当组件内部定义了 @Element() el: HTMLElement 的时候，在组件初始化过程中会把当前的 HTMLElement 实例 return 到 el 这个变量上，可以访问当前的 element，比如获取属性，外包围的信息等。 12345678910...export class TodoList { @Element() el: HTMLElement; getListHeight(): number { return this.el.getBoundingClientRect().height; }} @Element() 也是一个必要的装饰器，在构建组件库的时候，避免不了会根据当前组件的一些位置信息和尺寸信息进行一些逻辑的计算。比如根据当前元素的大小确定要弹出的 tooltip 的中间位置，等等。 可以说它是连接了组件内部和具体挂载 ELement 的一个桥梁。 @Method() @Method() 的作用是声明当前的 function 可以在组件的外部访问到，类似于 class 的 public 属性。它的用法是直接装饰在 function 的上面，如下： 1234@Method() async showPrompt() { // show a prompt } 这样，从组件外部就可以访问当前 tag 的暴露的方法： 12345(async () =&gt; { await customElements.whenDefined('todo-list'); const todoListElement = document.querySelector('todo-list'); await todoListElement.showPrompt();})(); 尽量使用 props 来控制一些组件的内部逻辑。 在 Stencil 的文档里关于 methods 有这样一段话： Public methods must be async 反正官方告知公共的方法必须是保持异步的，这样会发挥框架最大的性能: @ Event() @Event() 装饰器的作用是用来声明 DOM event，并提供了 emit 的方法来触发。使用方法如下： 1234567...export class TodoList { @Event() todoCompleted: EventEmitter&lt;Todo&gt;; todoCompletedHandler(todo: Todo) { this.todoCompleted.emit(todo); }} 在 Stencil 的组件中声明了一个 Event todoCompleted，并声明了它是一个 EventEmitter类型，携带的参数类型为 Todo，在组件中，需要触发这个 DOM 事件的时候，只需调用 todoCompleted 的 emit api 并填入携带参数即可。而在组件外层就可以使用如下的形式进行 DOM 事件的捕获： 1234567// jsx&lt;todo-list onTodoCompleted={(ev) =&gt; this.someMethod(ev)} /&gt;;// jsElement.addEventListener(&quot;todoCompleted&quot;, (event) =&gt; { console.log(event.detail.value);}); Event() 还有几个可选的 options 如下： 123456@Event({ eventName: 'todoCompleted', // 事件名称 composed: true, // 冒泡事件是否逃逸出当前的 shadowdom cancelable: true, // 事件是否可以被取消 bubbles: true, // 事件是否冒泡到父级 }) todoCompleted: EventEmitter&lt;Todo&gt;; @Event() 可以说你连接了 DOM 事件，可以在组件中快速的声明，使用 DOM 事件的特性，最终还是编译回到原生的 DOM 事件。 Listen() 有了 @Event() 肯定还会有 @Listen() ，Listen 的作用就是监听子组件冒泡上传的 DOM 事件，和一些公共的事件，比如 scroll、keydown、mousemove 等。可以说用处也是非常广泛，也比较高效。具体用法如下： 123456789...export class TodoApp { @Listen('todoCompleted') todoCompletedHandler(event: CustomEvent&lt;Todo&gt;) { console.log('Received the custom todoCompleted event: ', event.detail); }} 例如上面举例 @Event() 时的例子，在上面 event 开启冒泡后，可以在父组件里面 @Listen('todoCompleted') 装饰到一个回调函数上，当子组件触发 emit ，父组件就能收到冒泡过来的 DOM 事件，从而执行一些逻辑操作。 或者在 input 组件的时候，监听用户是否按下了回车，也可以监听一个键盘事件： 1234@listen ('keydown')handleKeyDown(ev: KeyboardEvent) { // xxx} Listen() 装饰器也可以监控除了本身之外的 dom 节点的事件，这需要传入 options 的 target 的取值： 12345678910export interface ListenOptions { target?: 'body' | 'document' | 'window'; capture?: boolean; passive?: boolean;} @Listen('scroll', { target: 'window' }) handleScroll(ev) { console.log('the body was scrolled', ev); }","link":"/2023/03/05/stencil/%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/3.%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"title":"effect scheduler","text":"实现调度器效果 1234567891011121314151617181920212223242526272829//reactivity/__test__/effect.spec.ts...it('scheduler', () =&gt; { /** * 1. 通过effect 的第二个参数给定一个 scheduler的fn * 2. effect 第一次执行的时候 还会执行 fn * 3. 当 响应式对象 修改更新 的时候不会执行 fn 而是执行 scheduler * 4. 如果说当执行 runner 的时候，会再次执行 fn */ let dummy let run: any const scheduler = jest.fn(() =&gt; { run = runner }) const obj = reactive({ foo: 1 }) const runner = effect( () =&gt; { dummy = obj.foo }, { scheduler } ) expect(scheduler).not.toHaveBeenCalled() expect(dummy).toBe(1) obj.foo++ expect(scheduler).toHaveBeenCalledTimes(1) expect(dummy).toBe(1) run() expect(dummy).toBe(2)}) 123456789101112131415161718192021222324252627282930313233//reactivity/effect.ts...class ReactiveEffect { private _fn: any //私有变量 public scheduler: Function | undefined constructor(fn, scheduler?: Function) { //新增 this._fn = fn } run() { activeEffect = this this._fn() }}export const trigger = (target, key) =&gt; { let depsMap = targetMap.get(target) let dep = depsMap.get(key) for (const effect of dep) { //新增判断scheduler if (effect.scheduler) { effect.scheduler() } else { effect.run() } }}export const effect = (fn, options: any = {}) =&gt; { const { scheduler } = options const _effect = new ReactiveEffect(fn, scheduler) //新增 _effect.run() const runner = _effect.run.bind(_effect) return runner}","link":"/2023/08/05/vue/effect/scheduler/"},{"title":"effect 流程","text":"effect 流程图总览 effect 主要部分就是里面的 ReactiveEffect 类类里面会有副作用的控制，以及副作用执行前后的环境处理 effect 主要方法也就是 track（依赖收集）和 trigger（依赖触发）依赖会以 weakmap 及 set 数据结构进行保存，图里流程比较详细","link":"/2023/08/05/vue/effect/process/"},{"title":"effect stop","text":"effect stop 方法 123456789101112131415161718192021222324252627282930313233//reactivity/__test__/effect.spec.ts...import { stop } from '../effect'it('stop', () =&gt; { let dummy const obj = reactive({ prop: 1 }) const runner = effect(() =&gt; { dummy = obj.prop }) obj.prop = 2 expect(dummy).toBe(2) //调用stop函数后停止更新 stop(runner) obj.props = 3 expect(dummy).toBe(2) //调用runner后更新 runner() expect(dummy).toBe(3)})it('onStop', () =&gt; { const obj = reactive({ foo: 1 }) const onStop = jest.fn() let dummy const runner = effect( () =&gt; { dummy = obj.foo }, { onStop } ) //执行stop后触发一个onStop回调，允许用户进行一些操作 stop(runner) expect(onStop).toBeCalledTimes(1)}) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//reactivity/__test__/effect.ts...import { extend } from '../shared'class ReactiveEffect { private _fn: any //私有变量 deps = [] //新增 active = true //新增 onStop?: () =&gt; void //新增 public scheduler: Function | undefined constructor(fn, scheduler?: Function) { this._fn = fn } run() { activeEffect = this this._fn() } stop() { //新增 if (this.active) { cleanupEffect(this) //onStop有值的时候调用这个回调函数 this.onStop?.() this.active = false } }}//新增const cleanupEffect = effect =&gt; { effect.deps.forEach((dep: any) =&gt; { dep.delete(effect) })}export const effect = (fn, options: any = {}) =&gt; { const _effect = new ReactiveEffect(fn, options.scheduler) //新增 _effect.run() extend(_effect, options) //新增 const runner = _effect.run.bind(_effect) runner.effect = _effect //新增 return runner}//依赖收集const targetMap = new Map()export const track = (target, key) =&gt; { //taget -&gt; key -&gt; dep let depsMap = targetMap.get(target) //初始化 if (!depsMap) { depsMap = new Map() targetMap.set(target, depsMap) } let dep = depsMap.get(key) if (!dep) { dep = new Set() depsMap.set(key, dep) } dep.add(activeEffect) if (!activeEffect) return //新增 activeEffect.deps.push(dep) //新增}//新增export const stop = runner =&gt; { runner.effect.stop()}","link":"/2023/08/05/vue/effect/stop/"},{"title":"","text":"","link":"/2023/08/07/stencil/%E5%AE%9E%E6%88%98/%E5%AE%9E%E6%88%98image%E7%BB%84%E4%BB%B6/"},{"title":"reactive computed","text":"reactive 响应系统 reactive computed 1234567891011121314151617181920212223242526272829303132//reactivity/__test__/computed.spesimport { computed } from '../computed'import { reactive } from '../reactive'describe('computed', () =&gt; { it('happy path', () =&gt; { const user = reactive({ age: 1 }) const age = computed(() =&gt; user.age) expect(age.value).toBe(1) }) it('should compute lazily', () =&gt; { const value = reactive({ foo: 1 }) const getter = jest.fn(() =&gt; value.foo) const cValue = computed(getter) /**不调用计算属性的时候不会执行 */ expect(getter).not.toHaveBeenCalled() /**调用计算属性执行一次 */ expect(cValue.value).toBe(1) expect(getter).toHaveBeenCalledTimes(1) /**再次读取计算属性值执行一次 */ cValue.value expect(getter).toHaveBeenCalledTimes(1) value.foo = 2 expect(getter).toHaveBeenCalledTimes(1) expect(cValue.value).toBe(2) expect(getter).toHaveBeenCalledTimes(2) cValue.value expect(getter).toHaveBeenCalledTimes(2) })}) 1234567891011121314151617181920212223242526272829303132333435//reactivity/computedimport { ReactiveEffect } from './effect'class ComputedRefImpl { private _getter: any private _dirty: boolean = true private _value: any private _effect: any constructor(getter) { this._getter = getter this._effect = new ReactiveEffect( getter, /* 响应式对象更新 * _dirty私有变量标记转true 表示需要重新获取新的计算结果 */ () =&gt; { if (!this._dirty) this._dirty = true } ) } get value() { /**缓存操作 * 通过_dirty私有变量标记判断是否被调用过 * 调用过 直接返回缓存的上次调用结果 * 没调用过 _dirty转false 保留调用结果 */ if (this._dirty) { this._dirty = false this._value = this._effect.run() } return this._value }}export const computed = getter =&gt; { return new ComputedRefImpl(getter)}","link":"/2023/08/05/vue/reactive/computed/"},{"title":"reactive isProxy","text":"reactive 判断对象是否为响应式 1234567891011//reactivity/__test__/reactive.spec.ts...import { isProxy, reactive, readonly } from '../reactive'it('isProxy', () =&gt; { const user = { age: 18, name: 'joy' } const reactiveObj = reactive(user) const readonlyObj = readonly(user) expect(isProxy(reactiveObj)).toBe(true) expect(isProxy(readonlyObj)).toBe(true) expect(isProxy(user)).toBe(false)}) reactive 实现 123//reactivity/reactive.ts...export const isProxy = raw =&gt; isReactive(raw) || isReadonly(raw)","link":"/2023/08/05/vue/reactive/isProxy/"},{"title":"reactive流程","text":"reactive 流程总览 reactive 的核心自然是通过 proxy 对目标对象进行拦截了会根据传入的标志不同，执行对应的操作，像只读，浅层响应等 数据结构依然采用了 weakmap","link":"/2023/08/05/vue/reactive/process/"},{"title":"reactive isReactive&amp;isReadonly","text":"reactive isReactive&amp;isReadonly isReactive 判断对象是否为 reactive（响应式） 123456789//reactivity/__test__/reactive.spec.ts...import { isReactive } from '../reactive'it('isReactive', () =&gt; { const user = { age: 10, name: 'joy' } const observed = reactive(user) expect(isReactive(observed)).toBe(true) expect(isReactive(user)).toBe(false)}) 12345678910111213141516171819//reactivity/baseHandler.ts...import { ReactiveFlags } from './reactive'export const createGetter = (isReadonly = false) =&gt; { return function get(target, key) { if (key === ReactiveFlags.IS_REACTIVE) { return !isReadonly } const res = Reflect.get(target, key) /**嵌套转换 */ if (isObject(res)) { return isReadonly ? readonly(res) : reactive(res) } if (!isReadonly) { track(target, key) } return res }} isReadonly 判断对象是否为只读属性 123456789//reactivity/__test__/readonly.spec.ts...import { isReadonly } from '../reactive'it('isReadonly', () =&gt; { const user = { age: 10, name: 'joy' } const observed = reactive(user) expect(isReadonly(observed)).toBe(true) expect(isReadonly(user)).toBe(false)}) 123456789101112131415161718192021//reactivity/baseHandler.ts...import { ReactiveFlags } from './reactive'export const createGetter = (isReadonly = false) =&gt; { return function get(target, key) { if (key === ReactiveFlags.IS_REACTIVE) { return !isReadonly } else if (key === ReactiveFlags.IS_READONLY) { return isReadonly } const res = Reflect.get(target, key) /**嵌套转换 */ if (isObject(res)) { return isReadonly ? readonly(res) : reactive(res) } if (!isReadonly) { track(target, key) } return res }}","link":"/2023/08/05/vue/reactive/isReactive&isReadonly/"},{"title":"reactive readonly","text":"reactive 只读功能 1234567891011//reactivity/__test__/readonly.spec.ts...import { readonly } from '../reactive'describe('readonly', () =&gt; { it('happy path', () =&gt; { const original = { foo: 1, bar: { baz: 2 } } const wrapped = readonly(original) expect(wrapped).not.toBe(original) expect(wrapped.foo).toBe(1) })}) reactive 实现 123456789101112131415//reactivity/reactive.ts...import { isObject } from '../shared/index'import { mutableHandler, readonlyHandler } from './baseHandlers'/**响应式对象实现 */export const createReactiveObject = (raw, baseHandlers) =&gt; { if (!isObject(raw)) { console.warn(`target ${raw} 必须是一个对象`) return raw } return new Proxy(raw, baseHandlers)}export const reactive = raw =&gt; createReactiveObject(raw, mutableHandler)export const readonly = raw =&gt; createReactiveObject(raw, readonlyHandler) 123456789101112131415161718192021222324252627282930313233343536373839//reactivity/baseHandler.ts...import { track, trigger } from './effect'import { isObject, extend } from '../shared/index'import { reactive, readonly } from './reactive'//创建getexport const createGetter = (isReadonly = false) =&gt; { return function get(target, key) { const res = Reflect.get(target, key) /**嵌套转换 */ if (isObject(res)) { return isReadonly ? readonly(res) : reactive(res) } if (!isReadonly) { track(target, key) } return res }}//创建setexport const createSetter = () =&gt; { return function set(target, key, value) { const res = Reflect.set(target, key, value) trigger(target, key) return res }}//缓存get跟set，始终使用同一个const get = createGetter()const set = createSetter()const readonlyGet = createGetter(true)export const readonlyHandler = { get: readonlyGet, set(target, key) { console.warn(`${key} set失败，因为target是readonly`, target) return true }}","link":"/2023/08/05/vue/reactive/readonly/"},{"title":"reactive shallowReadonly","text":"reactive 表层只读 1234567891011121314151617//reactivity/__test__/shallowReadonly.spec.tsimport { isReadonly, shallowReadonly } from '../reactive'describe('shallowReadonly', () =&gt; { test('should not make non-reactive properties reactive', () =&gt; { const props = shallowReadonly({ n: { foo: 1 } }) expect(isReadonly(props)).toBe(true) expect(isReadonly(props.n)).toBe(false) }) it('warn then call set', () =&gt; { console.warn = jest.fn() const user = shallowReadonly({ age: 10 }) user.age = 11 expect(console.warn).toBeCalled() })}) reactive 实现 1234567891011121314151617//reactivity/baseHandler.tsexport const createGetter = (isReadonly = false, shallow = false) =&gt; { return function get(target, key) { if (key === ReactiveFlags.IS_REACTIVE) return !isReadonly else if (key === ReactiveFlags.IS_READONLY) return isReadonly const res = Reflect.get(target, key) if (shallow) return res /**判断res是否是复杂数据类型 */ if (isObject(res)) return isReadonly ? readonly(res) : reactive(res) if (!isReadonly) track(target, key) return res }}const shallowReadonlyGet = createGetter(true, true)export const shallowReadonlyHandlers = extend({}, readonlyHandler, { get: shallowReadonlyGet})","link":"/2023/08/05/vue/reactive/shallowReadonly/"},{"title":"数组节点更新","text":"双端对比，动态规划算法 1. 从头比对Vue 3 的 diff 算法第一步就是进行新老节点从头比对的方式来判断是否是同类型的节点： 123456789101112131415161718192021222324const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; { let i = 0 const l2 = c2.length // 旧节点的尾部标记位 let e1 = c1.length - 1 // 新节点的尾部标记位 let e2 = l2 - 1 // 从头部开始比对 // (a b) c // (a b) d e while (i &lt;= e1 &amp;&amp; i &lt;= e2) { const n1 = c1[i] const n2 = (c2[i] = optimized ? cloneIfMounted(c2[i] as VNode) : normalizeVNode(c2[i])) // 如果是 sameVnode 则递归执行 patch if (isSameVNodeType(n1, n2)) { patch(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) } else { break } i++ }} 变量解释： i 代表的是头部的标记位； e1 代表的是旧的子节点的尾部标记位； e2 代表的是新的子节点的尾部标记位。 从头比对就是通过不断移动 i 这个头部标记位来判断对应的节点是否是 sameVnode。如果是，则进行递归 patch 操作。如果不满足条件，则退出头部比对，进入从尾比对流程。 2. 从尾比对123456789101112131415161718192021222324252627const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; { let i = 0 const l2 = c2.length // 旧节点的尾部标记位 let e1 = c1.length - 1 // 新节点的尾部标记位 let e2 = l2 - 1 // 从头部开始比对 // ... // 从尾部开始比对 // a (b c) // d e (b c) while (i &lt;= e1 &amp;&amp; i &lt;= e2) { const n1 = c1[e1] const n2 = (c2[i] = optimized ? cloneIfMounted(c2[i] as VNode) : normalizeVNode(c2[i])) // 如果是 sameVnode 则递归执行 patch if (isSameVNodeType(n1, n2)) { patch(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) } else { break } e1-- e2-- }} 从尾比对就是通过不断移动新旧节点 e1 和 e2 的尾部指针来判断对应的节点是否是 sameVnode。如果是则进行递归 patch 操作。如果不满足条件，则退出头部比对，进入后续流程。 3. 新增节点123456&lt;ul&gt; &lt;li key=&quot;a&quot;&gt;a&lt;/li&gt; &lt;li key=&quot;b&quot;&gt;b&lt;/li&gt; &lt;li key=&quot;c&quot;&gt;c&lt;/li&gt; &lt;li key=&quot;d&quot;&gt;d&lt;/li&gt;&lt;/ul&gt; 新列表的变更是在中间插入了一个新节点： 12345678&lt;ul&gt; &lt;li key=&quot;a&quot;&gt;a&lt;/li&gt; &lt;li key=&quot;b&quot;&gt;b&lt;/li&gt; // ++ &lt;li key=&quot;b&quot;&gt;e&lt;/li&gt; &lt;li key=&quot;c&quot;&gt;c&lt;/li&gt; &lt;li key=&quot;d&quot;&gt;d&lt;/li&gt;&lt;/ul&gt; 那么先进入第一步头部比对流程： 第一步执行时，会完成对 a 和 b 头部这 2 个节点进行 patch。当 i = 2 时，由于此时的 c 和 e 节点的 key 不一样，所以退出了头部比对流程，进入尾部比对： 第二步执行时，会完成对 c 和 d 尾部这 2 个节点进行 patch。当 e1 = 1 时，由于i &gt; e1，所以退出了尾部比对流程。此时的情况是新节点多了个 e 节点的情况，所以需要添加多余的剩余节点： 1234567891011121314151617181920212223242526272829303132333435363738394041const patchKeyedChildren = ( c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; { let i = 0; const l2 = c2.length; // 旧节点的尾部标记位 let e1 = c1.length - 1; // 新节点的尾部标记位 let e2 = l2 - 1; // 从头部开始必须 // ... // 从尾部开始比对 // ... // 如果有多余的新节点，则执行新增逻辑 if (i &gt; e1) { if (i &lt;= e2) { const nextPos = e2 + 1; const anchor = nextPos &lt; l2 ? c2[nextPos].el : parentAnchor; while (i &lt;= e2) { // 新增新节点 patch( null, c2[i], container, anchor, parentComponent, parentSuspense, isSVG ); i++; } } }}; 4. 删除节点12345678&lt;ul&gt; &lt;li key=&quot;a&quot;&gt;a&lt;/li&gt; &lt;li key=&quot;b&quot;&gt;b&lt;/li&gt; // -- &lt;li key=&quot;b&quot;&gt;e&lt;/li&gt; &lt;li key=&quot;c&quot;&gt;c&lt;/li&gt; &lt;li key=&quot;d&quot;&gt;d&lt;/li&gt;&lt;/ul&gt; 新列表的变更是在中间删除了一个旧节点： 123456&lt;ul&gt; &lt;li key=&quot;a&quot;&gt;a&lt;/li&gt; &lt;li key=&quot;b&quot;&gt;b&lt;/li&gt; &lt;li key=&quot;c&quot;&gt;c&lt;/li&gt; &lt;li key=&quot;d&quot;&gt;d&lt;/li&gt;&lt;/ul&gt; 那么先进入第一步头部比对流程： 第一步执行时，会完成对 a 和 b 头部这 2 个节点进行 patch。当 i = 2 时，由于此时的 e 和 c 节点的 key 不一样，所以退出了头部比对流程，进入尾部比对： 第二步执行时，会完成对 c 和 d 尾部这 2 个节点进行 patch。当 e2 = 1 时，由于i &gt; e2，所以退出了尾部比对流程。此时的情况是新节点少了个 e 节点的情况，所以需要删除节点 e： 12345678910111213141516171819202122const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; { let i = 0 const l2 = c2.length // 旧节点的尾部标记位 let e1 = c1.length - 1 // 新节点的尾部标记位 let e2 = l2 - 1 // 从头部开始比对 // ... // 从尾部开始比对 // ... // 如果有多余的新节点，则执行新增逻辑 // ... // 如果有多余的旧节点，则执行卸载逻辑 else if (i &gt; e2) { while (i &lt;= e1) { // 卸载节点 unmount(c1[i], parentComponent, parentSuspense, true) i++ } }} 5. 未知子序列经过步骤 1、2 的操作后如果可以直接进入步骤 3、4 那是非常方便的操作了，直接进行多余删除缺少新增的操作。如果步骤 3、4 的条件都不满足的情况，如下： 旧子节点： 12345678910&lt;ul&gt; &lt;li key=&quot;a&quot;&gt;a&lt;/li&gt; &lt;li key=&quot;b&quot;&gt;b&lt;/li&gt; &lt;li key=&quot;c&quot;&gt;c&lt;/li&gt; &lt;li key=&quot;d&quot;&gt;d&lt;/li&gt; &lt;li key=&quot;e&quot;&gt;e&lt;/li&gt; &lt;li key=&quot;f&quot;&gt;f&lt;/li&gt; &lt;li key=&quot;g&quot;&gt;g&lt;/li&gt; &lt;li key=&quot;h&quot;&gt;h&lt;/li&gt;&lt;/ul&gt; 新子节点： 12345678910&lt;ul&gt; &lt;li key=&quot;a&quot;&gt;a&lt;/li&gt; &lt;li key=&quot;b&quot;&gt;b&lt;/li&gt; &lt;li key=&quot;e&quot;&gt;e&lt;/li&gt; &lt;li key=&quot;c&quot;&gt;c&lt;/li&gt; &lt;li key=&quot;d&quot;&gt;d&lt;/li&gt; &lt;li key=&quot;i&quot;&gt;i&lt;/li&gt; &lt;li key=&quot;g&quot;&gt;g&lt;/li&gt; &lt;li key=&quot;h&quot;&gt;h&lt;/li&gt;&lt;/ul&gt; 此时经过步骤 1、2 后的结果可以表示为如下图： 这种情况，既不满足 i &gt; e1 也不满足 i &gt; e2 的条件，进行节点复用 c 和 d 节点不动，只做 patch，e 节点 patch 后移动到 c 节点前面，删除 f 节点，然后在 d 节点后面添加 i 节点。 e 节点不动，只做 patch，c 和 d 节点 patch 后移动到 e 节点后面，删除 f 节点，然后在 d 节点后面添加 i 节点。 实现动态规划 最长公共子序列： 如果节点在新节点中，不在旧节点中，那么新增节点。 如果节点在旧节点中，不在新节点中，那么删除节点。 如果节点既在旧节点中，也在新节点中，那么更新。 如果节点需要移动，那么求取最长公共子序列后，进行最小位置移动。 构造新老节点位置映射 keyToNewIndexMap123456789101112131415// 旧子序列开始位置const s1 = i// 新子序列开始位置const s2 = i// 5.1 构建 key:index 关系索引 mapconst keyToNewIndexMap = new Map()for (i = s2; i &lt;= e2; i++) { const nextChild = (c2[i] = optimized ? cloneIfMounted(c2[i] as VNode) : normalizeVNode(c2[i])) if (nextChild.key != null) { keyToNewIndexMap.set(nextChild.key, i) }} 这里的新旧子节点开始位置通过 s1 和 s2 作为标记，然后开始进行构造新老节点位置映射，这里新节点 key -&gt; index 关系的索引图是保存在了 keyToNewIndexMap 这样一个 Map 结构中，其中的 key 就是新节点的 key 值，而 value 则是旧节点对应的位置关系 index。这一步完成后，生成的 keyToNewIndexMap 结果可以表示为： 1keyToNewIndexMap = { e: 2, c: 3, d: 4, i: 5 }; 继续处理旧节点有了上面的 keyToNewIndexMap 新节点的索引图，接下来就需要遍历旧的节点，寻找旧节点在新节点中对应的位置信息，如果找到则做更新，找不到则移除。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 记录新节点已更新的数目let patched = 0// 记录新节点还有多少个没有更新const toBePatched = e2 - s2 + 1// 标记是否有必要进行节点的位置移动let moved = false// 标记是否有节点进行了位置移动let maxNewIndexSoFar = 0// 记录新节点在旧节点中的位置数组const newIndexToOldIndexMap = new Array(toBePatched)// newIndexToOldIndexMap 全部置为 0for (i = 0; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = 0// 开始遍历旧子节点for (i = s1; i &lt;= e1; i++) { // prevChild 代表旧节点 const prevChild = c1[i] // 还有多余的旧节点，则删除 if (patched &gt;= toBePatched) { unmount(prevChild, parentComponent, parentSuspense, true) continue } // 记录旧节点在新节点中的位置数组 let newIndex = keyToNewIndexMap.get(prevChild.key) // 如果旧节点不存在于新节点中，则删除该节点 if (newIndex === undefined) { unmount(prevChild, parentComponent, parentSuspense, true) } else { // newIndexToOldIndexMap 中元素为 0 表示着新节点不存在于旧节点中 newIndexToOldIndexMap[newIndex - s2] = i + 1 // 默认不移动的话，所有相同节点都是增序排列的 // 如果有移动，必然出现节点降序的情况 if (newIndex &gt;= maxNewIndexSoFar) { maxNewIndexSoFar = newIndex } else { moved = true } // 更新节点 patch( prevChild, c2[newIndex] as VNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ) // 记录更新的数量 patched++ }} 流程： Step 1： 定义一个初始长度为新节点数组长度且默认值全为 0 的变量 newIndexToOldIndexMap，记录新节点中的元素在旧节点中的位置关系。 Step 2： 遍历旧的节点数组，如果旧节点不存在于新节点中，则表示旧的节点其实是多余的节点，需要被移除。 Step 3： 如果旧节点存在于新节点数组中，则将它在旧子序列中的位置信息记录到 newIndexToOldIndexMap 中，同时根据 newIndex 是否大于 maxNewIndexSoFar 来判断是否有节点移动。 示例：假如旧节点信息为 abc、新节点为 cab，当旧节点遍历到 c 节点时，此时的newIndex 的值为 0 而 maxNewIndexSoFar 的值为 2。这就意味着此时的 c 节点并不是升序位于 ab 节点之后的，因此需要标记为有需要移动的节点。 Step 4： 更新相同节点。 最后得到一个 newIndexToOldIndexMap 和一个 moved 两个变量 ，这两个变量将在下文的移动和新增节点中被使用。 处理后的数组： c、d、e 因为是相同节点，所以进行 patch 更新，f 节点因为不存在于新的索引中，所以被删除。最后得到的 newIndexToOldIndexMap 数据结构大致如下： 1newIndexToOldIndexMap = [5, 3, 4, 0]; 而且此时的 moved 也被标记为 true。 移动和增加新节点123456789101112131415161718192021222324252627282930313233// 根据 newIndexToOldIndexMap 求取最长公共子序列const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;// 最长公共子序列尾部索引j = increasingNewIndexSequence.length - 1;// 从尾部开始遍历for (i = toBePatched - 1; i &gt;= 0; i--) { const nextIndex = s2 + i; const nextChild = c2[nextIndex]; const anchor = nextIndex + 1 &lt; l2 ? c2[nextIndex + 1].el : parentAnchor; // 如果新子序列中的节点在旧子序列中不存在，则新增节点 if (newIndexToOldIndexMap[i] === 0) { patch( null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG ); } else if (moved) { // 如果需要移动且 // 没有最长递增子序列 // 当前的节点不在最长递增子序列中 if (j &lt; 0 || i !== increasingNewIndexSequence[j]) { move(nextChild, container, anchor, MoveType.REORDER); } else { j--; } }} Step 1： 这里针对 moved 是 true 的情况，则会进行求取最长递增子序列的索引操作。 最长递增子序列-&gt;动态规划 Step 2： 从尾部开始遍历新的子序列，在遍历的过程中，如果新子序列中的节点在旧子序列中不存在，也就是 newIndexToOldIndexMap[i] === 0，则新增节点。 Step 3： 判断是否存在节点移动的情况，如果存在的话则看节点的索引是不是在最长递增子序列中，如果不在，则将它移动到锚点的前面，否则仅移动最长子序列的尾部指针。 1move(nextChild, container, anchor, MoveType.REORDER); 最后结果： 动态规划算法实现： 下面这个不够好，解释的不清楚，不容易理解，后续要换成数组记录方式,一次简单遍历就行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function getSequence(arr) { const p = arr.slice(); const result = [0]; let i, j, u, v, c; const len = arr.length; for (i = 0; i &lt; len; i++) { const arrI = arr[i]; // 排除等于 0 的情况 if (arrI !== 0) { j = result[result.length - 1]; // 与最后一项进行比较 if (arr[j] &lt; arrI) { // 存储在 result 更新前的最后一个索引的值 p[i] = j; result.push(i); continue; } u = 0; v = result.length - 1; // 二分搜索，查找比 arrI 小的节点，更新 result 的值 while (u &lt; v) { // 取整得到当前位置 c = ((u + v) / 2) | 0; if (arr[result[c]] &lt; arrI) { u = c + 1; } else { v = c; } } if (arrI &lt; arr[result[u]]) { if (u &gt; 0) { // 正确的结果 p[i] = result[u - 1]; } // 有可能替换会导致结果不正确，需要一个新数组 p 记录正确的结果 result[u] = i; } } } u = result.length; v = result[u - 1]; // 回溯数组 p，找到最终的索引 while (u-- &gt; 0) { result[u] = v; v = p[v]; } return result;} 其中 result 中存储的是长度为 i 的递增子序列最小末尾值的索引。p 是来存储在每次更新 result 前最后一个索引的值，并且它的 key 是这次要更新的 result 值： 123456// 插入p[i] = j;result.push(i);// 替换p[i] = result[u - 1];result[u] = i;","link":"/2023/08/05/vue/%E6%B8%B2%E6%9F%93/diff%E7%AE%97%E6%B3%95/"},{"title":"mount","text":"mount 流程 createComponentInstance 1、从 main.js 的 createApp 到 mount1createApp(App).mount(&quot;#app&quot;); 123456// packages/runtime-dom/src/index.tsexport const createApp = (...args) =&gt; { const app = ensureRenderer().createApp(...args); // ... return app;}; 1234567891011121314151617181920// packages/runtime-dom/src/index.tsfunction ensureRenderer() { // 如果 renderer 有值的话，那么以后都不会初始化了 return ( renderer || (renderer = createRenderer(rendererOptions) )}// renderOptions 包含以下函数：const renderOptions = { createElement, createText, setText, setElementText, patchProp, insert, remove,} 123456789// packages/runtime-dom/src/index.tslet enabledHydration = false;function ensureHydrationRenderer() { renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions); enabledHydration = true; return renderer;} 12345678910// packages/runtime-core/src/renderer.tsexport function createRenderer(options) { // ... // 这里不介绍 hydrate 模式 return { render, hydrate, createApp: createAppAPI(render, hydrate), };} 123456789101112131415// packages/runtime-core/src/apiCreateApp.tsfunction createAppAPI(render, hydrate) { // createApp createApp 方法接收的两个参数：根组件的对象和 prop return function createApp(rootComponent, rootProps = null) { const app = { // ... 省略很多不需要在这里介绍的属性 _component: rootComponent, _props: rootProps, mount(rootContainer, isHydrate, isSVG) { // ... }, }; return app; };} 2、接下来就是具体的 mount 实现 创建根组件的 vnode vnode === Virtual DOM，就是离屏渲染的一种设计，本质是一个结构体 1234567const vnode = { type: &quot;div&quot;, props: { class: &quot;helloWorld&quot;, }, children: &quot;helloWorld&quot;,}; createVNode，根节点创建成 vnode ： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// packages/runtime-core/src/vnode.tsfunction createBaseVNode(...) { const vnode = { type, props, key: props &amp;&amp; normalizeKey(props), children, component: null, shapeFlag, patchFlag, dynamicProps, dynamicChildren: null, // ... 一些其他属性 } // ... return vnode}function createVNode(type, props = null, children = null) { if (props) { // 如果存在 props 则需要对 props 进行一些处理，这里先省略 } // ... // 处理 shapeFlag 类型 const shapeFlag = isString(type) ? ShapeFlags.ELEMENT : __FEATURE_SUSPENSE__ &amp;&amp; isSuspense(type) ? ShapeFlags.SUSPENSE : isTeleport(type) ? ShapeFlags.TELEPORT : isObject(type) ? ShapeFlags.STATEFUL_COMPONENT : isFunction(type) ? ShapeFlags.FUNCTIONAL_COMPONENT : 0 // ... return createBaseVNode( type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true )} params1type是节点类型例：shapeFlag === STATEFUL_COMPONENT，代表的是一个有状态组件对象如果传函数，则是函数式组件 FUNCTIONAL_COMPONENT VNode 渲染成真实的组件 mount 后就是对 vnode 的渲染工作： 1render(vnode, rootContainer); 1234567891011121314// packages/runtime-core/src/renderer.tsconst render = (vnode, container) =&gt; { if (vnode == null) { // 如果 vnode 不存在，表示需要卸载组件 if (container._vnode) { unmount(container._vnode, null, null, true); } } else { // 否则进入更新流程（初始化创建也是特殊的一种更新） patch(container._vnode || null, vnode, container); } // 缓存 vnode container._vnode = vnode;}; 初始化执行 patch ，初始化算作全量更新，其他更新则是局部： 1234567891011121314151617181920212223242526272829// packages/runtime-core/src/renderer.tsfunction patch(n1,n2,container = null,anchor = null,parentComponent = null) { // 对于类型不同的新老节点，直接进行卸载 if (n1 &amp;&amp; !isSameVNodeType(n1, n2)) { anchor = getNextHostNode(n1) unmount(n1, parentComponent, parentSuspense, true) n1 = null } // 基于 n2 的类型来判断 // 因为 n2 是新的 vnode const { type, shapeFlag } = n2; switch (type) { case Text: // 处理文本节点 break; // 其中还有几个类型比如： static fragment comment default: // 这里就基于 shapeFlag 来处理 if (shapeFlag &amp; ShapeFlags.ELEMENT) { // 处理普通 DOM 元素 processElement(n1, n2, container, anchor, parentComponent); } else if (shapeFlag &amp; ShapeFlags.COMPONENT) { // 处理 component processComponent(n1, n2, container, parentComponent); } else if { // ... 处理其他元素 } }} patch 参数： n1 表示老的 vnode 节点（初始化则为空）； n2 表示新的 vnode 节点； container 表示需要挂载的 dom 容器； anchor 挂载的参考元素； parentComponent 父组件。 根据n2类型判断更新节点类型，进行不同操作 这里需要注意的是 ShapeFlags 是一个二进制左移操作符生成的对象，其中 ShapeFlags.COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT，所以 shapeFlag &amp; ShapeFlags.COMPONENT 这里的值是 true 所以进 processComponent 的逻辑： 12345678910// packages/runtime-core/src/renderer.tsfunction processComponent(n1, n2, container, parentComponent) { // 如果 n1 没有值的话，那么就是 mount if (!n1) { // 初始化 component mountComponent(n2, container, parentComponent); } else { updateComponent(n1, n2, container); }} 初始化n1 此时还是个空值，所以进 mountComponent ，函数对组件进行初始挂载过程。 1234567891011121314// packages/runtime-core/src/renderer.tsfunction mountComponent(initialVNode, container, parentComponent) { // 1. 先创建一个 component instance const instance = (initialVNode.component = createComponentInstance( initialVNode, parentComponent )); // 2. 初始化 instance 上的 props, slots, 执行组件的 setup 函数... setupComponent(instance); // 3. 设置并运行带副作用的渲染函数 setupRenderEffect(instance, initialVNode, container);} 第一步是组件实例化，通过 createComponentInstance 的方法创建组件实例，返回的是一个组件实例的对象，如下： 12345678910111213141516171819202122232425262728// packages/runtime-core/src/component.tsconst instance = { // 这里是组件对象 type: vnode.type, // 组件 vnode vnode, // 新的组件 vnode next: null, // props 相关 props: {}, // 指向父组件 parent, // 依赖注入相关 provides: parent ? parent.provides : {}, // 渲染上下文代理 proxy: null, // 标记是否被挂载 isMounted: false, // attrs 相关 attrs: {}, // slots 相关 slots: {}, // context 相关 ctx: {}, // setup return 的状态数据 setupState: {}, // ...}; 第二步是初始化组件实例的一些对象，就是传入 setup 上下文： 123456789101112// packages/runtime-core/src/component.tsexport function setupComponent(instance) { // 1. 处理 props // 取出存在 vnode 里面的 props const { props, children } = instance.vnode; initProps(instance, props); // 2. 处理 slots initSlots(instance, children); // 3. 调用 setup 并处理 setupResult setupStatefulComponent(instance);} 第三步执行 setupRenderEffect ，也就是render的真正执行时机： 1234567891011121314151617181920212223242526// packages/runtime-core/src/renderer.tsconst setupRenderEffect = ( instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) =&gt; { function componentUpdateFn() { if (!instance.isMounted) { // 渲染子树的 vnode const subTree = (instance.subTree = renderComponentRoot(instance)); // 挂载子树 vnode 到 container 中 patch(null, subTree, container, anchor, instance, parentSuspense, isSVG); // 把渲染生成的子树根 DOM 节点存储到 el 属性上 initialVNode.el = subTree.el; instance.isMounted = true; } else { // 更新相关，后面介绍 } } // 创建副作用渲染函数 instance.update = effect(componentUpdateFn, prodEffectOptions);}; 调用 renderComponentRoot 来生成 subTree，然后再把 subTree 挂载到 container 中。其实 renderComponentRoot 的核心工作就是执行 instance.render 方法： 1234567import { openBlock, createElementBlock } from &quot;vue&quot;const _hoisted_1 = { class: &quot;helloWorld&quot; }export function render(...) { return (openBlock(), createElementBlock(&quot;div&quot;, _hoisted_1, &quot; hello world &quot;))} 1234567891011121314// packages/runtime-core/src/vnode.tsexport const createElementBlock = (...) =&gt; { return setupBlock( createBaseVNode( type, props, children, patchFlag, dynamicProps, shapeFlag, true /* isBlock */ ) )}; 本质还是调用 createBaseVNode 创建 vnode。所以 subtree 就是调用 render 函数而生产的 vnode 节点。subtree的 shapeFlags === ELEMENT 所以后续调用 processElement 这个函数： 123if (shapeFlag &amp; ShapeFlags.ELEMENT) { processElement(n1, n2, container, anchor, parentComponent);} processElement 的实现： 12345678910// packages/runtime-core/src/renderer.tsfunction processElement(n1, n2, container, anchor, parentComponent) { if (!n1) { // 挂载元素节点 mountElement(n2, container, anchor); } else { // 更新元素节点 updateElement(n1, n2, container, anchor, parentComponent); }} 初始化，n1 === null，所以这里执行的是 mountElement 进行元素的初始化挂载。 123456789101112131415161718192021222324252627282930313233// packages/runtime-core/src/renderer.tsconst mountElement = ( vnode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; { let el; const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode; // ... // 根据 vnode 创建 DOM 节点 el = vnode.el = hostCreateElement(vnode.type, isSVG, props &amp;&amp; props.is); if (props) { // 处理 props 属性 for (const key in props) { if (!isReservedProp(key)) { hostPatchProp(el, key, null, props[key], isSVG); } } } // 文本节点处理 if (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) { hostSetElementText(el, vnode.children); } else if (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) { // 如果节点是个数据类型，则递归子节点 mountChildren(vnode.children, el); } // 把创建好的 el 元素挂载到容器中 hostInsert(el, container, anchor);}; mountElemet 首先是通过 hostCreateElement 创建了一个 DOM 节点，然后处理一下 props 属性，接着根据 shapeFlag 判断子节点的类型，如果节点是个文本节点，则直接创建文本节点，如果子节点是个数组，比如这种情况： 1234567return ( openBlock(), createElementBlock(&quot;div&quot;, _hoisted_1, [ hoisted_2, createVNode(_component_Hello), ])); 数组会递归 patch 最后，处理完所有子节点后，通过 hostInsert 方法把缓存在内存中的 DOM el 映射渲染到真实的 DOM Container 当中。 1234// packages/runtime-dom/src/nodeOps.tsinsert: (child, parent, anchor) { parent.insertBefore(child, anchor || null)}","link":"/2023/08/05/vue/%E6%B8%B2%E6%9F%93/mount/"},{"title":"ref 工具函数","text":"ref 工具函数 isRef 判断是否为 ref 1234567891011//reactivity/__test__/ref.spec.ts...it('isRef', () =&gt; { const a = ref(1) const user = reactive({ age: 1 }) expect(isRef(a)).toBe(true) expect(isRef(1)).toBe(false) expect(isRef(user)).toBe(false)}) 1234567891011121314151617181920212223242526//reactivity/ref.ts...class RefImpl { private _value: any public dep private _rawValue: any public __v_isRef = true constructor(value) { this._rawValue = value this._value = convert(value) this.dep = new Set() } get value() { trackRefValue(this) return this._value } set value(newVal) { if (hasChanged(newVal, this._rawValue)) { this._rawValue = newVal this._value = convert(newVal) triggerEffects(this.dep) } }}export const isRef = ref =&gt; !!ref.__v_isRef; unRef ref 解包，去掉 value 操作 1234567//reactivity/__test__/ref.ts...it('unRef', () =&gt; { const a = ref(1) expect(unRef(a)).toBe(1) expect(unRef(1)).toBe(1)}) 1234//reactivity/ref.ts...export const unRef = ref =&gt; (isRef(ref) ? ref.value : ref) proxyRefs vue 中 template 的 setup 去掉 value 操作 12345678910111213141516171819202122232425//reactivity/__test__/ref.spec.ts...it('proxyRefs', () =&gt; { const user = { age: ref(10), name: 'qiuSu' } /** * get操作读取key判断是否是ref类型 * 是 返回.value * 否 直接返回 */ const proxyUser = proxyRefs(user) expect(user.age.value).toBe(10) expect(proxyUser.age).toBe(10) expect(proxyUser.name).toBe('qiuSu') /** * set操作修改val判断是否是ref类型 * 是 修改.value * 否 直接修改 */ proxyUser.age = 20 expect(proxyUser.age).toBe(20) expect(user.age.value).toBe(20) }) 12345678910111213//reactivity/ref.ts...export const proxyRefs = objectWithRefs =&gt; { return new Proxy(objectWithRefs, { get(target, key) { return unRef(Reflect.get(target, key)) }, set(target, key, val) { if (isRef(target[key]) &amp;&amp; !isRef(val)) return (target[key].value = val) else return Reflect.set(target, key, val) } })}","link":"/2023/08/05/vue/ref/isRef&unRef&proxyRefs/"},{"title":"渲染流程总览","text":"整体渲染流程，包括 mount，update，双端 diff 算法 这里做个标记，流程图中对于 setup 的 this 描述有问题，后面来改","link":"/2023/08/05/vue/%E6%B8%B2%E6%9F%93/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/"},{"title":"setup中的数据代理","text":"setup 中数据怎么实现代理,mount setupComponent 实现原理 这一节最好结合响应式组件上有一个动态文本节点 {{ msg }}，但是却有 2 处定义了 msg 响应式数据按照实例获取顺序，会渲染 msg from setup ,点击会更新 setup 里的 msg。 12345678910111213141516171819202122232425&lt;template&gt; &lt;p&gt;{{ msg }}&lt;/p&gt; &lt;button @click=&quot;changeMsg&quot;&gt;点击试试&lt;/button&gt;&lt;/template&gt;&lt;script&gt; import { ref } from &quot;vue&quot;; export default { data() { return { msg: &quot;msg from data&quot;, }; }, setup() { const msg = ref(&quot;msg from setup&quot;); return { msg, }; }, methods: { changeMsg() { this.msg = &quot;change&quot;; }, }, };&lt;/script&gt; 详解 mountComponent 的函数： 12345678910111213function mountComponent(initialVNode, container, parentComponent) { // 1. 先创建一个 component instance const instance = (initialVNode.component = createComponentInstance( initialVNode, parentComponent )); // 2. 初始化组件实例 setupComponent(instance); // 3. 设置并运行带副作用的渲染函数 setupRenderEffect(instance, initialVNode, container);} 初始化组件实例setupComponent 在源码中的实现： 12345678910111213141516171819export function setupComponent(instance, isSSR = false) { const { props, children } = instance.vnode; // 判断组件是否是有状态的组件 const isStateful = isStatefulComponent(instance); // 初始化 props initProps(instance, props, isStateful, isSSR); // 初始化 slots initSlots(instance, children); // 如果是有状态组件，那么去设置有状态组件实例 const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : undefined; return setupResult;} setupComponent 方法流程： 通过 isStatefulComponent(instance) 判断是否是有状态的组件； initProps 初始化 props； initSlots 初始化 slots； 根据组件是否是有状态的，来决定是否需要执行 setupStatefulComponent 函数。 其中， isStatefulComponent 判断是否是有状态的组件的函数如下： 123function isStatefulComponent(instance) { return instance.vnode.shapeFlag &amp; ShapeFlags.STATEFUL_COMPONENT;} ShapeFlags 在遇到组件类型的 type = Object 时，vnode 的shapeFlags = ShapeFlags.STATEFUL_COMPONENT，会执行 setupStatefulComponent 函数。 1234567891011121314151617181920212223242526function setupStatefulComponent(instance, isSSR) { // 定义 Component 变量 const Component = instance.type; // 1. 创建渲染代理的属性访问缓存 instance.accessCache = Object.create(null); // 2. 创建渲染上下文代理, proxy 对象其实是代理了 instance.ctx 对象 instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers); // 3. 执行 setup 函数 const { setup } = Component; if (setup) { // 如果 setup 函数带参数，则创建一个 setupContext const setupContext = (instance.setupContext = setup.length &gt; 1 ? createSetupContext(instance) : null); // 执行 setup 函数，获取结果 const setupResult = callWithErrorHandling(setup, instance, 0, [ instance.props, setupContext, ]); // 处理 setup 执行结果 handleSetupResult(instance, setupResult); } else { // 4. 完成组件实例设置 finishComponentSetup(instance, isSSR); }} setupStatefulComponent 是有状态组件，Vue 内部会保留组件状态数据。相对于有状态组件，Vue 还存在一种函数组件 FUNCTIONAL_COMPONENT，例： 12345678910111213import { ref } from &quot;vue&quot;;export default () =&gt; { let num = ref(0); const plusNum = () =&gt; { num.value++; }; return ( &lt;div&gt; &lt;button onClick={plusNum}&gt;{num.value}&lt;/button&gt; &lt;/div&gt; );}; 这个函数点击按钮时，num 的值并不会按照预期那样值会一直递增，因为它是一个函数组件，函数组件内部是没有状态保持的，所以 num 数据更新时，组件会重新渲染，num 的值永远不变一直是 0。 所以在这个时候，为了能符合预期的结果，需要将其设置成有状态的组件。可以通过 defineComponent 函数包装一下： 1234567891011121314import { ref, defineComponent } from &quot;vue&quot;;export default defineComponent(() =&gt; { let num = ref(0); const plusNum = () =&gt; { num.value++; }; return () =&gt; ( &lt;div&gt; &lt;button onClick={plusNum}&gt;{num.value}&lt;/button&gt; &lt;/div&gt; );}); defineComponent 返回的是个对象类型的 type，所以就变成了有状态组件。 创建渲染上下文代理Vue 3 内部有很多状态属性，存储在不同的对象上，比如 setupState、ctx、data、props。为减少心智负担，所以对 instance.ctx 进行代理，然后根据属性优先级关系依次完成从特定对象上获取值。 getinstance.ctx 代理的 PublicInstanceProxyHandlers 。get 函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667export const PublicInstanceProxyHandlers = { get({ _: instance }, key) { const { ctx, setupState, data, props, accessCache, type, appContext } = instance let normalizedProps if (key[0] !== '$') { // 从缓存中获取当前 key 存在于哪个属性中 const n = accessCache![key] if (n !== undefined) { switch (n) { case AccessTypes.SETUP: return setupState[key] case AccessTypes.DATA: return data[key] case AccessTypes.CONTEXT: return ctx[key] case AccessTypes.PROPS: return props![key] } } else if (setupState !== EMPTY_OBJ &amp;&amp; hasOwn(setupState, key)) { // 从 setupState 中取 accessCache![key] = AccessTypes.SETUP return setupState[key] } else if (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) { // 从 data 中取 accessCache![key] = AccessTypes.DATA return data[key] } else if ( (normalizedProps = instance.propsOptions[0]) &amp;&amp; hasOwn(normalizedProps, key) ) { // 从 props 中取 accessCache![key] = AccessTypes.PROPS return props![key] } else if (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) { // 从 ctx 中取 accessCache![key] = AccessTypes.CONTEXT return ctx[key] } else if (!__FEATURE_OPTIONS_API__ || shouldCacheAccess) { // 都取不到 accessCache![key] = AccessTypes.OTHER } } const publicGetter = publicPropertiesMap[key] let cssModule, globalProperties if (publicGetter) { // 以 $ 保留字开头的相关函数和方法 // ... } else if ( // css module (cssModule = type.__cssModules) &amp;&amp; (cssModule = cssModule[key]) ) { // ... } else if (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) { // ... } else if ( // 全局属性 ((globalProperties = appContext.config.globalProperties), hasOwn(globalProperties, key)) ) { // ... } else if (__DEV__) { // 一些告警 // ... } }} 这里解决 创建渲染代理的属性访问缓存 问题。如果知道 key 存在于哪个对象上，那么就可以直接通过对象取值的操作获取属性上的值了。如果不知道用户访问的 key 存在于哪个属性上，那只能通过 hasOwn 的方法先判断存在于哪个属性上，再通过对象取值的操作获取属性值，这无疑是多操作了一步，而且这个判断是比较耗费性能的。如果遇到大量渲染取值的操作，那么这块就是个性能瓶颈，所以这里用了 accessCache 来标记缓存 key 存在于哪个属性上。这其实也 相当于用一部分空间换时间的优化 。 接下来，函数首先判断 key[0] !== '$' 的情况（$ 开头的一般是 Vue 组件实例上的内置属性），在 Vue 3 源码中，会依次从 setupState、data、props、ctx 这几类数据中取状态值。 这里的定义顺序，决定了后续取值的优先级顺序：setupState &gt;data &gt;props &gt; ctx。 如果 key 是以 $ 开头，则首先会判断是否是存在于组件实例上的内置属性： 整体的获取顺序依次是：publicGetter &gt; cssModule &gt; ctx。最后，如果都取不到，那么在开发环境就会给一些告警提示。 setinstance.ctx 代理的 PublicInstanceProxyHandlers 。set 函数： 12345678910111213141516171819202122232425export const PublicInstanceProxyHandlers = { set({ _: instance }, key, value) { const { data, setupState, ctx } = instance; if (setupState !== EMPTY_OBJ &amp;&amp; hasOwn(setupState, key)) { // 设置 setupState setupState[key] = value; return true; } else if (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) { // 设置 data data[key] = value; return true; } else if (hasOwn(instance.props, key)) { // 不能给 props 赋值 return false; } if (key[0] === &quot;$&quot; &amp;&amp; key.slice(1) in instance) { // 不能给组件实例上的内置属性赋值 return false; } else { // 用户自定义数据赋值 ctx[key] = value; } return true; },}; 可以看到这里也是和前面 get 函数类似的通过调用顺序来实现对 set 函数不同属性设置优先级的，可以直观地看到优先级关系为：setupState &gt; data &gt; props。同时这里也有说明：就是如果直接对 props 或者组件实例上的内置属性赋值，则会告警。 hasproxy 属性 has 的实现： 1234567891011121314export const PublicInstanceProxyHandlers = { has({_: { data, setupState, accessCache, ctx, appContext, propsOptions }}, key) { let normalizedProps return ( !!accessCache![key] || (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) || (setupState !== EMPTY_OBJ &amp;&amp; hasOwn(setupState, key)) || ((normalizedProps = propsOptions[0]) &amp;&amp; hasOwn(normalizedProps, key)) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key) ) },} 这个函数则是依次判断 key 是否存在于 accessCache &gt; data &gt; setupState &gt; prop &gt; ctx &gt; publicPropertiesMap &gt; globalProperties，然后返回结果。 has 在业务代码的使用定义如下： 123456export default { created() { // 这里会触发 has 函数 console.log(&quot;msg&quot; in this); },}; 综上 handle 就是创建上下文代理的过程。 调用执行 setup 函数一个简单的包含 CompositionAPI 的 Vue 3 demo 如下： 12345678910111213&lt;template&gt; &lt;p&gt;{{ msg }}&lt;/p&gt;&lt;/template&gt;&lt;script&gt; export default { props: { msg: String, }, setup(props, setupContext) { // todo }, };&lt;/script&gt; 这里的 setup 函数，正是在这里被调用执行的： 123456789101112131415// 获取 setup 函数const { setup } = Component;// 存在 setup 函数if (setup) { // 根据 setup 函数的入参长度，判断是否需要创建 setupContext 对象 const setupContext = (instance.setupContext = setup.length &gt; 1 ? createSetupContext(instance) : null); // 调用 setup const setupResult = callWithErrorHandling(setup, instance, 0, [ instance.props, setupContext, ]); // 处理 setup 执行结果 handleSetupResult(instance, setupResult);} createSetupContext因为 setupContext 是 setup 中的第二个参数，所以会判断 setup 函数参数的长度，如果大于 1，则会通过 createSetupContext 函数创建 setupContext 上下文。 该上下文创建如下： 12345678910function createSetupContext(instance) { return { get attrs() { return attrs || (attrs = createAttrsProxy(instance)); }, slots: instance.slots, emit: instance.emit, expose, };} 可以看到，setupContext 中包含了 attrs、slots、emit、expose 这些属性。这些属性分别代表着：组件的属性、插槽、派发事件的方法 emit、以及所有想从当前组件实例导出的内容 expose。 callWithErrorHandling第二步，通过 callWithErrorHandling 函数来间接执行 setup 函数，其实就是执行了以下代码： 12const setupResult = setup &amp;&amp; setup(shallowReadonly(instance.props), setupContext); 只不过增加了对执行过程中 handleError 的捕获。 Vue 3 很多函数的调用都是通过 callWithErrorHandling 来包裹的： 123456789export function callWithErrorHandling(fn, instance, type, args = []) { let res; try { res = args ? fn(...args) : fn(); } catch (err) { handleError(err, instance, type); } return res;} 这样的好处一方面可以由 Vue 内部统一 try...catch 处理用户代码运行可能出现的错误。另一方面这些错误也可以交由用户统一注册的 errorHandler 进行处理，比如上报给监控系统。 handleSetupResult最后执行 handleSetupResult 函数： 12345678910function handleSetupResult(instance, setupResult) { if (isFunction(setupResult)) { // setup 返回渲染函数 instance.render = setupResult; } else if (isObject(setupResult)) { // proxyRefs 的作用就是把 setupResult 对象做一层代理 instance.setupState = proxyRefs(setupResult); } finishComponentSetup(instance);} setup 返回值不一样的话，会有不同的处理，如果 setupResult 是个函数，那么会把该函数绑定到 render 上。比如： 123456789101112131415&lt;script&gt; import { createVnode } from 'vue' export default { props: { msg: String }, setup (props, { emit }) { return (ctx) =&gt; { return [ createVnode('p', null, ctx.msg) ] } } }&lt;/script&gt; 当 setupResult 是一个对象的时候，为 setupResult 对象通过 proxyRefs 作了一层代理，方便用户直接访问 ref 类型的值。比如，在模板中访问 setupResult 中的数据，就可以省略 .value 的取值，而由代理来默认取 .value 的值。 注意，这里 instance.setupState = proxyRefs(setupResult); 之前的 Vue 源码的写法是 instance.setupState = reactive(setupResult); ，至于为什么改成上面的，Vue 作者也有相关说明：Template auto ref unwrapping for setup() return object is now applied only to the root level refs. 完成组件实例设置最后， finishComponentSetup ： 12345678910111213141516171819202122function finishComponentSetup(instance) { // type 是个组件对象 const Component = instance.type; if (!instance.render) { // 如果组件没有 render 函数，那么就需要把 template 编译成 render 函数 if (compile &amp;&amp; !Component.render) { if (Component.template) { // 这里就是 runtime 模块和 compile 模块结合点 // 运行时编译 Component.render = compile(Component.template, { isCustomElement: instance.appContext.config.isCustomElement || NO, }); } } instance.render = Component.render; } if (__FEATURE_OPTIONS_API__ &amp;&amp; !(__COMPAT__ &amp;&amp; skipOptions)) { // 兼容选项式组件的调用逻辑 }} 这里主要做的就是根据 instance 上有没有 render 函数来判断是否需要进行运行时渲染，运行时渲染指的是在浏览器运行的过程中，动态编译 &lt;template&gt; 标签内的内容，产出渲染函数。对于编译时渲染，则是有渲染函数的，因为模板中的内容会被 webpack 中 vue-loader 这样的插件进行编译。 另外需要注意的，这里有个 __FEATURE_OPTIONS_API__ 变量用来标记是否是兼容 选项式 API 调用，如果只使用 Composition Api 那么就可以通过 webpack 静态变量注入的方式关闭此特性。然后交由 Tree-Shacking 删除无用的代码，从而减少引用代码包的体积。","link":"/2023/08/05/vue/%E6%B8%B2%E6%9F%93/setup%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86/"},{"title":"组件完成更新渲染","text":"setup 中数据怎么实现代理,mount setupRenderEffect 实现原理 组件更新123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const setupRenderEffect = ( instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) =&gt; { function componentUpdateFn() { if (!instance.isMounted) { // 初始化组件 } else { // 更新组件 let { next, vnode } = instance; // 如果有 next 的话说明需要更新组件的数组（props, slot 等） if (next) { next.el = vnode.el; // 更新组件实例信息 updateComponentPreRender(instance, next, optimized); } else { next = vnode; } // 获取新的子树 vnode const nextTree = renderComponentRoot(instance); // 获取旧的子树 vnode const prevTree = instance.subTree; // 更新子树 vnode instance.subTree = nextTree; // patch 新老子树的 vnode patch( prevTree, nextTree, // 处理 teleport 相关 hostParentNode(prevTree.el), // 处理 fragment 相关 getNextHostNode(prevTree), instance, parentSuspense, isSVG ); // 缓存更新后的 DOM 节点 next.el = nextTree.el; } } // 创建响应式的副作用渲染函数 instance.update = effect(componentUpdateFn, prodEffectOptions);}; 这里的核心流程是通过 next 来判断当前是否需要更新 vnode 的节点信息，然后渲染出新的子树 nextTree，再进行比对新旧子树并找出需要更新的点，进行 DOM 更新 patch ： 123456789101112131415161718192021222324252627282930313233function patch( n1, n2, container = null, anchor = null, parentComponent = null) { // 对于类型不同的新老节点，直接进行卸载 if (n1 &amp;&amp; !isSameVNodeType(n1, n2)) { anchor = getNextHostNode(n1); unmount(n1, parentComponent, parentSuspense, true); n1 = null; } // 基于 n2 的类型来判断 // 因为 n2 是新的 vnode const { type, shapeFlag } = n2; switch (type) { case Text: processText(n1, n2, container); break; // 其中还有几个类型比如： static fragment comment case Fragment: processFragment(n1, n2, container); break; default: // 这里就基于 shapeFlag 来处理 if (shapeFlag &amp; ShapeFlags.ELEMENT) { processElement(n1, n2, container, anchor, parentComponent); } else if (shapeFlag &amp; ShapeFlags.STATEFUL_COMPONENT) { processComponent(n1, n2, container, parentComponent); } }} 首先判断当 n1 存在，即存在老节点，isSameVNodeType判断新节点和老节点是否相同，不相同则销毁老节点，新增新节点： 1234export function isSameVNodeType(n1, n2) { // 新老节点的 type 和 key 都相同 return n1.type === n2.type &amp;&amp; n1.key === n2.key;} 这里比如从 div 变成了 p 标签，那么 isSameVNodeType 就会是个 false。 如果当新老节点是同类型的节点，则会根据 shapeFlag不同走到不同的逻辑，如果是普通元素更新，那么就会走到 processElement 的逻辑中；如果是组件更新，则会走到 processComponent 中。 processElement123456789101112131415161718const processElement = ( n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; { isSVG = isSVG || n2.type === &quot;svg&quot;; if (n1 == null) { // 初始化的过程 } else { // 更新的过程 patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized); }}; processElement 更新逻辑调用 patchElement 函数： 12345678910111213141516171819202122232425262728293031323334353637const patchElement = ( n1, n2, parentComponent, parentSuspense, isSVG, optimized) =&gt; { const el = (n2.el = n1.el); let { patchFlag, dynamicChildren, dirs } = n2; // ... // 旧节点的 props const oldProps = (n1 &amp;&amp; n1.props) || EMPTY_OBJ; // 新节点的 props const newProps = n2.props || EMPTY_OBJ; // 对比 props 并更新 patchProps( el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG ); // 先省略 dynamicChildren 的逻辑，后续介绍... // 全量比对子节点更新 patchChildren( n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG );}; 普通元素的更新主要做的就是先更新 props ，当 props 更新完成后，然后再统一更新子节点。 patchChildren 更新子节点的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172const patchChildren = ( n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized = false) =&gt; { // c1 代表旧节点的子节点元素 const c1 = n1 &amp;&amp; n1.children; const prevShapeFlag = n1 ? n1.shapeFlag : 0; // c2 代表新节点的子节点元素 const c2 = n2.children; const { patchFlag, shapeFlag } = n2; // 新节点是文本 if (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) { // 旧节点是数组 if (prevShapeFlag &amp; ARRAY_CHILDREN) { // 卸载旧节点 unmountChildren(c1, parentComponent, parentSuspense); } if (c2 !== c1) { // 新旧节点都是文本，但内容不一样，则替换 hostSetElementText(container, c2); } } else { // 新节点不为文本 // 旧节点是数组 if (prevShapeFlag &amp; ARRAY_CHILDREN) { // 新节点也是数组 if (shapeFlag &amp; ARRAY_CHILDREN) { // 进行新旧节点的 diff patchKeyedChildren( c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized ); } else { // 卸载旧节点 unmountChildren(c1, parentComponent, parentSuspense, true); } } else { // 新节点不为文本 // 旧节点不是数组 // 旧节点是文本 if (prevShapeFlag &amp; TEXT_CHILDREN) { // 则把它清空 hostSetElementText(container, &quot;&quot;); } // 新节点是数组 if (shapeFlag &amp; ARRAY_CHILDREN) { // 挂载新节点 mountChildren( c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized ); } } }}; 子节点只会有文本节点、数组节点、空节点三种，结合流程图可以知道每种情况的处理 其中新旧节点都是数组就是最复杂的情况， diff 算法 上面是处理DOM元素的情况，下面处理vue组件。 processComponent1234567891011121314151617const processComponent = ( n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; { if (n1 == null) { // 初始化的过程 } else { // 更新的过程 updateComponent(n1, n2, parentComponent, optimized); }}; processComponent 更新逻辑调用 updateComponent 函数： 123456789101112131415const updateComponent = (n1, n2, optimized) =&gt; { const instance = (n2.component = n1.component)! // 根据新老节点判断是否需要更新子组件 if (shouldUpdateComponent(n1, n2, optimized)) { //... // 如果需要更新，则将新节点 vnode 赋值给 next instance.next = n2 // 执行前面定义在 instance 上的 update 函数。 instance.update() } else { // 如果不需要更新，则将就节点的内容更新到新节点上即可 n2.el = n1.el instance.vnode = n2 }} updateComponent 函数首先通过 shouldUpdateComponent 函数来判断当前是否需要更新。 因为有些 VNode 值的变化并不需要立即显示更新子组件，举个例子： 123456789&lt;template&gt; &lt;div&gt;{{msg}}&lt;/div&gt; &lt;Child /&gt;&lt;/template&gt;&lt;script setup&gt;import { ref } from 'vue'const msg = ref('hello')&lt;script&gt; 因为子组件不依赖父组件的状态数据，所以子组件是不需要更新的。 最后执行的 instance.update，这个函数其实就是在 setupRenderEffect 内创建的。最终子组件的更新还会走一遍自己副作用函数的渲染，然后 patch 子组件的子模板 DOM，接上上面的流程。 示例： 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div&gt; hello world &lt;hello :msg=&quot;msg&quot; /&gt; &lt;button @click=&quot;changeMsg&quot;&gt;修改 msg&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import { ref } from &quot;vue&quot;; export default { setup() { const msg = ref(&quot;你好&quot;); function changeMsg() { msg.value = &quot;你好啊，change&quot;; } return { msg, changeMsg, }; }, };&lt;/script&gt;// hello.vue&lt;template&gt; &lt;div&gt;{{msg}}&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { props: { msg: String, }, };&lt;/script&gt; 当点击 修改 msg 后， App 组件自身的数据变化，导致 App 组件进入 update 逻辑，此时是没有 next 的，接下来渲染新的子组件vnode，得到真实的模板vnode nextTree，用新旧subTree进行patch。 此时patch的元素类型是 div，进入更新普通元素的流程，先更新props，再更新子节点，当前div下的子节点有Hello组件时，进入组件的的更新流程。 在更新 Hello 组件时，根据 updateComponent 函数执行的逻辑，会先将Hello组件 instance.next 赋值为最新的子组件 vnode，之后再主动调用instance.update 进入上面的副作用渲染函数，这次的实例是 Hello 组件自身的渲染，且 next 存在值。 当 next 存在时，会执行 updateComponentPreRender 函数： 12345678910111213const updateComponentPreRender = (instance, nextVNode, optimized) =&gt; { // 新节点 vnode.component 赋值为 instance nextVNode.component = instance; // 获取老节点的 props const prevProps = instance.vnode.props; // 为 instance.vnode 赋值为新的组件 vnode instance.vnode = nextVNode; instance.next = null; // 更新 props updateProps(instance, nextVNode.props, prevProps, optimized); // 更新 slots updateSlots(instance, nextVNode.children);}; updateComponentPreRender 函数核心功能就是完成了对实例上的属性、vnode 信息、slots 进行更新，当后续组件渲染的时候，得到的就是最新的值。 next 就是用来标记接下来需要渲染的子组件，如果 next 存在，则会进行子组件实例相关内容属性的更新操作，再进行子组件的更新流程。","link":"/2023/08/05/vue/%E6%B8%B2%E6%9F%93/%E7%BB%84%E4%BB%B6%E5%AE%8C%E6%88%90%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93/"},{"title":"ref流程","text":"ref 普通变量的响应式数据 123456789101112131415161718192021222324252627282930313233343536373839//reactivity/__test__/ref.spec.tsimport { effect } from '../effect'import { reactive } from '../reactive'import { ref, isRef, unRef, proxyRefs } from '../ref'describe('ref', () =&gt; { it('happy path', () =&gt; { const a = ref(1) expect(a.value).toBe(1) }) it('should be reactive', () =&gt; { const a = ref(1) let dummy let calls = 0 effect(() =&gt; { calls++ dummy = a.value }) expect(calls).toBe(1) expect(dummy).toBe(1) a.value = 2 expect(calls).toBe(2) expect(dummy).toBe(2) a.value = 2 expect(calls).toBe(2) expect(dummy).toBe(2) }) it('should make nested properties reactive', () =&gt; { const a = ref({ count: 1 }) let dummy effect(() =&gt; { dummy = a.value.count }) expect(dummy).toBe(1) a.value.count = 2 expect(dummy).toBe(2) })}) ref 实现 1234567891011121314151617181920212223242526272829303132333435//reactivity/ref.tsimport { trackEffects, triggerEffects, isTracking } from './effect'import { reactive } from './reactive'import { hasChanged, isObject } from '../shared'/**对象转换为reactive对象 */const convert = val =&gt; (isObject(val) ? reactive(val) : val)class RefImpl { private _value: any public dep private _rawValue: any constructor(value) { this._rawValue = value this._value = convert(value) this.dep = new Set() } get value() { tarckRefValue(this) return this._value } set value(newVal) { if (hasChanged(newVal, this._rawValue)) { this._rawValue = newVal this._value = convert(newVal) triggerEffects(this.dep) } }}const tarckRefValue = ref =&gt; { if (isTracking()) trackEffects(ref.dep)}export const ref = value =&gt; new RefImpl(value) 1234567891011121314151617181920212223242526272829303132333435363738//reactivity/effect.ts/**是否收集依赖 */export const isTracking = () =&gt; shouldTrack &amp;&amp; activeEffect !== undefinedexport const trackEffects = dep =&gt; { if (dep.has(activeEffect)) return dep.add(activeEffect) activeEffect.deps.push(dep)}/**依赖收集 */export const track = (target, key) =&gt; { if (!isTracking()) return // target -&gt; key -&gt; dep let depsMap = targetMap.get(target) if (!depsMap) { depsMap = new Map() targetMap.set(target, depsMap) } let dep = depsMap.get(key) if (!dep) { dep = new Set() depsMap.set(key, dep) } trackEffects(dep)}export const triggerEffects = dep =&gt; { for (const effect of dep) { if (effect.scheduler) effect.scheduler() else effect.run() }}/**触发依赖收集 */export const trigger = (target, key) =&gt; { let depsMap = targetMap.get(target) let dep = depsMap.get(key) triggerEffects(dep)}","link":"/2023/08/05/vue/ref/ref/"},{"title":"template -&gt; AST","text":"根据 template 生成抽象语法树（AST），baseCompile baseParse Vue3 的核心编译源码文件在 packages/compiler-dom/src/index.ts 中： 1234567891011121314function compile(template, options = {}) { return baseCompile( template, extend({}, parserOptions, options, { nodeTransforms: [...DOMNodeTransforms, ...(options.nodeTransforms || [])], directiveTransforms: extend( {}, DOMDirectiveTransforms, options.directiveTransforms || {} ), transformHoist: null, }) );} 其核心调用的就是 baseCompile 函数： 12345678910111213141516171819202122232425262728293031export function baseCompile(template, options = {}) { // 如果是字符串模版，则直接进行解析，转成 AST const ast = isString(template) ? baseParse(template, options) : template; const [nodeTransforms, directiveTransforms] = getBaseTransformPreset(prefixIdentifiers); // AST 转换成 JS AST transform( ast, extend({}, options, { prefixIdentifiers, nodeTransforms: [ ...nodeTransforms, ...(options.nodeTransforms || []), // user transforms ], directiveTransforms: extend( {}, directiveTransforms, options.directiveTransforms || {} // user transforms ), }) ); // JS AST 生成代码 return generate( ast, extend({}, options, { prefixIdentifiers, }) );} 可以看到 baseCompile 函数核心就只有 3 步： 对 template 模版进行词法和语法分析，生成 AST AST 转换成附有 JS 语义的 JavaScript AST 解析 JavaScript AST 生成代码 解析 template 生成 AST一个简单的模版如下： 1234&lt;template&gt; &lt;!-- 这是一段注释 --&gt; &lt;p&gt;{{ msg }}&lt;/p&gt;&lt;/template&gt; 这个模版经过 baseParse 后转成的 AST 结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100{ &quot;type&quot;: 0, &quot;children&quot;: [ { &quot;type&quot;: 3, &quot;content&quot;: &quot; 这是一段注释 &quot;, &quot;loc&quot;: { &quot;start&quot;: { &quot;column&quot;: 3, &quot;line&quot;: 2, &quot;offset&quot;: 3 }, &quot;end&quot;: { &quot;column&quot;: 18, &quot;line&quot;: 2, &quot;offset&quot;: 18 }, &quot;source&quot;: &quot;&lt;!-- 这是一段注释 --&gt;&quot; } }, { &quot;type&quot;: 1, &quot;ns&quot;: 0, &quot;tag&quot;: &quot;p&quot;, &quot;tagType&quot;: 0, &quot;props&quot;: [], &quot;isSelfClosing&quot;: false, &quot;children&quot;: [ { &quot;type&quot;: 5, &quot;content&quot;: { &quot;type&quot;: 4, &quot;isStatic&quot;: false, &quot;constType&quot;: 0, &quot;content&quot;: &quot;msg&quot;, &quot;loc&quot;: { &quot;start&quot;: { &quot;column&quot;: 9, &quot;line&quot;: 3, &quot;offset&quot;: 27 }, &quot;end&quot;: { &quot;column&quot;: 12, &quot;line&quot;: 3, &quot;offset&quot;: 30 }, &quot;source&quot;: &quot;msg&quot; } }, &quot;loc&quot;: { &quot;start&quot;: { &quot;column&quot;: 6, &quot;line&quot;: 3, &quot;offset&quot;: 24 }, &quot;end&quot;: { &quot;column&quot;: 15, &quot;line&quot;: 3, &quot;offset&quot;: 33 }, &quot;source&quot;: &quot;{{ msg }}&quot; } } ], &quot;loc&quot;: { &quot;start&quot;: { &quot;column&quot;: 3, &quot;line&quot;: 3, &quot;offset&quot;: 21 }, &quot;end&quot;: { &quot;column&quot;: 19, &quot;line&quot;: 3, &quot;offset&quot;: 37 }, &quot;source&quot;: &quot;&lt;p&gt;{{ msg }}&lt;/p&gt;&quot; } } ], &quot;helpers&quot;: [], &quot;components&quot;: [], &quot;directives&quot;: [], &quot;hoists&quot;: [], &quot;imports&quot;: [], &quot;cached&quot;: 0, &quot;temps&quot;: 0, &quot;loc&quot;: { &quot;start&quot;: { &quot;column&quot;: 1, &quot;line&quot;: 1, &quot;offset&quot;: 0 }, &quot;end&quot;: { &quot;column&quot;: 1, &quot;line&quot;: 4, &quot;offset&quot;: 38 }, &quot;source&quot;: &quot;\\n &lt;!-- 这是一段注释 --&gt;\\n &lt;p&gt;{{ msg }}&lt;/p&gt;\\n&quot; }} 其中有一个 type 字段，用来标记 AST 节点的类型，这里涉及到的枚举如下： 123456789export const enum NodeTypes { ROOT, // 0 根节点 ELEMENT, // 1 元素节点 TEXT, // 2 文本节点 COMMENT, // 3 注释节点 SIMPLE_EXPRESSION, // 4 表达式 INTERPOLATION, // 5 插值节点 // ...} 另外，props 描述的是节点的属性，loc 代表的是节点对应的代码相关信息，包括代码的起始位置等等。 生成 AST 的核心算法： 1234567891011export function baseParse(content, options) { // 创建解析上下文 const context = createParserContext(content, options); // 获取起点位置 const start = getCursor(context); // 创建 AST return createRoot( parseChildren(context, TextModes.DATA, []), getSelection(context, start) );} 其中创建解析上下文得到的 context 的过程： 12345678910111213function createParserContext(content, options) { return { options: extend({}, defaultParserOptions, options), column: 1, line: 1, offset: 0, // 存储原始模版内容 originalSource: content, source: content, inPre: false, inVPre: false, };} createParserContext 本质就是返回了一个 context 对象，用来标记解析过程中的上下文内容。 接下来需要分析的是 parseChildren 函数，该函数是生成 AST 的核心函数。该函数传入了初始化生成的 context 对象，context 对象中包含初始的模版内容，存储在 originalSource 和 source 中。 parseChildren 对节点内容解析的过程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192function parseChildren(context, mode, ancestors) { // 获取父节点 const parent = last(ancestors); const ns = parent ? parent.ns : Namespaces.HTML; const nodes: TemplateChildNode[] = []; // 判断是否到达结束位置，遍历结束 while (!isEnd(context, mode, ancestors)) { // template 中的字符串 const s = context.source; let node = undefined; // 如果 mode 是 DATA 和 RCDATA 模式 if (mode === TextModes.DATA || mode === TextModes.RCDATA) { // 处理 {{ 开头的情况 if (!context.inVPre &amp;&amp; startsWith(s, context.options.delimiters[0])) { // '{{' node = parseInterpolation(context, mode); } else if (mode === TextModes.DATA &amp;&amp; s[0] === &quot;&lt;&quot;) { // 以 &lt; 开头且就一个 &lt; 字符 if (s.length === 1) { emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 1); } else if (s[1] === &quot;!&quot;) { // 以 &lt;! 开头的情况 if (startsWith(s, &quot;&lt;!--&quot;)) { // 如果是 &lt;!-- 这种情况，则按照注释节点处理 node = parseComment(context); } else if (startsWith(s, &quot;&lt;!DOCTYPE&quot;)) { // 如果是 &lt;!DOCTYPE 这种情况 node = parseBogusComment(context); } else if (startsWith(s, &quot;&lt;![CDATA[&quot;)) { // 如果是 &lt;![CDATA[ 这种情况 if (ns !== Namespaces.HTML) { node = parseCDATA(context, ancestors); } else { emitError(context, ErrorCodes.CDATA_IN_HTML_CONTENT); node = parseBogusComment(context); } } else { // 都不是的话，则报错 emitError(context, ErrorCodes.INCORRECTLY_OPENED_COMMENT); node = parseBogusComment(context); } } else if (s[1] === &quot;/&quot;) { // 以 &lt;/ 开头，并且只有 &lt;/ 的情况 if (s.length === 2) { emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 2); } else if (s[2] === &quot;&gt;&quot;) { // &lt;/&gt; 缺少结束标签，报错 emitError(context, ErrorCodes.MISSING_END_TAG_NAME, 2); advanceBy(context, 3); continue; } else if (/[a-z]/i.test(s[2])) { // 文本中存在多余的结束标签的情况 &lt;/p&gt; emitError(context, ErrorCodes.X_INVALID_END_TAG); parseTag(context, TagType.End, parent); continue; } else { emitError( context, ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME, 2 ); node = parseBogusComment(context); } } else if (/[a-z]/i.test(s[1])) { // 解析标签元素节点 node = parseElement(context, ancestors); } else if (s[1] === &quot;?&quot;) { emitError( context, ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME, 1 ); node = parseBogusComment(context); } else { emitError(context, ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME, 1); } } } if (!node) { // 解析普通文本节点 node = parseText(context, mode); } if (isArray(node)) { for (let i = 0; i &lt; node.length; i++) { pushNode(nodes, node[i]); } } else { pushNode(nodes, node); } }} Vue 在解析模板字符串时，可分为两种情况：以 &lt; 开头的字符串和不以 &lt; 开头的字符串。 其中，不以 &lt; 开头的字符串有两种情况：它是文本节点或 {{ exp }} 插值表达式。 而以 &lt; 开头的字符串又分为以下几种情况： 元素开始标签，比如 &lt;div&gt; 注释节点 &lt;!-- 123 --&gt; 文档声明 &lt;!DOCTYPE html&gt; 纯文本标签 &lt;![CDATA[&lt;]]&gt; 1. 解析插值当遇到字符串 {{msg}} 的时候，会把当前代码当做是插值节点来解析，进入 parseInterpolation 函数体内： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function parseInterpolation(context, mode) { // 从配置中获取插值开始和结束分隔符，默认是 {{ 和 }} const [open, close] = context.options.delimiters; // 获取结束分隔符的位置 const closeIndex = context.source.indexOf(close, open.length); // 如果不存在结束分隔符，则报错 if (closeIndex === -1) { emitError(context, ErrorCodes.X_MISSING_INTERPOLATION_END); return undefined; } // 获取开始解析的起点 const start = getCursor(context); // 解析位置移动到插值开始分隔符后 advanceBy(context, open.length); // 获取插值起点位置 const innerStart = getCursor(context); // 获取插值结束位置 const innerEnd = getCursor(context); // 插值原始内容的长度 const rawContentLength = closeIndex - open.length; // 插值原始内容 const rawContent = context.source.slice(0, rawContentLength); // 获取插值的内容，并移动位置到插值的内容后 const preTrimContent = parseTextData(context, rawContentLength, mode); const content = preTrimContent.trim(); // 如果存在空格的情况，需要计算偏移值 const startOffset = preTrimContent.indexOf(content); if (startOffset &gt; 0) { // 更新插值起点位置 advancePositionWithMutation(innerStart, rawContent, startOffset); } // 如果尾部存在空格的情况 const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset); // 也需要更新尾部的位置 advancePositionWithMutation(innerEnd, rawContent, endOffset); // 移动位置到插值结束分隔符后 advanceBy(context, close.length); return { type: NodeTypes.INTERPOLATION, content: { type: NodeTypes.SIMPLE_EXPRESSION, isStatic: false, // Set `isConstant` to false by default and will decide in transformExpression constType: ConstantTypes.NOT_CONSTANT, content, loc: getSelection(context, innerStart, innerEnd), }, loc: getSelection(context, start), };} advanceBy(context, numberOfCharacters)：其功能是更新解析上下文 context 中的 source 来移动代码解析的位置，同时更新 offset、line、column 等和代码位置相关的属性，这样来达到一步步 蚕食 模版字符串的目的，从而达到对整个模版字符 chuancontext 是字符串的上下文对象，numberOfCharacters 是要前进的字符数。 针对这样一段代码： 1234&lt;div&gt; {{ msg }} &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 调用 advance(s, 14) 函数，得到结果： parseInterpolation 函数本质就是通过插值的开始标签{{` 和结束标签 `}} 找到插值的内容 content。然后再计算插值的起始位置，接着就是前进代码到插值结束分隔符后，表示插值部分代码处理完毕，可以继续解析后续代码了。 最后返回一个描述插值节点的 AST 对象，其中，loc 记录了插值的代码开头和结束的位置信息，type 表示当前节点的类型，content 表示当前节点的内容信息。 2. 解析文本针对源代码起点位置的字符不是 &lt; 或者 {{` 时，则当做是文本节点处理，调用 `parseText` 函数： 123456789101112131415161718192021222324function parseText(context, mode) { // 文本结束符 const endTokens = mode === TextModes.CDATA ? [&quot;]]&gt;&quot;] : [&quot;&lt;&quot;, context.options.delimiters[0]]; let endIndex = context.source.length; // 遍历文本结束符，匹配找到结束的位置 for (let i = 0; i &lt; endTokens.length; i++) { const index = context.source.indexOf(endTokens[i], 1); if (index !== -1 &amp;&amp; endIndex &gt; index) { endIndex = index; } } const start = getCursor(context); // 获取文本的内容，并前进代码到文本的内容后 const content = parseTextData(context, endIndex, mode); return { type: NodeTypes.TEXT, content, loc: getSelection(context, start), };} `parseText` ：如果一段文本，在 `CDATA` 模式下，当遇到 `]]>` 即为结束位置，否则，都是在遇到 `","link":"/2023/08/05/vue/%E7%BC%96%E8%AF%91%E5%99%A8/%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E5%88%B0AST/"},{"title":"AST transform","text":"将已生成的 AST 转为 js AST 并且进行优化，baseCompile transform Transform123456789101112131415161718192021function baseCompile(template, options) { const isModuleMode = options.mode === &quot;module&quot;; // 用来标记代码生成模式 const prefixIdentifiers = !__BROWSER__ &amp;&amp; (options.prefixIdentifiers === true || isModuleMode); // 获取节点和指令转换的方法 const [nodeTransforms, directiveTransforms] = getBaseTransformPreset(); // AST 转换成 Javascript AST transform( ast, extend({}, options, { prefixIdentifiers, nodeTransforms: [...nodeTransforms, ...(options.nodeTransforms || [])], directiveTransforms: extend( {}, directiveTransforms, options.directiveTransforms || {} ), }) );} 其中第一个参数 prefixIdentifiers 是用于标记前缀代码生成模式的。示例： 1&lt;div&gt;{{msg}}&lt;/div&gt; 在 module 模式下，生成的渲染函数是一个通过 with(_ctx) { ... } 包裹后的，大致为： 123456789return function render(_ctx) { with (_ctx) { const { toDisplayString, openBlock, createElementBlock } = Vue; return ( openBlock(), createElementBlock(&quot;div&quot;, null, toDisplayString(msg), 1 /* TEXT */) ); }}; 而在 function 模式下，生成的渲染函数中的动态内容，则会被转成 _ctx.msg 的模式： 1234567import { toDisplayString, openBlock, createElementBlock } from &quot;vue&quot;;export function render(_ctx) { return ( openBlock(), createElementBlock(&quot;div&quot;, null, toDisplayString(ctx.msg), 1 /* TEXT */) );} 而参数 nodeTransforms 和 directiveTransforms 对象则是由 getBaseTransformPreset 生成的一系列预设函数： 12345678910111213141516171819function getBaseTransformPreset(prefixIdentifiers) { return [ [ transformOnce, transformIf, transformFor, transformExpression, transformSlotOutlet, transformElement, trackSlotScopes, transformText, ], { on: transformOn, bind: transformBind, model: transformModel, }, ];} nodeTransforms 涵盖了特殊节点的转换函数，比如文本节点、v-if 节点等等， directiveTransforms 则包含了一些指令的转换函数。 12345678910111213141516171819202122export function transform(root, options) { // 生成 transform 上下文 const context = createTransformContext(root, options); // 遍历处理 ast 节点 traverseNode(root, context); // 静态提升 if (options.hoistStatic) { hoistStatic(root, context); } // 创建根代码生成节点 if (!options.ssr) { createRootCodegen(root, context); } // 最终确定元信息 root.helpers = [...context.helpers.keys()]; root.components = [...context.components]; root.directives = [...context.directives]; root.imports = context.imports; root.hoists = context.hoists; root.temps = context.temps; root.cached = context.cached;} 1. 生成 transform 上下文开始 transform 前，需要创建生成一个 transformContext，即 transform 上下文。 12345678910111213141516171819202122232425262728293031export function createTransformContext(root, TransformOptions) { const context = { // 选项配置 hoistStatic, cacheHandlers, nodeTransforms, directiveTransforms, transformHoist, // ... // 状态数据 root, helpers: new Map(), components: new Set(), directives: new Set(), hoists: [], // .... // 一些函数 helper(name) {}, removeHelper(name) {}, helperString(name) {}, replaceNode(node) {}, removeNode(node) {}, onNodeRemoved: () =&gt; {}, addIdentifiers(exp) {}, removeIdentifiers(exp) {}, hoist(exp) {}, cache(exp, isVNode = false) {}, }; return context;} 上下文对象 context 内主要包含三部分：tansform 过程中的一些配置属性，一些状态数据，以及在 transform 过程中可能会调用的一些辅助函数。 2. 遍历 AST 节点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859export function traverseNode(node, context) { context.currentNode = node; // 节点转换函数 const { nodeTransforms } = context; const exitFns = []; for (let i = 0; i &lt; nodeTransforms.length; i++) { // 执行节点转换函数，返回得到一个退出函数 const onExit = nodeTransforms[i](node, context); // 收集所有退出函数 if (onExit) { if (isArray(onExit)) { exitFns.push(...onExit); } else { exitFns.push(onExit); } } if (!context.currentNode) { // 节点被移除 return; } else { node = context.currentNode; } } switch (node.type) { case NodeTypes.COMMENT: if (!context.ssr) { // context 中 helpers 添加 CREATE_COMMENT 辅助函数 context.helper(CREATE_COMMENT); } break; case NodeTypes.INTERPOLATION: // context 中 helpers 添加 TO_DISPLAY_STRING 辅助函数 if (!context.ssr) { context.helper(TO_DISPLAY_STRING); } break; case NodeTypes.IF: // 递归遍历每个分支节点 for (let i = 0; i &lt; node.branches.length; i++) { traverseNode(node.branches[i], context); } break; case NodeTypes.IF_BRANCH: case NodeTypes.FOR: case NodeTypes.ELEMENT: case NodeTypes.ROOT: // 遍历子节点 traverseChildren(node, context); break; } context.currentNode = node; // 执行上面收集到的所有退出函数 let i = exitFns.length; while (i--) { exitFns[i](); }} traverseNode 递归的遍历 ast 中的每个节点，然后执行一些转换函数 nodeTransforms，这些转换函数就是通过 getBaseTransformPreset 生成的对象，nodeTransforms 返回的是一个数组，说明这些转换函数是有序的，顺序代表着优先级关系，比如对于if的处理优先级就比 for 要高，因为如果条件不满足很可能有大部分内容都没必要进行转换。 另外，如果转换函数执行完成后，有返回退出函数 onExit 的话，那么会被统一存贮到 exitFns 当中，在所有字节点处理完成统一执行调用。 transformElement基于对transformElement进行分析，理解对AST的转化过程： 12345678910111213141516171819export const transformElement = (node, context) =&gt; { // 这里就是返回了一个退出函数 return function postTransformElement() { // ... node.codegenNode = createVNodeCall( context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false /* disableTracking */, isComponent, node.loc ); };}; transformElement 的核心目的就是通过调用createVNodeCall函数获取 VNodeCall 对象，并赋值给 node.codegenNode。 把 AST 转成 JavaScript AST，实际上就是给 AST 的codegenNode 属性赋值。 12345678910111213141516171819202122232425262728293031323334353637function createVNodeCall( context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, loc = locStub) { if (context) { if (isBlock) { context.helper(OPEN_BLOCK); context.helper(getVNodeBlockHelper(context.inSSR, isComponent)); } else { context.helper(getVNodeHelper(context.inSSR, isComponent)); } if (directives) { context.helper(WITH_DIRECTIVES); } } return { type: NodeTypes.VNODE_CALL, tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking, loc, };} createVNodeCall本质就是为了返回一个 VNodeCall 对象，该对象是用来描述 js 代码的。 这里的函数 context.helper 是会把一些 Symbol 对象添加到 context.helpers Set 的数据结构当中，在接下来的代码生成阶段，会判断当前 JS AST 中是否存在 helpers 内容，如果存在，则会根据 helpers 中标记的 Symbol 对象，来生成辅助函数。 demo： 1234&lt;template&gt; &lt;!-- 这是一段注释 --&gt; &lt;p&gt;{{ msg }}&lt;/p&gt;&lt;/template&gt; 经过遍历AST节点 traverseNode 函数调用之后之后的结果大致如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859{ &quot;type&quot;: 0, &quot;children&quot;: [ { &quot;type&quot;: 1, &quot;ns&quot;: 0, &quot;tag&quot;: &quot;p&quot;, &quot;tagType&quot;: 0, &quot;props&quot;: [], &quot;isSelfClosing&quot;: false, &quot;children&quot;: [], &quot;loc&quot;: {}, &quot;codegenNode&quot;: { &quot;type&quot;: 13, &quot;tag&quot;: &quot;\\&quot;p\\&quot;&quot;, &quot;children&quot;: { &quot;type&quot;: 5, &quot;content&quot;: { &quot;type&quot;: 4, &quot;isStatic&quot;: false, &quot;constType&quot;: 0, &quot;content&quot;: &quot;msg&quot;, &quot;loc&quot;: { &quot;start&quot;: {}, &quot;end&quot;: {}, &quot;source&quot;: &quot;msg&quot; } }, &quot;loc&quot;: { &quot;start&quot;: {}, &quot;end&quot;: {}, &quot;source&quot;: &quot;{{ msg }}&quot; } }, &quot;patchFlag&quot;: &quot;1 /* TEXT */&quot;, &quot;isBlock&quot;: false, &quot;disableTracking&quot;: false, &quot;isComponent&quot;: false, &quot;loc&quot;: { &quot;start&quot;: {}, &quot;end&quot;: {}, &quot;source&quot;: &quot;&lt;p&gt;{{ msg }}&lt;/p&gt;&quot; } } } ], &quot;helpers&quot;: [], &quot;components&quot;: [], &quot;directives&quot;: [], &quot;hoists&quot;: [], &quot;imports&quot;: [], &quot;cached&quot;: 0, &quot;temps&quot;: 0, &quot;loc&quot;: { &quot;start&quot;: {}, &quot;end&quot;: {}, &quot;source&quot;: &quot;\\n &lt;p&gt;{{ msg }}&lt;/p&gt;\\n&quot; }} 相比原节点，转换后的节点无论是在语义化还是在信息上，都更加丰富，可以依据它在代码生成阶段生成所需的代码。 3. 静态提升12345678export function hoistStatic(root, context) { walk( root, context, // 根节点是不可提升的 isSingleElementRoot(root, root.children[0]) );} hoistStatic 核心调用的就是 walk 函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889function walk(node, context, doNotHoistNode = false) { const { children } = node // 记录那些被静态提升的节点数量 let hoistedCount = 0 for (let i = 0; i &lt; children.length; i++) { const child = children[i] // 普通元素节点可以被提升 if ( child.type === NodeTypes.ELEMENT &amp;&amp; child.tagType === ElementTypes.ELEMENT ) { // 根据 doNotHoistNode 判断是否可以提升 // 设置 constantType 的值 const constantType = doNotHoistNode ? ConstantTypes.NOT_CONSTANT : getConstantType(child, context) // constantType = CAN_SKIP_PATCH || CAN_HOIST || CAN_STRINGIFY if (constantType &gt; ConstantTypes.NOT_CONSTANT) { // constantType = CAN_HOIST || CAN_STRINGIFY if (constantType &gt;= ConstantTypes.CAN_HOIST) { // 可提升状态中，codegenNode = PatchFlags.HOISTED child.codegenNode.patchFlag = PatchFlags.HOISTED + (__DEV__ ? ` /* HOISTED */` : ``) // 提升节点，将节点存储到 转换上下文context 的 hoist 数组中 child.codegenNode = context.hoist(child.codegenNode!) // 提升节点数量自增 1 hoistedCount++ continue } } else { // 动态子节点可能存在一些静态可提升的属性 const codegenNode = child.codegenNode! if (codegenNode.type === NodeTypes.VNODE_CALL) { // 判断 props 是否可提升 const flag = getPatchFlag(codegenNode) if ( (!flag || flag === PatchFlags.NEED_PATCH || flag === PatchFlags.TEXT) &amp;&amp; getGeneratedPropsConstantType(child, context) &gt;= ConstantTypes.CAN_HOIST ) { // 提升 props const props = getNodeProps(child) if (props) { codegenNode.props = context.hoist(props) } } // 将节点的动态 props 添加到转换上下文对象中 if (codegenNode.dynamicProps) { codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps) } } } } if (child.type === NodeTypes.ELEMENT) { // 组件是 slot 的情况 const isComponent = child.tagType === ElementTypes.COMPONENT if (isComponent) { context.scopes.vSlot++ } // 如果节点类型是组件，则进行递归判断操作 walk(child, context) if (isComponent) { context.scopes.vSlot-- } } else if (child.type === NodeTypes.FOR) { // 再循环节点中，只有一个子节点的情况下，不需要提升 walk(child, context, child.children.length === 1) } else if (child.type === NodeTypes.IF) { for (let i = 0; i &lt; child.branches.length; i++) { // 在 v-if 这样的条件节点上，如果也只有一个分支逻辑的情况 walk( child.branches[i], context, child.branches[i].children.length === 1 ) } } } // 预字符串化 if (hoistedCount &amp;&amp; context.transformHoist) { context.transformHoist(children, context, node) } // ...} 通过 walk 这个递归函数，不断的判断节点是否符合可以静态提升的条件：只有普通的元素节点是可以提升的。 如果满足条件，则会给节点的 codegenNode 属性中的 patchFlag 的值设置成 PatchFlags.HOISTED。 接着执行转换器上下文中的 context.hoist 方法： 123456789101112function hoist(exp) { // 存储到 hoists 数组中 context.hoists.push(exp); const identifier = createSimpleExpression( `_hoisted_${context.hoists.length}`, false, exp.loc, true ); identifier.hoisted = exp; return identifier;} 该函数的作用就是将这个可以被提升的节点存储到转换上下文 context 的 hoist 数组中。这个数据就是用来存储那些可被提升节点的列表。 123&lt;div&gt; &lt;p&gt;text&lt;/p&gt;&lt;/div&gt; 在没有被提升的情况下其渲染函数相当于： 123456789101112import { createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock,} from &quot;vue&quot;;export function render(_ctx, _cache, $props, $setup, $data, $options) { return ( _openBlock(), _createElementBlock(&quot;div&quot;, null, [_createElementVNode(&quot;p&quot;, null, &quot;text&quot;)]) );} p 标签是静态的，不会改变。但是如上渲染函数的问题也很明显，如果组件内存在动态的内容，当渲染函数重新执行时，即使 p 标签是静态的，那么它对应的 VNode 也会重新创建。 所谓的 “静态提升”，就是将一些静态的节点或属性提升到渲染函数之外 。如下： 1234567891011121314151617import { createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock,} from &quot;vue&quot;;const _hoisted_1 = /*#__PURE__*/ _createElementVNode( &quot;p&quot;, null, &quot;text&quot;, -1 /* HOISTED */);const _hoisted_2 = [_hoisted_1];export function render(_ctx, _cache, $props, $setup, $data, $options) { return _openBlock(), _createElementBlock(&quot;div&quot;, null, _hoisted_2);} 这就实现了减少 VNode 创建的性能消耗。 而这里的静态提升步骤生成的 hoists，会在 codegenNode 会在生成代码阶段帮助生成静态提升的相关代码。 预字符串化示例： 12345&lt;template&gt; &lt;p&gt;&lt;/p&gt; ... 共 20+ 节点 &lt;p&gt;&lt;/p&gt;&lt;/template&gt; 对于这样有大量静态提升的模版场景，如果不考虑 预字符串化 那么生成的渲染函数将会包含大量的 createElementVNode 函数：假设如上模板中有大量连续的静态的 p 标签，此时渲染函数生成的结果如下： 123456789101112const _hoisted_1 = /*#__PURE__*/_createElementVNode(&quot;p&quot;, null, null, -1 /* HOISTED */)// ...const _hoisted_20 = /*#__PURE__*/_createElementVNode(&quot;p&quot;, null, null, -1 /* HOISTED */)const _hoisted_21 = [ _hoisted_1, // ... _hoisted_20,]export function render(_ctx, _cache, $props, $setup, $data, $options) { return (_openBlock(), _createElementBlock(&quot;div&quot;, null, _hoisted_21))} createElementVNode 大量连续性创建 vnode 也是挺影响性能的，所以可以通过 预字符串化 来一次性创建这些静态节点，采用 与字符串化 后，生成的渲染函数如下： 123456const _hoisted_1 = /*#__PURE__*/ _createStaticVNode(&quot;&lt;p&gt;&lt;/p&gt;...&lt;p&gt;&lt;/p&gt;&quot;, 20);const _hoisted_21 = [_hoisted_1];export function render(_ctx, _cache, $props, $setup, $data, $options) { return _openBlock(), _createElementBlock(&quot;div&quot;, null, _hoisted_21);} 这样一方面降低了 createElementVNode 连续创建带来的性能损耗，也降侧面减少了代码体积。 4. 创建根代码生成节点123456789101112131415161718192021222324252627282930313233343536function createRootCodegen(root, context) { const { helper } = context; const { children } = root; if (children.length === 1) { const child = children[0]; // 如果子节点是单个元素节点，则将其转换成一个 block if (isSingleElementRoot(root, child) &amp;&amp; child.codegenNode) { const codegenNode = child.codegenNode; if (codegenNode.type === NodeTypes.VNODE_CALL) { makeBlock(codegenNode, context); } root.codegenNode = codegenNode; } else { root.codegenNode = child; } } else if (children.length &gt; 1) { // 如果子节点是多个节点，则返回一个 fragement 的代码生成节点 let patchFlag = PatchFlags.STABLE_FRAGMENT; let patchFlagText = PatchFlagNames[PatchFlags.STABLE_FRAGMENT]; root.codegenNode = createVNodeCall( context, helper(FRAGMENT), undefined, root.children, patchFlag + (__DEV__ ? ` /* ${patchFlagText} */` : ``), undefined, undefined, true, undefined, false /* isComponent */ ); } else { // no children = noop. codegen will return null. }} Vue3 中是可以在 template 中写多个字节点的： 1234&lt;template&gt; &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt;&lt;/template&gt; createRootCodegen，核心就是创建根节点的 codegenNode 对象。所以当有多个子节点时，也就是 children.length &gt; 1 时，调用 createVNodeCall 来创建一个新的 fragement 根节点 codegenNode。 否则，就代表着只有一个根节点，直接让根节点的 codegenNode 等于第一个子节点的根节点的codegenNode即可。 createRootCodegen 完成之后，接着把 transform 上下文在转换 AST 节点过程中创建的一些变量赋值给 root 节点对应的属性，这样方便在后续代码生成的过程中访问到这些变量。 1234567root.helpers = [...context.helpers.keys()];root.components = [...context.components];root.directives = [...context.directives];root.imports = context.imports;root.hoists = context.hoists;root.temps = context.temps;root.cached = context.cached;","link":"/2023/08/05/vue/%E7%BC%96%E8%AF%91%E5%99%A8/transform/"},{"title":"generate","text":"代码生成器，baseCompile generate 使用 123456generate( ast, extend({}, options, { prefixIdentifiers, })); 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102export function generate(ast, options = {}) { // 创建代码生成上下文 const context = createCodegenContext(ast, options) const { mode, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context const hasHelpers = ast.helpers.length &gt; 0 const useWithBlock = !prefixIdentifiers &amp;&amp; mode !== 'module' const genScopeId = !__BROWSER__ &amp;&amp; scopeId != null &amp;&amp; mode === 'module' const isSetupInlined = !__BROWSER__ &amp;&amp; !!options.inline // 生成预设代码 const preambleContext = isSetupInlined ? createCodegenContext(ast, options) : context // 不在浏览器的环境且 mode 是 module if (!__BROWSER__ &amp;&amp; mode === 'module') { genModulePreamble(ast, preambleContext, genScopeId, isSetupInlined) } else { genFunctionPreamble(ast, preambleContext) } // 进入 render 函数构造 const functionName = `render` const args = ['_ctx', '_cache'] const signature = args.join(', ') push(`function ${functionName}(${signature}) {`) indent() if (useWithBlock) { // 处理带 with 的情况，Web 端运行时编译 push(`with (_ctx) {`) indent() if (hasHelpers) { push(`const { ${ast.helpers.map(aliasHelper).join(', ')} } = _Vue`) push(`\\n`) newline() } } // 生成自定义组件声明代码 if (ast.components.length) { genAssets(ast.components, 'component', context) if (ast.directives.length || ast.temps &gt; 0) { newline() } } // 生成自定义指令声明代码 if (ast.directives.length) { genAssets(ast.directives, 'directive', context) if (ast.temps &gt; 0) { newline() } } // 生成临时变量代码 if (ast.temps &gt; 0) { push(`let `) for (let i = 0; i &lt; ast.temps; i++) { push(`${i &gt; 0 ? `, ` : ``}_temp${i}`) } } if (ast.components.length || ast.directives.length || ast.temps) { push(`\\n`) newline() } if (!ssr) { push(`return `) } // 生成创建 VNode 树的表达式 if (ast.codegenNode) { genNode(ast.codegenNode, context) } else { push(`null`) } if (useWithBlock) { deindent() push(`}`) } deindent() push(`}`) return { ast, code: context.code, preamble: isSetupInlined ? preambleContext.code : ``, map: context.map ? (context.map as any).toJSON() : undefined }} generate ：接收两个参数，分别是经过转换器处理的 ast 抽象语法树，以及 options 代码生成选项。最终返回一个 CodegenResult 类型的对象： 123456return { ast, // 抽象语法树 code, // render 函数代码字符串 preamble, // 代码字符串的前置部分 map, //可选的 sourceMap}; 1. 创建代码生成上下文generate 函数的第一步是通过 createCodegenContext 来创建 CodegenContext 上下文对象： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function createCodegenContext( ast, { mode = &quot;function&quot;, prefixIdentifiers = mode === &quot;module&quot;, sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeBindings = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssr = false, }) { const context = { mode, prefixIdentifiers, sourceMap, filename, scopeId, optimizeBindings, runtimeGlobalName, runtimeModuleName, ssr, source: ast.loc.source, code: ``, column: 1, line: 1, offset: 0, indentLevel: 0, pure: false, map: undefined, helper(key) { return `_${helperNameMap[key]}`; }, push(code) { context.code += code; // ... 省略 非浏览器环境下的 addMapping }, indent() { newline(++context.indentLevel); }, deindent(withoutNewLine = false) { if (withoutNewLine) { --context.indentLevel; } else { newline(--context.indentLevel); } }, newline() { newline(context.indentLevel); }, }; function newline(n) { context.push(&quot;\\n&quot; + ` `.repeat(n)); } return context;} createCodegenContext 创建的 context 中，核心维护了一些基础配置变量和一些工具函数： push：该函数的功能是将传入的字符串拼接入上下文中的 code 属性中。并且会生成对应的 sourceMap。 indent: 作用是缩进 deindent: 回退缩进 newline: 插入新的一行 其中，index、deindent、newline 是用来辅助生成的代码字符串，用来格式化结构，让生成的代码字符串非常直观，就像在 ide 中敲入的制表符、换行、格式化代码块一样。 在创建上下文变量完成后，接着进入生成预设代码的流程： 2. 生成预设代码12345678// 不在浏览器的环境且 mode 是 moduleif (!__BROWSER__ &amp;&amp; mode === &quot;module&quot;) { // 使用 ES module 标准的 import 来导入 helper 的辅助函数，处理生成代码的前置部分 genModulePreamble(ast, preambleContext, genScopeId, isSetupInlined);} else { // 否则生成的代码前置部分是一个单一的 const { helpers... } = Vue 处理代码前置部分 genFunctionPreamble(ast, preambleContext);} mode 有两个选项: module: 会通过 ES module 的 import 来导入 ast 中的 helpers 辅助函数，并用 export 默认导出 render 函数。 function 时，就会生成一个单一的 const { helpers... } = Vue 声明，并且 return 返回 render 函数。 genModulePreamble实现： 12345678910111213141516171819202122232425262728293031323334353637383940function genModulePreamble(ast, context, genScopeId, inline) { const { push, newline, optimizeImports, runtimeModuleName, ssrRuntimeModuleName, } = context; // ... if (ast.helpers.length) { if (optimizeImports) { // 生成 import 声明代码 push( `import { ${ast.helpers .map((s) =&gt; helperNameMap[s]) .join(&quot;, &quot;)} } from ${JSON.stringify(runtimeModuleName)}\\n` ); push( `\\n// Binding optimization for webpack code-split\\nconst ${ast.helpers .map((s) =&gt; `_${helperNameMap[s]} = ${helperNameMap[s]}`) .join(&quot;, &quot;)}\\n` ); } else { push( `import { ${ast.helpers .map((s) =&gt; `${helperNameMap[s]} as _${helperNameMap[s]}`) .join(&quot;, &quot;)} } from ${JSON.stringify(runtimeModuleName)}\\n` ); } } // 提升静态节点 genHoists(ast.hoists, context); newline(); if (!inline) { push(`export `); }} 其中 ast.helpers 是在 transform 阶段通过 context.helper 方法添加的，值如下： 12345678[ Symbol(resolveComponent), Symbol(createVNode), Symbol(createCommentVNode), Symbol(toDisplayString), Symbol(openBlock), Symbol(createBlock),]; 所以这一步结束后，得到的代码为 1234567import { createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock,} from &quot;vue&quot;; 然后执行 genHoists ： 123456789101112131415161718function genHoists(hoists, context) { if (!hoists.length) { return; } context.pure = true; const { push, newline } = context; newline(); hoists.forEach((exp, i) =&gt; { if (exp) { push(`const _hoisted_${i + 1} = `); genNode(exp, context); newline(); } }); context.pure = false;} 核心功能就是遍历 ast.hoists 数组，该数组是在 transfrom 的时候构造的，然后生成静态提升变量定义的方法。在进行 hoists 数组遍历的时候，这里有个 geNode 函数，是用来生成节点的创建字符串的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function genNode(node, context) { if (isString(node)) { context.push(node) return } if (isSymbol(node)) { context.push(context.helper(node)) return } // 根据 node 节点类型不同，调用不同的生成函数 switch (node.type) { case NodeTypes.ELEMENT: case NodeTypes.IF: case NodeTypes.FOR: genNode(node.codegenNode!, context) break case NodeTypes.TEXT: genText(node, context) break case NodeTypes.SIMPLE_EXPRESSION: genExpression(node, context) break case NodeTypes.INTERPOLATION: genInterpolation(node, context) break case NodeTypes.TEXT_CALL: genNode(node.codegenNode, context) break case NodeTypes.COMPOUND_EXPRESSION: genCompoundExpression(node, context) break case NodeTypes.COMMENT: genComment(node, context) break case NodeTypes.VNODE_CALL: genVNodeCall(node, context) break case NodeTypes.JS_CALL_EXPRESSION: genCallExpression(node, context) break case NodeTypes.JS_OBJECT_EXPRESSION: genObjectExpression(node, context) break case NodeTypes.JS_ARRAY_EXPRESSION: genArrayExpression(node, context) break case NodeTypes.JS_FUNCTION_EXPRESSION: genFunctionExpression(node, context) break case NodeTypes.JS_CONDITIONAL_EXPRESSION: genConditionalExpression(node, context) break case NodeTypes.JS_CACHE_EXPRESSION: genCacheExpression(node, context) break case NodeTypes.JS_BLOCK_STATEMENT: genNodeList(node.body, context, true, false) break /* istanbul ignore next */ case NodeTypes.IF_BRANCH: // noop break default: }} 1234&lt;template&gt; &lt;p&gt;hello world&lt;/p&gt; &lt;p&gt;{{ msg }}&lt;/p&gt;&lt;/template&gt; 经过 transform 后得到的 AST 内容大致如下： 其中 hoists 内容中存储的是 &lt;p&gt;hello world&lt;/p&gt; 节点的信息，其中 type = 13 表示的是 VNODE_CALL 类型，进入 genVNodeCall 函数中： 12345678910111213141516171819202122232425262728293031323334353637383940function genVNodeCall(node, context) { const { push, helper, pure } = context; const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking, isComponent, } = node; if (directives) { push(helper(WITH_DIRECTIVES) + `(`); } if (isBlock) { push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `); } if (pure) { push(PURE_ANNOTATION); } const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent) : getVNodeHelper(context.inSSR, isComponent); push(helper(callHelper) + `(`, node); genNodeList( genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context ); push(`)`); if (isBlock) { push(`)`); } if (directives) { push(`, `); genNode(directives, context); push(`)`); }} 在执行 genVNodeCall 函数时，因为 directives 不存在，isBlock = false 此时生成的代码内容如下 1234567891011121314import { createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock,} from &quot;vue&quot;;const _hoisted_1 = /*#__PURE__*/ _createElementVNode( &quot;p&quot;, null, &quot;hello world&quot;, -1 /* HOISTED */); genModulePreamble 函数的最后，执行 push('export') 完成 genModulePreamble 的所有逻辑，得到以下内容： 12345import { createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from &quot;vue&quot;const _hoisted_1 = /*#__PURE__*/_createElementVNode(&quot;p&quot;, null, &quot;hello world&quot;, -1 /* HOISTED */)export genFunctionPreamble的功能和 genModulePreamble 类似，生成的结果： 1234567891011const _Vue = Vue;const { createElementVNode: _createElementVNode } = _Vue;const _hoisted_1 = /*#__PURE__*/ _createElementVNode( &quot;p&quot;, null, &quot;hello world&quot;, -1 /* HOISTED */);return; 要注意以上代码仅仅是代码前置部分，还没有开始解析其他资源和节点，所以仅仅是到了 export 或者 return 就结束了。 2. 生成渲染函数123456789// 进入 render 函数构造const functionName = `render`;const args = [&quot;_ctx&quot;, &quot;_cache&quot;];const signature = args.join(&quot;, &quot;);push(`function ${functionName}(${signature}) {`);indent(); 通过 push 函数，继续生成 code 字符串，然后代码字符串变成的内容： 12345import { createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from &quot;vue&quot;const _hoisted_1 = /*#__PURE__*/_createElementVNode(&quot;p&quot;, null, &quot;hello world&quot;, -1 /* HOISTED */)export function render(_ctx, _cache) { 这里就是生成 render 函数的主题内容代码，先忽略对 components、directives、temps 代码块的生成。 transform 在处理节点内容时，会生成 codegenNode 对象，这个对象就是在这里被使用转换成代码字符串的： 12345if (ast.codegenNode) { genNode(ast.codegenNode, context);} else { push(`null`);} 上面的例子中，生产的模版节点的 codegenNode 内容如下： 其中 type = 13 表示的是 VNODE_CALL 类型，也进入 genVNodeCall 函数中，因为 template 下包含了 2 个同级的标签，所以在 transform 阶段会创建一个 patchFlag = STABLE_FRAGMENT 这样一个根 fragment 的 ast 节点来包含 2 个 p 标签节点。 针对上面的示例，directives 没有，isBlock 是 true。那么经过 genVNodeCall 后生成的代码如下： 123456789import { createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from &quot;vue&quot;const _hoisted_1 = /*#__PURE__*/_createElementVNode(&quot;p&quot;, null, &quot;hello world&quot;, -1 /* HOISTED */)export function render(_ctx, _cache) { return (_openBlock(), _createElementBlock(_Fragment, null, [ _hoisted_1, _createElementVNode(&quot;p&quot;, null, _toDisplayString(msg), 1 /* TEXT */) ], 64 /* STABLE_FRAGMENT */)) 至此，根节点 vnode 树的表达式就创建好了。回到 generate 函数，generate 函数的最后就是添加右括号 } 来闭合渲染函数，最终生成如下代码： 1234567891011121314151617181920212223242526272829import { createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock,} from &quot;vue&quot;;const _hoisted_1 = /*#__PURE__*/ _createElementVNode( &quot;p&quot;, null, &quot;hello world&quot;, -1 /* HOISTED */);export function render(_ctx, _cache) { return ( _openBlock(), _createElementBlock( _Fragment, null, [ _hoisted_1, _createElementVNode(&quot;p&quot;, null, _toDisplayString(msg), 1 /* TEXT */), ], 64 /* STABLE_FRAGMENT */ ) );} generate 是 compile 阶段的最后一步，作用是将 transform 转换后的 AST 生成对应的可执行代码，从而在之后 Runtime 的 Render 阶段时，就可以通过可执行代码生成对应的 VNode Tree，然后最终映射为真实的 DOM Tree 在页面上。","link":"/2023/08/05/vue/%E7%BC%96%E8%AF%91%E5%99%A8/generate/"},{"title":"编译优化","text":"编译优化 示例： 1234&lt;template&gt; &lt;p&gt;hello world&lt;/p&gt; &lt;p&gt;{{ msg }}&lt;/p&gt; &lt;/template&gt;&gt; 其中一个 p 标签的节点是一个静态的节点，第二个 p 标签的节点是一个动态的节点，如果当 msg 的值发生了变化，那么理论上肉眼可见最优的更新方案应该是只做第二个动态节点的 diff，而无需进行第一个 p 标签节点的 diff。 PatchFlagsPatchFlags 是一个枚举类型，里面是一些二进制操作的值，用来标记在节点的 patch 类型。具体的枚举内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940export const enum PatchFlags { // 动态文本的元素 TEXT = 1, // 动态 class 的元素 CLASS = 1 &lt;&lt; 1, // 动态 style 的元素 STYLE = 1 &lt;&lt; 2, // 动态 props 的元素 PROPS = 1 &lt;&lt; 3, // 动态 props 和有 key 值绑定的元素 FULL_PROPS = 1 &lt;&lt; 4, // 有事件绑定的元素 HYDRATE_EVENTS = 1 &lt;&lt; 5, // children 顺序确定的 fragment STABLE_FRAGMENT = 1 &lt;&lt; 6, // children 中有带有 key 的节点的 fragment KEYED_FRAGMENT = 1 &lt;&lt; 7, // 没有 key 的 children 的 fragment UNKEYED_FRAGMENT = 1 &lt;&lt; 8, // 带有 ref、指令的元素 NEED_PATCH = 1 &lt;&lt; 9, // 动态的插槽 DYNAMIC_SLOTS = 1 &lt;&lt; 10, // 静态节点 HOISTED = -1, // 不是 render 函数生成的元素，如 renderSlot BAIL = -2,} 123TEXT = 0000000001;CLASS = 0000000010;STYLE = 0000000100; 这里通过二进制来表示 PatchFlags 可以方便做很多属性的判断，比如 TEXT | STYLE 来得到 0000000101，表示 patchFlag 既有 TEXT 属性也有 STYLE 属性，当需要进行判断有没有 STYLE 属性时，只需要 FLAG &amp; STYLE &gt; 0就行。 生成时机模板字符串在 compiler 阶段会被转成一个 render 函数的字符串代码： 1234567891011121314151617181920212223242526272829import { createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock,} from &quot;vue&quot;;const _hoisted_1 = /*#__PURE__*/ _createElementVNode( &quot;p&quot;, null, &quot;hello world&quot;, -1 /* HOISTED */);export function render(_ctx, _cache) { return ( _openBlock(), _createElementBlock( _Fragment, null, [ _hoisted_1, _createElementVNode(&quot;p&quot;, null, _toDisplayString(msg), 1 /* TEXT */), ], 64 /* STABLE_FRAGMENT */ ) );} render 函数内是通过 createElementVNode 方法来创建 vnode 的，该函数的第四个参数就代表着 patchFlag。对于上面的示例，其中 &lt;p&gt;hello world&lt;/p&gt; 是 hoisted，对应的 patchFlag = -1，&lt;p&gt;{{ msg }}&lt;/p&gt; 是动态文字节点，对应的 patchFlag = 1。 patchElement作用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) =&gt; { let { patchFlag, dynamicChildren, dirs } = n2 // 如果 patchFlag 不存在，那么就设置成 FULL_PROPS，意味着要全量 props 比对 patchFlag |= n1.patchFlag &amp; PatchFlags.FULL_PROPS const oldProps = n1.props || EMPTY_OBJ const newProps = n2.props || EMPTY_OBJ const areChildrenSVG = isSVG &amp;&amp; n2.type !== 'foreignObject' if (dynamicChildren) { patchBlockChildren( n1.dynamicChildren!, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds ) } else if (!optimized) { // full diff patchChildren( n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false ) } if (patchFlag &gt; 0) { if (patchFlag &amp; PatchFlags.FULL_PROPS) { // 如果元素的 props 中含有动态的 key，则需要全量比较 patchProps( el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG ) } else { // class if (patchFlag &amp; PatchFlags.CLASS) { if (oldProps.class !== newProps.class) { hostPatchProp(el, 'class', null, newProps.class, isSVG) } } // style if (patchFlag &amp; PatchFlags.STYLE) { hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG) } // props if (patchFlag &amp; PatchFlags.PROPS) { const propsToUpdate = n2.dynamicProps! for (let i = 0; i &lt; propsToUpdate.length; i++) { const key = propsToUpdate[i] const prev = oldProps[key] const next = newProps[key] // #1471 force patch value if (next !== prev || key === 'value') { hostPatchProp( el, key, prev, next, isSVG, n1.children as VNode[], parentComponent, parentSuspense, unmountChildren ) } } } } // text if (patchFlag &amp; PatchFlags.TEXT) { if (n1.children !== n2.children) { hostSetElementText(el, n2.children as string) } } } else if (!optimized &amp;&amp; dynamicChildren == null) { patchProps( el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG ) }} 这里涉及到两个比较重点的事儿，一个是和 dynamicChildren 相关，另一个是和动态 props 相关。 Vue 在更新子节点时，首先也是利用 patchFlag 的能力，对子节点进行分类做出不同的处理，比如针对以下例子： 123&lt;template&gt; &lt;div :class=&quot;classNames&quot; id=&quot;test&quot;&gt;hello world&lt;/div&gt;&lt;/template&gt; 得到的编译结果： 1234567891011121314151617181920import { normalizeClass as _normalizeClass, openBlock as _openBlock, createElementBlock as _createElementBlock,} from &quot;vue&quot;;export function render(_ctx, _cache) { return ( _openBlock(), _createElementBlock( &quot;div&quot;, { class: _normalizeClass(classNames), id: &quot;test&quot;, }, &quot; hello world &quot;, 2 /* CLASS */ ) );} 此时 patchFlag &amp; PatchFlags.CLASS &gt; 0 则在 diff 过程中，需要进行 class 属性的 diff， 从而减少了对 id 属性的不必要 diff，提升了 props diff 过程中的性能。 dynamicChildren在编译后的 render 函数中会有一个 _openBlock() 函数的执行： 123456export const blockStack = [];export let currentBlock = null;export function openBlock(disableTracking = false) { blockStack.push((currentBlock = disableTracking ? null : []));} openBlock 实现比较通俗易懂，就是向 blockStack 中 push currentBlock。其中 currentBlock 是一个数组，用于存储动态节点。blockStack 则是存储 currentBlock 的一个 Block tree。 createElementBlock 实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758export function createElementBlock( type, props, children, patchFlag, dynamicProps, shapeFlag) { return setupBlock( createBaseVNode( type, props, children, patchFlag, dynamicProps, shapeFlag, true /* isBlock */ ) );}function createBaseVNode( type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : ShapeFlags.ELEMENT, isBlockNode = false, needFullChildrenNormalization = false) { // ... // 添加动态 vnode 节点到 currentBlock 中 if ( isBlockTreeEnabled &gt; 0 &amp;&amp; !isBlockNode &amp;&amp; currentBlock &amp;&amp; (vnode.patchFlag &gt; 0 || shapeFlag &amp; ShapeFlags.COMPONENT) &amp;&amp; vnode.patchFlag !== PatchFlags.HYDRATE_EVENTS ) { currentBlock.push(vnode); } return vnode;}function setupBlock(vnode) { // 在 vnode 上保留当前 Block 收集的动态子节点 vnode.dynamicChildren = isBlockTreeEnabled &gt; 0 ? currentBlock || EMPTY_ARR : null; // 当前 Block 恢复到父 Block closeBlock(); // 节点本身作为父 Block 收集的子节点 if (isBlockTreeEnabled &gt; 0 &amp;&amp; currentBlock) { currentBlock.push(vnode); } return vnode;} createElementBlock 内部首先通过 createBaseVNode 创建 vnode 节点，在创建的过程中，会根据 patchFlag 的值进行判断是否是动态节点，如果发现 vnode 是一个动态节点，那么会被添加到 currentBlock 当中，然后在执行 setupBlock 函数的时候，将 currentBlock 赋值给 vnode.dynamicChildren 属性。 patchElement 函数体内部会进行是否有 dynamicChildren 属性进行不同的逻辑执行，当 dynamicChildren 存在时，这里只会进行 patchBlockChildren 的动态节点 diff： 12345678910111213141516171819202122232425262728293031323334const patchBlockChildren = ( oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG) =&gt; { for (let i = 0; i &lt; newChildren.length; i++) { const oldVNode = oldChildren[i]; const newVNode = newChildren[i]; // 确定待更新节点的容器 const container = // 对于 Fragment，需要提供正确的父容器 oldVNode.type === Fragment || // 在不同节点的情况下，将有一个替换节点，也需要正确的父容器 !isSameVNodeType(oldVNode, newVNode) || // 组件的情况，也需要提供一个父容器 oldVNode.shapeFlag &amp; 6 /* COMPONENT */ ? hostParentNode(oldVNode.el) : // 在其他情况下，父容器实际上并没有被使用，所以这里只传递 Block 元素即可 fallbackContainer; patch( oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, true ); }}; patchBlockChildren 遍历新的动态子节点数组，拿到对应的新旧动态子节点，并执行 patch 更新子节点即可。 这样一来，更新的复杂度就变成和动态节点的数量正相关，而不与模板大小正相关。这也是 Vue 3 做的一个重要的编译时优化的一部分。 Demo:1234&lt;template&gt; &lt;p&gt;hello world&lt;/p&gt; &lt;p&gt;{{ msg }}&lt;/p&gt;&lt;/template&gt; 转成 vnode 后的结果大致为： 12345678910const vnode = { type: Symbol(Fragment), children: [ { type: &quot;p&quot;, children: &quot;hello world&quot; }, { type: &quot;p&quot;, children: ctx.msg, patchFlag: 1 /* 动态的 text */ }, ], dynamicChildren: [ { type: &quot;p&quot;, children: ctx.msg, patchFlag: 1 /* 动态的 text */ }, ],}; 此时组件内存在了一个静态的节点 &lt;p&gt;hello world&lt;/p&gt;，在传统的 diff 算法里，还是需要对该静态节点进行不必要的 diff。所以 Vue3 先通过 patchFlag 来标记动态节点 &lt;p&gt;{{ msg }}&lt;/p&gt;， 然后配合 dynamicChildren 将动态节点进行收集，从而完成在 diff 阶段只做靶向更新的目的。","link":"/2023/08/05/vue/%E7%BC%96%E8%AF%91%E5%99%A8/%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/"},{"title":"plugin高级","text":"plugin 开发高级介绍 日志处理与 Loader 相似，开发插件时也可以复用 Webpack 一系列日志基础设施，包括： 通过 compilation.getLogger 获取分级日志管理器； 使用 compilation.errors/wraning 处理异常信息。 使用分级日志基础设施 开发插件时，也能使用这一接口管理日志输出，只是用法稍有不同，如： 123456789101112131415const PLUGIN_NAME = &quot;FooPlugin&quot;;class FooPlugin { apply(compiler) { compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation) =&gt; { // 获取日志对象 const logger = compilation.getLogger(PLUGIN_NAME); // 调用分级日志接口 logger.log(&quot;Logging from FooPlugin&quot;); logger.error(&quot;Error from FooPlugin&quot;); }); }}module.exports = FooPlugin; 提示：此外，还可以通过 compiler.getInfrastructureLogger 获取日志对象。 上述代码需要调用 compilation.getLogger 获取日志对象 logger，logger 的用法与 Loader 场景相似，同样支持 verbose/log/info/warn/error 五种日志分级，此处不再赘述。 正确处理异常信息 在 Webpack 插件中，可以通过如下方式提交错误信息。 使用 logger.error/warning 接口，这种方法同样不会中断构建流程，且能够复用 Webpack 的分级日志体系，由最终用户决定是否输出对应等级日志。 借助 compilation.errors/warnings 数组，如： 123456789101112const PLUGIN_NAME = &quot;FooPlugin&quot;;class FooPlugin { apply(compiler) { compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation) =&gt; { compilation.errors.push(new Error(&quot;Emit Error From FooPlugin&quot;)); compilation.warnings.push(&quot;Emit Warning From FooPlugin&quot;); }); }}module.exports = FooPlugin; 执行效果： 这种方法仅记录异常日志，不影响构建流程，构建正常结束后 Webpack 还会将错误信息汇总到 stats 统计对象，方便后续二次处理，使用率极高。例如 eslint-webpack-plugin 就是通过这种方式输出 ESLint 检查出来的代码风格问题。 使用 Hook Callback，这种方式可将错误信息传递到 Hook 下一个流程，由 Hook 触发者根据错误内容决定后续处理措施(中断、忽略、记录日志等)，如 imagemin-webpack-plugin 中： 123456789101112131415161718export default class ImageminPlugin { apply(compiler) { const onEmit = async (compilation, callback) =&gt; { try { await Promise.all([ ...this.optimizeWebpackImages(throttle, compilation), ...this.optimizeExternalImages(throttle), ]); callback(); } catch (err) { // if at any point we hit a snag, pass the error on to webpack callback(err); } }; compiler.hooks.emit.tapAsync(this.constructor.name, onEmit); }} 上例第 13 行，在 catch 块中通过 callback 函数传递错误信息。不过，并不是所有 Hook 都会传递 callback 函数，实际开发时建议参考相关用例。 直接抛出异常，如： 1234567891011const PLUGIN_NAME = &quot;FooPlugin&quot;;class FooPlugin { apply(compiler) { compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation) =&gt; { throw new Error(&quot;Throw Error Directly&quot;); }); }}module.exports = FooPlugin; 这种方式会导致 Webpack 进程奔溃，多用于插件遇到严重错误，不得不提前中断构建工作的场景。 总的来说，这些方式各自有适用场景： 多数情况下使用 compilation.errors/warnings，柔和地抛出错误信息； 特殊场景，需要提前结束构建时，则直接抛出异常； 拿捏不准的时候，使用 callback 透传错误信息，交由上游调用者自行判断处理措施。 上报统计信息有时候需要在插件中执行一些特别耗时的操作，例如：抽取 CSS 代码（如 mini-css-extract-plugin）、压缩图片（如 image-minimizer-webpack-plugin）、代码混淆（如 terser-webpack-plugin），这些操作会延长 Webpack 构建的整体耗时，更糟糕的是会阻塞构建主流程，最终用户会感觉到明显卡顿。 针对这种情况，可以在插件中上报一些统计信息，帮助用户理解插件的运行进度与性能情况，有两种上报方式： 使用 ProgressPlugin 插件的 reportProgress 接口上报执行进度； 使用 stats 接口汇总插件运行的统计数据。 使用 reportProgress 接口 ProgressPlugin 是 Webpack 内置用于展示构建进度的插件，有两种用法： 简化版，执行构建命令时带上 --progress 参数，如： 1npx webpack --progress 也可以在 Webpack 配置文件中添加插件实例，如： 123456789101112131415const { ProgressPlugin } = require(&quot;webpack&quot;);module.exports = { //... plugins: [ new ProgressPlugin({ activeModules: false, entries: true, handler(percentage, message, ...args) { // custom logic }, //... }), ],}; 开发插件时，可以使用 ProgressPlugin 插件的 Reporter 方法提交自定义插件的运行进度，例如： 123456789101112131415161718192021222324252627const { ProgressPlugin } = require(&quot;webpack&quot;);const PLUGIN_NAME = &quot;BlockPlugin&quot;;const wait = (misec) =&gt; new Promise((r) =&gt; setTimeout(r, misec));const noop = () =&gt; ({});class BlockPlugin { apply(compiler) { compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation) =&gt; { compilation.hooks.processAssets.tapAsync( PLUGIN_NAME, async (assets, callback) =&gt; { const reportProgress = ProgressPlugin.getReporter(compiler) || noop; const len = 100; for (let i = 0; i &lt; len; i++) { await wait(50); reportProgress(i / 100, `Our plugin is working ${i}%`); } reportProgress(1, &quot;Done work!&quot;); await wait(1000); callback(); } ); }); }}module.exports = BlockPlugin; 示例中，最关键的代码在于第 12 行，即调用 ProgressPlugin.getReporter 方法获取 Reporter 函数，之后再用这个函数提交执行进度： 1const reportProgress = ProgressPlugin.getReporter(compiler) || noop; 注意：若最终用户没有使用 ProgressPlugin 插件，则这个函数会返回 Undefined，所以需要增加 || noop 兜底。 reportProgress 接受如下参数： 1reportProgress(percentage, ...args); percentage：当前执行进度百分比，但这个参数实际并不生效， ProgressPlugin 底层会根据当前处于那个 Hook 计算一个固定的 Progress 百分比值，在自定义插件中无法改变，所以目前来看这个参数值随便填就好； ...args：任意数量字符串参数，这些字符串会被拼接到 Progress 输出的信息。 最终执行效果： 通过 stats 添加统计信息 stats 是 Webpack 内置的数据统计机制，专门用于收集模块构建耗时、模块依赖关系、产物组成等过程信息，可以借此分析、优化应用构建性能。在开发插件时，可以借用 stats 机制，向用户输出插件各种维度的统计信息，例如： 123456789101112131415161718192021222324252627282930313233const PLUGIN_NAME = &quot;FooPlugin&quot;;class FooPlugin { apply(compiler) { compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation) =&gt; { const statsMap = new Map(); // buildModule 钩子将在开始处理模块时触发 compilation.hooks.buildModule.tap(PLUGIN_NAME, (module) =&gt; { const ident = module.identifier(); const startTime = Date.now(); // 模拟复杂耗时操作 // ... // ... const endTime = Date.now(); // 记录处理耗时 statsMap.set(ident, endTime - startTime); }); compilation.hooks.statsFactory.tap(PLUGIN_NAME, (factory) =&gt; { factory.hooks.result .for(&quot;module&quot;) .tap(PLUGIN_NAME, (module, context) =&gt; { const { identifier } = module; const duration = statsMap.get(identifier); // 添加统计信息 module.fooDuration = duration || 0; }); }); }); }}module.exports = FooPlugin; 再次执行 Webpack 构建命令，将产出如下 stats 统计信息： 12345678910111213141516171819202122232425262728293031{ &quot;hash&quot;: &quot;0a17278b49620a86b126&quot;, &quot;version&quot;: &quot;5.73.0&quot;, // ... &quot;modules&quot;: [ { &quot;type&quot;: &quot;module&quot;, &quot;identifier&quot;: &quot;/Users/tecvan/studio/webpack-book-samples/target-sample/src/index.js&quot;, &quot;fooDuration&quot;: 124 /*...*/ } /*...*/ /*...*/ /*...*/ ], &quot;assets&quot;: [ /*...*/ ], &quot;chunks&quot;: [ /*...*/ ], &quot;entrypoints&quot;: { /*...*/ }, &quot;namedChunkGroups&quot;: { /*...*/ }, &quot;errors&quot;: [ /*...*/ ]} 这种方式有许多优点： 用户可以直接通过 stats 了解插件的运行情况，不需要重复学习其它方式； 支持按需执行，用户可通过 stats 配置项控制； 支持导出为 JSON 或其它文件格式，方便后续接入自动化分析流程。 因此，若明确插件将执行非常重的计算任务，需要消耗比较长的构建时间时，可以通过这种方式上报关键性能数据，帮助用户做好性能分析。 校验配置参数12345678910const { validate } = require(&quot;schema-utils&quot;);const schema = { /*...*/};class FooPlugin { constructor(options) { validate(schema, options); }} 搭建自动测试环境为 Webpack Loader 编写单元测试收益非常高，一方面对开发者来说，不用重复搭建测试环境、编写测试 demo；一方面对于最终用户来说，带有一定测试覆盖率的项目通常意味着更高、更稳定的质量。插件测试用例开发有两个关键技术点： 如何搭建自动运行 Webpack，并能够读取构建结果的测试环境？ 如何分析构建结果，确定插件逻辑符合预期？ 搭建测试环境 Webpack 虽然功能非常复杂，但本质上还是一个 Node 程序，所以可以使用一些 Node 测试工具搭建自动测试环境，例如 Jest、Karma 等。以 Jest 为例： 安装依赖，考虑到用 ES6 编写测试用例，这里额外添加了 babel-jest 等包： 1yarn add -D jest babel-jest @babel/core @babel/preset-env 添加 Babel 配置，如： 1234// babel.config.jsmodule.exports = { presets: [[&quot;@babel/preset-env&quot;, { targets: { node: &quot;current&quot; } }]],}; 添加 Jest 配置文件，如： 1234// jest.config.jsmodule.exports = { testEnvironment: &quot;node&quot;,}; 到这里，基础环境设置完毕，可以开始编写测试用例了。首先需要在测试代码中运行 Webpack，方法很简单，如： 123import webpack from &quot;webpack&quot;;webpack(config).run(); 这部分逻辑比较通用，许多开源仓库都会将其提取为工具函数，类似于： 123456789101112131415161718192021222324252627282930import path from &quot;path&quot;;import webpack from &quot;webpack&quot;;import { merge } from &quot;webpack-merge&quot;;import { createFsFromVolume, Volume } from &quot;memfs&quot;;export function runCompile(options) { const opt = merge( { mode: &quot;development&quot;, devtool: false, // Mock 项目入口文件 entry: path.join(__dirname, &quot;./enter.js&quot;), output: { path: path.resolve(__dirname, &quot;../dist&quot;) }, }, options ); const compiler = webpack(opt); // 使用内存文件系统，节省磁盘 IO 开支 compiler.outputFileSystem = createFsFromVolume(new Volume()); return new Promise((resolve, reject) =&gt; { compiler.run((error, stats) =&gt; { if (error) { return reject(error); } return resolve({ stats, compiler }); }); });} 有了测试所需的基础环境，以及运行 Webpack 实例的能力之后，可以正式开始编写测试用例了。 编写测试用例 Webpack 插件测试的基本逻辑是：在测试框架中运行 Webpack，之后对比分析构建结果、状态等是否符合预期，对比的内容通常有： 分析 compilation.error/warn 数组是否包含或不包含特定错误、异常信息，通常用于判断 Webpack 是否运行成功； 分析构建产物，判断是否符合预期，例如： image-minimizer-webpack-plugin 单测中会 判断 最终产物图片有没有经过压缩； copy-webpack-plugn 单测中会 判断 文件有没有被复制到产物文件； mini-css-extract-plugin 单测中会 判断 CSS 文件有没有被正确抽取出来。 沿着这个思路，构造一个简单的测试用例： 123456789101112131415161718192021222324252627282930313233import path from &quot;path&quot;;import { promisify } from &quot;util&quot;;import { runCompile } from &quot;./helpers&quot;;import FooPlugin from &quot;../src/FooPlugin&quot;;describe(&quot;foo plugin&quot;, () =&gt; { it(&quot;should inject foo banner&quot;, async () =&gt; { const { stats: { compilation }, compiler, } = await runCompile({ plugins: [new FooPlugin()], }); const { warnings, errors, assets } = compilation; // 判断 warnings、errors 是否报出异常信息 expect(warnings).toHaveLength(0); expect(errors).toHaveLength(0); const { path: outputPath } = compilation.options.output; // 遍历 assets，判断经过插件处理后，产物内容是否符合预期 await Promise.all( Object.keys(assets).map(async (name) =&gt; { const pathToEmitted = path.join(outputPath, name); const result = await promisify(compiler.outputFileSystem.readFile)( pathToEmitted, { encoding: &quot;UTF-8&quot; } ); expect(result.startsWith(&quot;// Inject By 范文杰&quot;)).toBeTruthy(); }) ); });}); 示例中，17、18 行通过 errors/warnings 判断运行过程是否出现异常；25 行读入产物文件，之后判断内容是否满足要求。","link":"/2023/01/01/webpack/plugin/2.%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6/"},{"title":"编译器流程","text":"编译器模块大致流程 其实本质就是将代码转换成 ast，然后再分析 ast 为浏览器能懂的代码，就是遍历字符串并按特定逻辑去优化和重组 height=850 width=90% src=\"https://template-explorer.vuejs.org/#eyJzcmMiOiI8ZGl2PkhlbGxvIFdvcmxkPC9kaXY+Iiwib3B0aW9ucyI6e319\" frameborder=0 allowfullscreen","link":"/2023/08/05/vue/%E7%BC%96%E8%AF%91%E5%99%A8/%E7%BC%96%E8%AF%91%E5%99%A8%E6%B5%81%E7%A8%8B/"},{"title":"plugin基础","text":"plugin 开发基础介绍 Webpack 对外提供了 Loader 与 Plugin 两种扩展方式，其中 Loader 职责比较单一，开发方法比较简单容易理解；Plugin 则功能强大，借助 Webpack 数量庞大的 Hook，几乎能改写 Webpack 所有特性，但也伴随着巨大的开发复杂度。 插件简介从形态上看，插件通常是一个带有 apply 函数的类，如： 123class SomePlugin { apply(compiler) {}} Webpack 在启动时会调用插件对象的 apply 函数，并以参数方式传递核心对象 compiler ，以此为起点，插件内可以注册 compiler 对象及其子对象的钩子(Hook)回调，例如： 1234567class SomePlugin { apply(compiler) { compiler.hooks.thisCompilation.tap(&quot;SomePlugin&quot;, (compilation) =&gt; { compilation.addModule(/* ... */); }); }} 示例中的 compiler 为 Hook 挂载的对象；thisCompilation 为 Hook 名称；后面调用的 tap 为调用方式，支持 tap/tapAsync/tapPromise 等。 在 Webpack 运行过程中，随着构建流程的推进会触发各个钩子回调，并传入上下文参数(例如上例回调函数中的 compilation 对象)，插件可以通过调用上下文接口、修改上下文状态等方式「篡改」构建逻辑，从而将扩展代码「勾入」到 Webpack 构建流程中。 基于 Hook 这一设计，开发插件时需要重点关注两个问题： 针对插件需求，应该使用什么钩子？ 选定钩子后，怎么跟上下文参数交互？ 什么时候会触发什么钩子： Webpack5 暴露了多达 200+ 个 Hook，基本上覆盖了整个构建流程的所有环节 —— 这也就意味着通过编写插件，几乎可以改写 Webpack 的所有执行逻辑。问题是，在什么情况下该用什么钩子？这就需要了解 Webpack 内部几个核心对象，以及各对象下 Hook 的触发时机，例如： Compiler：全局构建管理器，Webpack 启动后会首先创建 compiler 对象，负责管理配置信息、Loader、Plugin 等。从启动构建到结束，compiler 大致上会触发如下钩子： Compilation：单次构建过程的管理器，负责遍历模块，执行编译操作；当 watch = true 时，每次文件变更触发重新编译，都会创建一个新的 compilation 对象；compilation 生命周期中主要触发如下钩子： 此外，还有 Module、Resolver、Parser、Generator 等关键类型，也都相应暴露了许多 Hook。 由此可见，Webpack Hook 与构建流程强相关。 使用 Hook 上下文接口： Webpack Hook 有两个重点，一是上面介绍的触发时机；二是触发时传递的上下文参数。例如： compiler.hooks.compilation ： 时机：Webpack 刚启动完，创建出 compilation 对象后触发； 参数：当前编译的 compilation 对象。 compiler.hooks.make： 时机：正式开始构建时触发； 参数：同样是当前编译的 compilation 对象。 compilation.hooks.optimizeChunks ： 时机： seal 函数中，chunk 集合构建完毕后触发； 参数：chunks 集合与 chunkGroups 集合。 compiler.hooks.done： 时机：编译完成后触发； 参数： stats 对象，包含编译过程中的各类统计信息。 每个钩子传递的上下文参数不同，但主要包含如下几种类型(以 Webpack5 为例)： complation 对象：构建管理器，使用率非常高，主要提供了一系列与单次构建相关的接口，包括： addModule：用于添加模块，例如 Module 遍历出依赖之后，就会调用该接口将新模块添加到构建需求中； addEntry：添加新的入口模块，效果与直接定义 entry 配置相似； emitAsset：用于添加产物文件，效果与 Loader Context 的 emitAsset 相同； getDependencyReference：从给定模块返回对依赖项的引用，常用于计算模块引用关系； 等等。 compiler 对象：全局构建管理器，提供如下接口： createChildCompiler：创建子 compiler 对象，子对象将继承原始 Compiler 对象的所有配置数据； createCompilation：创建 compilation 对象，可以借此实现并行编译； close：结束编译； getCache：获取缓存接口，可借此复用 Webpack5 的缓存功能； getInfrastructureLogger：获取日志对象； 等等。 module 对象：资源模块，有诸如 NormalModule/RawModule/ContextModule 等子类型，其中 NormalModule 使用频率较高，提供如下接口： identifier：读取模块的唯一标识符； getCurrentLoader：获取当前正在执行的 Loader 对象； originalSource：读取模块原始内容； serialize/deserialize：模块序列化与反序列化函数，用于实现持久化缓存，一般不需要调用； issuer：模块的引用者； isEntryModule：用于判断该模块是否为入口文件； 等等。 chunk 对象：模块封装容器，提供如下接口： addModule：添加模块，之后该模块会与 Chunk 中其它模块一起打包，生成最终产物； removeModule：删除模块； containsModule：判断是否包含某个特定模块； size：推断最终构建出的产物大小； hasRuntime：判断 Chunk 中是否包含运行时代码； updateHash：计算 Hash 值。 stats 对象：构建过程收集到的统计信息，包括模块构建耗时、模块依赖关系、产物文件列表等。 源码最准确直观 只列举了重要接口。 小结 总结一下，Webpack 的插件体系与平常所见的 订阅/发布 模式差别很大，是一种非常强耦合的设计，Hook 回调由 Webpack 决定何时，以何种方式执行；而在 Hook 回调内部可以通过调用上下文 API 、修改上下文状态等方式，对 Webpack 原定流程产生 Side Effect。 所以想熟练编写插件，需要深入理解常见 Hook 调用时机，以及各类上下文参数的用法，这方面没有太多学习资料，直接看相关开源插件源码，下面列举几个比较经典、逻辑简单、容易理解的插件，剖析如何灵活使用 Hook。 实例剖析：imagemin-webpack-plugin 学习如何遍历、修改最终产物文件 imagemin-webpack-plugin 是一个用于实现图像压缩的插件，它会在 Webpack 完成前置的代码分析构建，提交(emit)产物时，找出所有图片资源并调用 imagemin 压缩图像。核心逻辑： 12345678910111213141516171819202122export default class ImageminPlugin { constructor(options = {}) { // init options } apply(compiler) { // ... const onEmit = async (compilation, callback) =&gt; { // ... await Promise.all([ ...this.optimizeWebpackImages(throttle, compilation), ...this.optimizeExternalImages(throttle), ]); }; compiler.hooks.emit.tapAsync(this.constructor.name, onEmit); } optimizeWebpackImages(throttle, compilation) {} optimizeExternalImages(throttle) {}} 上述代码主要用到 compiler.hooks.emit 钩子，该钩子在 Webpack 完成代码构建与打包操作，准备将产物发送到输出目录之前执行，可以在此修改产物内容，如上例 optimizeWebpackImages 函数： 1234567891011121314151617181920212223242526272829303132export default class ImageminPlugin { optimizeWebpackImages(throttle, compilation) { const { // 用于判断是否对特定文件做图像压缩操作 testFunction, // 缓存目录 cacheFolder, } = this.options; // 遍历 `assets` 产物数组 return map(compilation.assets, (asset, filename) =&gt; throttle(async () =&gt; { // 读取产物内容 const assetSource = asset.source(); if (testFunction(filename, assetSource)) { // 尝试从缓存中读取 let optimizedImageBuffer = await getFromCacheIfPossible( cacheFolder, assetSource, () =&gt; { // 调用 `imagemin` 压缩图片 return optimizeImage(assetSource, this.options); } ); // 之后，使用优化版本替换原始文件 compilation.assets[filename] = new RawSource(optimizedImageBuffer); } }) ); }} 这里面的关键逻辑是： 遍历 compilation.assets 产物列表，调用 asset.source() 方法读取产物内容； 调用 imagemin 压缩图片； 修改 compilation.assets，使用优化后的图片 RawSource 对象替换原始 asset 对象。 至此完成文件压缩操作。 提示：Source 是 Webpack 内代表资源内容的类，由 webpack-source 库实现，支持 RawSource/ConcatSource 等子类型，用于实现文件读写、合并、修改、Sourcemap 等操作。 实例剖析：eslint-webpack-plugin 学习如何提交错误日志 eslint-webpack-plugin 是一个基于 ESLint 实现的代码风格检查插件，它的实现比较巧妙，一是使用多个 Hook，在不同时间点执行 Lint 检查；二是复用 Webpack 内置的 error/warn 方法提交代码风格问题。核心逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142class ESLintWebpackPlugin { constructor(options = {}) { // ... } apply(compiler) { compiler.hooks.run.tapPromise(this.key, (c) =&gt; this.run(c, options, wanted, exclude) ); } async run(compiler, options, wanted, exclude) { compiler.hooks.compilation.tap(this.key, (compilation) =&gt; { ({ lint, report, threads } = linter(this.key, options, compilation)); const files = []; // 单个模块成功编译后触发 compilation.hooks.succeedModule.tap(this.key, ({ resource }) =&gt; { // 判断是否需要检查该文件 if ( isMatch(file, wanted, { dot: true }) &amp;&amp; !isMatch(file, exclude, { dot: true }) ) { lint(file); } }); // 所有模块构建完毕后触发 compilation.hooks.finishModules.tap(this.key, () =&gt; { if (files.length &gt; 0 &amp;&amp; threads &lt;= 1) { lint(files); } }); // 等待检查结果 compilation.hooks.additionalAssets.tapPromise(this.key, processResults); async function processResults() {} }); }} 代码用到如下 Hook： compiler.hooks.compilation：Compiler 环境初始化完毕，创建出 compilation 对象，准备开始执行构建前触发； compilation.hooks.succeedModule：Webpack 完成单个「模块」的读入、运行 Loader、AST 分析、依赖分析等操作后触发； compilation.hooks.finishModules：Webpack 完成「所有」模块的读入、运行 Loader、依赖分析等操作后触发； compilation.hooks.additionalAssets：构建、打包完毕后触发，通常用于为编译创建附加资产。 其中，比较重要的是借助 compilation.hooks.succeedModule 钩子，在每个模块处理完毕之后立即通过 lint 函数添加非阻塞代码检查任务，相比于过去的 eslint-loader 的阻塞式执行，这种方式能够提高 ESLint 的并发度，效率更高。 其次，借助 compilation.hooks.additionalAssets 钩子，在所有模块处理完毕后读取检查结果 —— 即 processResults 函数，核心代码： 123456789101112131415async function processResults() { const { errors, warnings } = await report(); if (warnings &amp;&amp; !options.failOnWarning) { compilation.warnings.push(warnings); } else if (warnings &amp;&amp; options.failOnWarning) { compilation.errors.push(warnings); } if (errors &amp;&amp; options.failOnError) { compilation.errors.push(errors); } else if (errors &amp;&amp; !options.failOnError) { compilation.warnings.push(errors); }} 代码读取 ESLint 执行结果(report 函数)，并使用 compilation 的 errors 与 warnings 数组提交错误/警告信息，这种方式只会输出错误信息，不会中断编译流程，运行效果如： 实例剖析：DefinePlugin 学习在插件中如何与 AST 结构交互 DefinePlugin 是 Webpack 官方实现的，用于构建时注入预定义常量的插件，先简单回顾一下用法，如： 1234567891011const { DefinePlugin } = require(&quot;webpack&quot;);const baseConfig = { // ... plugins: [ new DefinePlugin({ PROD: true, VERSION: JSON.stringify(&quot;12.13.0&quot;), }), ],}; 之后，Webpack 会替换掉代码中所有 DefinePlugin 声明的属性值，例如： 12345// 源码：console.log(PROD, VERSION);// 构建结果：console.log(true, &quot;5fa3b9&quot;); DefinePlugin 的 底层实现 比较复杂，需要遍历 AST 找出变量名对应的代码位置之后再做替换，插件核心结构： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class DefinePlugin { apply(compiler) { compiler.hooks.compilation.tap( &quot;DefinePlugin&quot;, (compilation, { normalModuleFactory }) =&gt; { const handler = (parser) =&gt; { // 递归处理 `DefinePlugin` 参数 const walkDefinitions = (definitions, prefix) =&gt; { Object.keys(definitions).forEach((key) =&gt; { const code = definitions[key]; if (isObject /*...*/) { // 递归处理对象属性 walkDefinitions(code, prefix + key + &quot;.&quot;); applyObjectDefine(prefix + key, code); return; } applyDefineKey(prefix, key); applyDefine(prefix + key, code); }); }; // 替换基本类型的表达式值 const applyDefine = (key, code) =&gt; { if (!isTypeof) { // 借助 expression 钩子替换内容 parser.hooks.expression.for(key).tap(&quot;DefinePlugin&quot;, (expr) =&gt; { /*...*/ }); } // 处理 `'typeof window': JSON.stringify('object'),` 场景 parser.hooks.typeof.for(key).tap(&quot;DefinePlugin&quot;, (expr) =&gt; { /*...*/ }); }; // 替换引用类型的表达式值 const applyObjectDefine = (key, obj) =&gt; { // ... parser.hooks.expression.for(key).tap(&quot;DefinePlugin&quot;, (expr) =&gt; { /*...*/ }); }; walkDefinitions(definitions, &quot;&quot;); }; // 监听 `parser` 钩子 normalModuleFactory.hooks.parser .for(&quot;javascript/auto&quot;) .tap(&quot;DefinePlugin&quot;, handler); normalModuleFactory.hooks.parser .for(&quot;javascript/dynamic&quot;) .tap(&quot;DefinePlugin&quot;, handler); normalModuleFactory.hooks.parser .for(&quot;javascript/esm&quot;) .tap(&quot;DefinePlugin&quot;, handler); } ); }}module.exports = DefinePlugin; 提示：可能有同学注意到，上例代码中出现 xxx.hooks.xxx.for(condition).tap 形式的调用，这里的 for 函数可以理解为 Hook 的过滤条件，仅在满足 condition 时触发。 核心逻辑： 使用 normalModuleFactory.hooks.parser 钩子(上例 48 行)，在 Webpack 创建出代码解析器 Parser 对象后执行 handler 函数。注意，此时还没有执行代码转 AST 操作； walkDefinitions 函数中递归遍历 DefinePlugin 参数对象，为每一个属性注册 parser.hooks.expression 钩子回调，该钩子会在 Webpack 遍历 AST 过程遇到表达式语句时触发； 在 parser.hooks.expression 回调中创建新的 Dependency 对象，调用 addPresentationalDependency 添加为模块依赖： 1234567891011121314151617181920const toConstantDependency = (parser, value, runtimeRequirements) =&gt; { return function constDependency(expr) { const dep = new ConstDependency(value, expr.range, runtimeRequirements); dep.loc = expr.loc; // 创建静态依赖对象，替换 loc 指定位置内容 parser.state.module.addPresentationalDependency(dep); return true; };};const applyDefine = (key, code) =&gt; { parser.hooks.expression.for(key).tap(&quot;DefinePlugin&quot;, (expr) =&gt; { const strCode = toCode(/*...*/); if (/*...*/) { /*...*/ } else { return toConstantDependency(parser, strCode)(expr); } });}; 之后，Webpack 会借助 Template 接口将上述 Dependency 打包进 Chunk 中，替换对应位置(loc)代码： 这是一个功能效果看起来简单，但实现特别复杂的例子，底层需要使用 Parser 钩子遍历 AST 结构，之后借助 Dependency 声明代码依赖，最后借助 Template 替换代码内容，过程中已经涉及到许多 Webpack 底层对象。 Webpack 是一个极度复杂、庞大的工具，这些具体知识点太多太碎，从更高更抽象的视角审视 Webpack 插件架构，抽象 or 复杂。 插件架构综述前端社区里很多有名的框架都各自有一套插件架构，例如 axios、quill、vscode、webpack、vue、rollup 等等。插件架构灵活性高，扩展性强，但通常架构复杂度更高，学习曲线更陡峭。插件架构至少需要解决三个方面的问题： 接口 ：需要提供一套逻辑接入方法，让开发者能够将代码插入特定环节，变更原始逻辑； 输入 ：如何将上下文信息高效传导给插件； 输出 ：插件内部通过何种方式影响整套运行体系。 针对这些问题，webpack 基于 tapable 实现了： 编译过程的特定节点以钩子形式，通知插件此刻正在发生什么事情； 通过 tapable 提供的回调机制，以参数方式传递上下文信息； 在上下文参数对象中附带了很多存在 Side Effect 的交互接口，插件可以通过这些接口改变。 这一切都离不开 tapable，举例来说： 1234567891011121314class Compiler { // 在构造函数中，先初始化钩子对象 constructor() { this.hooks = { thisCompilation: new SyncHook([&quot;compilation&quot;, &quot;params&quot;]), }; } compile() { // 特定时机触发特定钩子 const compilation = new Compilation(); this.hooks.thisCompilation.call(compilation); }} Compiler 类型内部定义了 thisCompilation 钩子，并在 compilation 创建完毕后发布事件消息，插件开发者就可以基于这个钩子获取到最新创建出的 compilation 对象： 1234567class SomePlugin { apply(compiler) { compiler.hooks.thisCompilation.tap(&quot;SomePlugin&quot;, (compilation, params) =&gt; { // 上下文信息： compilation、params }); }} 钩子回调传递的 compilation/params 参数，就是 Webpack 希望传递给插件的上下文信息，也是插件能拿到的输入。不同钩子会传递不同的上下文对象，这一点在钩子被创建的时候就定下来了，比如： 12345678910111213141516171819202122class Compiler { constructor() { this.hooks = { /** @type {SyncBailHook&lt;Compilation&gt;} */ shouldEmit: new SyncBailHook([&quot;compilation&quot;]), /** @type {AsyncSeriesHook&lt;Stats&gt;} */ done: new AsyncSeriesHook([&quot;stats&quot;]), /** @type {AsyncSeriesHook&lt;&gt;} */ additionalPass: new AsyncSeriesHook([]), /** @type {AsyncSeriesHook&lt;Compiler&gt;} */ beforeRun: new AsyncSeriesHook([&quot;compiler&quot;]), /** @type {AsyncSeriesHook&lt;Compiler&gt;} */ run: new AsyncSeriesHook([&quot;compiler&quot;]), /** @type {AsyncSeriesHook&lt;Compilation&gt;} */ emit: new AsyncSeriesHook([&quot;compilation&quot;]), /** @type {AsyncSeriesHook&lt;string, Buffer&gt;} */ assetEmitted: new AsyncSeriesHook([&quot;file&quot;, &quot;content&quot;]), /** @type {AsyncSeriesHook&lt;Compilation&gt;} */ afterEmit: new AsyncSeriesHook([&quot;compilation&quot;]), }; }} shouldEmit 会被传入 compilation 参数； done 会被传入 stats 参数； …… 这一设计贯穿 Webpack 整个执行过程，几乎无处不在，借此介入 Webpack 的运行逻辑。 插件架构的灵魂就在于，框架自身只负责实现最关键的核心流程，其它具体功能都尽量交给具体插件实现，包括 Webpack 仓库内也会内置非常多插件(如 DefinePlugin/EntryPlugin 等)，这就提供了非常充分的学习素材。因此，流程是： 先透彻理解上述 Webpack 插件架构的设计逻辑，捋清楚 Webpack 主流程与 Hook 之间的关系； 尝试用本文第一节提及的若干常见 Hook 与上下文参数对象编写一些示例，对这些钩子有一个感性认知； 尝试分析一些常用但不是很复杂的插件源码，例如文中提到的 eslint-webpack-plugin 等，或者：terser-webpack-plugin、stylelint-webpack-plugin 等，从中学习一些编写插件的常见方法； 最后，在实际开发时参考相关插件源码实现，带着问题与明确目标，逐行分析插件实现逻辑。","link":"/2023/01/01/webpack/plugin/1.%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"},{"title":"hook","text":"Webpack Hook 底层的 Tapable 框架 深入了解 Hook 类型，以及不同类型的特点、运行特性 理解如何识别 Webpack 特定钩子类型，正确调用处理。 Tapable 全解析而 Webpack 的插件体系是一种基于 Tapable 实现的强耦合架构，它在特定时机触发钩子时会附带上足够的上下文信息，插件定义的钩子回调中，能也只能与这些上下文背后的数据结构、接口交互产生 side effect，进而影响到编译状态和后续流程。 Tapable 是 Webpack 插件架构的核心支架，但它的代码量其实很少，本质上就是围绕着 订阅/发布 模式叠加各种特化逻辑，适配 Webpack 体系下复杂的事件源-处理器之间交互需求，比如： 有些场景需要支持将前一个处理器的结果传入下一个回调处理器； 有些场景需要支持异步并行调用这些回调处理器。 先简单看看 Tapable 的用法： 123456789101112131415const { SyncHook } = require(&quot;tapable&quot;);// 1. 创建钩子实例const sleep = new SyncHook();// 2. 调用订阅接口注册回调sleep.tap(&quot;test&quot;, () =&gt; { console.log(&quot;callback A&quot;);});// 3. 调用发布接口触发回调sleep.call();// 运行结果：// callback A 使用 Tapable 时通常需要经历三个步骤： 创建钩子实例，如上例第 4 行； 调用订阅接口注册回调，包括：tap、tapAsync、tapPromise，如上例第 7 行； 调用发布接口触发回调，包括：call、callAsync、promise，如上例第 12 行。 Webpack 内部的钩子大体上都遵循上面三个步骤，只是在某些钩子中还可以使用异步风格的 tapAsync/callAsync、promise 风格 tapPromise/promise，具体使用哪一类函数与钩子类型有关。 Hook 类型汇总Tabable 提供如下类型的钩子： 名称 简介 统计 SyncHook 同步钩子 Webpack 共出现 71 次，如Compiler.hooks.compilation SyncBailHook 同步熔断钩子 Webpack 共出现 66 次，如Compiler.hooks.shouldEmit SyncWaterfallHook 同步瀑布流钩子 Webpack 共出现 37 次，如Compilation.hooks.assetPath SyncLoopHook 同步循环钩子 Webpack 中未使用 AsyncParallelHook 异步并行钩子 Webpack 仅出现 1 次：Compiler.hooks.make AsyncParallelBailHook 异步并行熔断钩子 Webpack 中未使用 AsyncSeriesHook 异步串行钩子 Webpack 共出现 16 次，如Compiler.hooks.done AsyncSeriesBailHook 异步串行熔断钩子 Webpack 中未使用 AsyncSeriesLoopHook 异步串行循环钩子 Webpack 中未使用 AsyncSeriesWaterfallHook 异步串行瀑布流钩子 Webpack 共出现 5 次，如NormalModuleFactory.hooks.beforeResolve 类型虽多，但整体遵循两种分类规则： 按回调逻辑，分为： 基本类型，名称不带 Waterfall/Bail/Loop 关键字：与通常 订阅/回调 模式相似，按钩子注册顺序，逐次调用回调； waterfall 类型：前一个回调的返回值会被带入下一个回调； bail 类型：逐次调用回调，若有任何一个回调返回非 undefined 值，则终止后续调用； loop 类型：逐次、循环调用，直到所有回调函数都返回 undefined 。 按执行回调的并行方式，分为： sync ：同步执行，启动后会按次序逐个执行回调，支持 call/tap 调用语句； async ：异步执行，支持传入 callback 或 promise 风格的异步回调函数，支持 callAsync/tapAsync 、promise/tapPromise 两种调用语句。 所有钩子都可以按名称套进这两条规则里面，对插件开发者来说不同类型的钩子会直接影响到回调函数的写法，以及插件与其他插件的互通关系，但是有一些基本能力、概念是通用的：tap/call、intercept、context、动态编译等。 接下来展开详细介绍每种钩子的特点与执行逻辑。 SyncHook 钩子SyncHook 算的上是简单的钩子了，触发后会按照注册的顺序逐个调用回调，且不关心这些回调的返回值，底层逻辑大致如下述代码： 1234567function syncCall() { const callbacks = [fn1, fn2, fn3]; for (let i = 0; i &lt; callbacks.length; i++) { const cb = callbacks[i]; cb(); }} 举个例子： 1234567891011121314151617181920212223242526272829303132const { SyncHook } = require(&quot;tapable&quot;);class Somebody { constructor() { this.hooks = { sleep: new SyncHook(), }; } sleep() { // 触发回调 this.hooks.sleep.call(); }}const person = new Somebody();// 注册回调person.hooks.sleep.tap(&quot;test&quot;, () =&gt; { console.log(&quot;callback A&quot;);});person.hooks.sleep.tap(&quot;test&quot;, () =&gt; { console.log(&quot;callback B&quot;);});person.hooks.sleep.tap(&quot;test&quot;, () =&gt; { console.log(&quot;callback C&quot;);});person.sleep();// 输出结果：// callback A// callback B// callback C 示例中，Somebody 初始化时声明了一个 sleep 钩子，并在后续调用 sleep.tap 函数连续注册三次回调，在调用 person.sleep() 语句触发 sleep.call 之后，tapable 会按照注册的先后按序执行三个回调。 上述示例中，触发回调时用到了钩子的 call 函数，也可以选择异步风格的 callAsync ，选用 call 或 callAsync 并不会影响回调的执行逻辑：按注册顺序依次执行 + 忽略回调执行结果，两者唯一的区别是 callAsync 需要传入 callback 函数，用于处理回调队列可能抛出的异常： 123456789101112// call 风格try { this.hooks.sleep.call();} catch (e) { // 错误处理逻辑}// callAsync 风格this.hooks.sleep.callAsync((err) =&gt; { if (err) { // 错误处理逻辑 }}); 由于调用方式不会 Hook 本身的规则，所以对使用者来说，无需关心底层到底用的是 call 还是 callAsync，上面的例子只需要做简单的修改就可以适配 callAsync 场景： 1234567891011121314151617181920212223242526272829303132333435const { SyncHook } = require(&quot;tapable&quot;);class Somebody { constructor() { this.hooks = { sleep: new SyncHook(), }; } sleep() { // 触发回调 this.hooks.sleep.callAsync((err) =&gt; { if (err) { console.log(`interrupt with &quot;${err.message}&quot;`); } }); }}const person = new Somebody();// 注册回调person.hooks.sleep.tap(&quot;test&quot;, (cb) =&gt; { console.log(&quot;callback A&quot;); throw new Error(&quot;我就是要报错&quot;);});// 第一个回调出错后，后续回调不会执行person.hooks.sleep.tap(&quot;test&quot;, () =&gt; { console.log(&quot;callback B&quot;);});person.sleep();// 输出结果：// callback A// interrupt with &quot;我就是要报错&quot; SyncBailHook 钩子bail 单词有熔断的意思，而 bail 类型钩子的特点是在回调队列中，若任一回调返回了非 undefined 的值，则中断后续处理，直接返回该值，用一段伪代码来表示： 12345678910111213function bailCall() { const callbacks = [fn1, fn2, fn3]; for (let i in callbacks) { const cb = callbacks[i]; const result = cb(lastResult); // 如果有任意一个回调返回结果，则停止调用剩下的回调 if (result !== undefined) { // 熔断 return result; } } return undefined;} SyncBailHook 的调用顺序与规则都跟 SyncHook 相似，主要区别一是 SyncBailHook 增加了熔断逻辑，例如： 12345678910111213141516171819202122232425262728293031const { SyncBailHook } = require(&quot;tapable&quot;);class Somebody { constructor() { this.hooks = { sleep: new SyncBailHook(), }; } sleep() { return this.hooks.sleep.call(); }}const person = new Somebody();// 注册回调person.hooks.sleep.tap(&quot;test&quot;, () =&gt; { console.log(&quot;callback A&quot;); // 熔断点 // 返回非 undefined 的任意值都会中断回调队列 return &quot;返回值：tecvan&quot;;});person.hooks.sleep.tap(&quot;test&quot;, () =&gt; { console.log(&quot;callback B&quot;);});console.log(person.sleep());// 运行结果：// callback A// 返回值：tecvan 其次，相比于 SyncHook ，SyncBailHook 运行结束后，会将熔断值返回给 call 函数，例如上例第 20 行， callback A 返回的 返回值：tecvan 会成为 this.hooks.sleep.call 的调用结果。 在 Webpack 中被如何使用 SyncBailHook 通常用在发布者需要关心订阅回调运行结果的场景， Webpack 内部有接近 100 个地方用到这种钩子，举个例子： compiler.hooks.shouldEmit，对应的 call 语句： 1234567891011class Compiler { run(callback) { // ... const onCompiled = (err, compilation) =&gt; { if (this.hooks.shouldEmit.call(compilation) === false) { // ... } }; }} 此处 Webpack 会根据 shouldEmit 钩子的运行结果确定是否执行后续的操作，其它场景也有相似逻辑，如： NormalModuleFactory.hooks.createModule ：预期返回新建的 Module 对象； Compilation.hooks.needAdditionalSeal ：预期返回 bool 值，判定是否进入 unseal 状态； Compilation.hooks.optimizeModules ：预期返回 bool 值，用于判定是否继续执行优化操作。 SyncWaterfallHook 钩子waterfall 钩子的执行逻辑跟 lodash 的 flow 函数有点像，大致上就是将前一个函数的返回值作为参数传入下一个函数，逻辑如下： 12345678910function waterfallCall(arg) { const callbacks = [fn1, fn2, fn3]; let lastResult = arg; for (let i in callbacks) { const cb = callbacks[i]; // 上次执行结果作为参数传入下一个函数 lastResult = cb(lastResult); } return lastResult;} 理解上述逻辑后，SyncWaterfallHook 的特点也就很明确了： 上一个函数的结果会被带入下一个函数； 最后一个回调的结果会作为 call 调用的结果返回。 例如： 12345678910111213141516171819202122232425262728293031const { SyncWaterfallHook } = require(&quot;tapable&quot;);class Somebody { constructor() { this.hooks = { sleep: new SyncWaterfallHook([&quot;msg&quot;]), }; } sleep() { return this.hooks.sleep.call(&quot;hello&quot;); }}const person = new Somebody();// 注册回调person.hooks.sleep.tap(&quot;test&quot;, (arg) =&gt; { console.log(`call 调用传入： ${arg}`); return &quot;tecvan&quot;;});person.hooks.sleep.tap(&quot;test&quot;, (arg) =&gt; { console.log(`A 回调返回： ${arg}`); return &quot;world&quot;;});console.log(&quot;最终结果：&quot; + person.sleep());// 运行结果：// call 调用传入： hello// A 回调返回： tecvan// 最终结果：world 示例中，sleep 钩子为 SyncWaterfallHook 类型，之后注册了两个回调，从处理结果可以看到，第一个回调收到的 arg = hello ，即第 10 行 call 调用时传入的参数；第二个回调收到的是第一个回调返回的结果 tecvan；之后 call 调用返回的是第二个回调的结果 world 。 使用时，SyncWaterfallHook 钩子有一些注意事项： 初始化时必须提供参数，例如上例 new SyncWaterfallHook([&quot;msg&quot;]) 构造函数中，必须传入参数 [&quot;msg&quot;] ，用于动态编译 call 的参数依赖； 发布调用 call 时，需要传入初始参数。 在 Webpack 中被如何使用 SyncWaterfallHook 在 Webpack 中总共出现了 50+次，其中比较有代表性的例子是 NormalModuleFactory.hooks.factory ，在 Webpack 内部实现中，会在这个钩子内根据资源类型 resolve 出对应的 module 对象： 12345678910111213141516171819202122232425262728class NormalModuleFactory { constructor() { this.hooks = { factory: new SyncWaterfallHook([&quot;filename&quot;, &quot;data&quot;]), }; this.hooks.factory.tap(&quot;NormalModuleFactory&quot;, () =&gt; (result, callback) =&gt; { let resolver = this.hooks.resolver.call(null); if (!resolver) return callback(); resolver(result, (err, data) =&gt; { if (err) return callback(err); // direct module if (typeof data.source === &quot;function&quot;) return callback(null, data); // ... }); }); } create(data, callback) { // ... const factory = this.hooks.factory.call(null); // ... }} 大致上就是在创建模块，通过 factory 钩子将 module 的创建过程外包出去，在钩子回调队列中依据 waterfall 的特性逐步推断出最终的 module 对象。 SyncLoopHook 钩子loop 型钩子的特点是循环执行，直到所有回调都返回 undefined ，不过这里循环的维度是单个回调函数，例如有回调队列 [fn1, fn2, fn3] ，loop 钩子先执行 fn1 ，如果此时 fn1 返回了非 undefined 值，则继续执行 fn1 直到返回 undefined 后，才向前推进执行 fn2 。伪代码： 12345678function loopCall() { const callbacks = [fn1, fn2, fn3]; for (let i in callbacks) { const cb = callbacks[i]; // 重复执行 while (cb() !== undefined) {} }} 由于 loop 钩子循环执行的特性，使用时务必十分注意，避免陷入死循环。示例： 123456789101112131415161718192021222324252627282930313233343536const { SyncLoopHook } = require(&quot;tapable&quot;);class Somebody { constructor() { this.hooks = { sleep: new SyncLoopHook(), }; } sleep() { return this.hooks.sleep.call(); }}const person = new Somebody();let times = 0;// 注册回调person.hooks.sleep.tap(&quot;test&quot;, (arg) =&gt; { ++times; console.log(`第 ${times} 次执行回调A`); if (times &lt; 4) { return times; }});person.hooks.sleep.tap(&quot;test&quot;, (arg) =&gt; { console.log(`执行回调B`);});person.sleep();// 运行结果// 第 1 次执行回调A// 第 2 次执行回调A// 第 3 次执行回调A// 第 4 次执行回调A// 执行回调B 可以看到示例中一直在执行回调 A，直到满足判定条件 times &gt;= 4 ，A 返回 undefined 后，才开始执行回调 B。 虽然 Tapable 提供了 SyncLoopHook 钩子，但 Webpack 源码中并没有使用到，所以大家理解用法就行，不用深究。 AsyncSeriesHook 钩子前面这些以 Sync 开头的都是同步风格的钩子，执行逻辑相对简单，但不支持异步回调，所以 Tapable 还提供了一系列 Async 开头的异步钩子，支持在回调函数中执行异步操作，执行逻辑比较复杂。 例如 AsyncSeriesHook，它有这样一些特点： 支持异步回调，可以在回调函数中写 callback 或 promise 风格的异步操作； 回调队列依次执行，前一个执行结束后，才会开始执行下一个； 与 SyncHook 一样，不关心回调的执行结果。 用一段伪代码来表示： 1234567891011121314151617181920212223function asyncSeriesCall(callback) { const callbacks = [fn1, fn2, fn3]; // 执行回调 1 fn1((err1) =&gt; { if (err1) { callback(err1); } else { // 执行回调 2 fn2((err2) =&gt; { if (err2) { callback(err2); } else { // 执行回调 3 fn3((err3) =&gt; { if (err3) { callback(err2); } }); } }); } });} 先来看一个 callback 风格的示例： 1234567891011121314151617181920212223const { AsyncSeriesHook } = require(&quot;tapable&quot;);const hook = new AsyncSeriesHook();// 注册回调hook.tapAsync(&quot;test&quot;, (cb) =&gt; { console.log(&quot;callback A&quot;); setTimeout(() =&gt; { console.log(&quot;callback A 异步操作结束&quot;); // 回调结束时，调用 cb 通知 tapable 当前回调已结束 cb(); }, 100);});hook.tapAsync(&quot;test&quot;, () =&gt; { console.log(&quot;callback B&quot;);});hook.callAsync();// 运行结果：// callback A// callback A 异步操作结束// callback B 从代码输出结果可以看出，A 回调内部的 setTimeout 执行完毕调用 cb 函数，tapable 才认为当前回调执行完毕，开始执行 B 回调。 除了 callback 风格外，也可以使用 promise 风格调用 tap/call 函数，改造上例： 12345678910111213141516171819202122232425const { AsyncSeriesHook } = require(&quot;tapable&quot;);const hook = new AsyncSeriesHook();// 注册回调hook.tapPromise(&quot;test&quot;, () =&gt; { console.log(&quot;callback A&quot;); return new Promise((resolve) =&gt; { setTimeout(() =&gt; { console.log(&quot;callback A 异步操作结束&quot;); resolve(); }, 100); });});hook.tapPromise(&quot;test&quot;, () =&gt; { console.log(&quot;callback B&quot;); return Promise.resolve();});hook.promise();// 运行结果：// callback A// callback A 异步操作结束// callback B 有三个改动点： 将 tapAsync 更改为 tapPromise； Tap 回调需要返回 promise 对象，如上例第 8 行； callAsync 调用更改为 promise。 在 Webpack 中被如何使用 AsyncSeriesHook 钩子在 Webpack 中总共出现了 30+ 次，相对来说都是一些比较容易理解的时机，比如在构建完毕后触发 compiler.hooks.done 钩子，用于通知单次构建已经结束： 1234567891011121314151617181920212223242526272829303132class Compiler { run(callback) { if (err) return finalCallback(err); this.emitAssets(compilation, (err) =&gt; { if (err) return finalCallback(err); if (compilation.hooks.needAdditionalPass.call()) { // ... this.hooks.done.callAsync(stats, (err) =&gt; { if (err) return finalCallback(err); this.hooks.additionalPass.callAsync((err) =&gt; { if (err) return finalCallback(err); this.compile(onCompiled); }); }); return; } this.emitRecords((err) =&gt; { if (err) return finalCallback(err); // ... this.hooks.done.callAsync(stats, (err) =&gt; { if (err) return finalCallback(err); return finalCallback(null, stats); }); }); }); }} AsyncParallelHook 钩子与 AsyncSeriesHook 类似，AsyncParallelHook 也支持异步风格的回调，不过 AsyncParallelHook 是以并行方式，同时执行回调队列里面的所有回调，逻辑上近似于： 123456789101112131415161718192021222324252627282930313233343536function asyncParallelCall(callback) { const callbacks = [fn1, fn2]; // 内部维护了一个计数器 var _counter = 2; var _done = function () { _callback(); }; if (_counter &lt;= 0) return; // 按序执行回调 var _fn0 = callbacks[0]; _fn0(function (_err0) { if (_err0) { if (_counter &gt; 0) { // 出错时，忽略后续回调，直接退出 _callback(_err0); _counter = 0; } } else { if (--_counter === 0) _done(); } }); if (_counter &lt;= 0) return; // 不需要等待前面回调结束，直接开始执行下一个回调 var _fn1 = callbacks[1]; _fn1(function (_err1) { if (_err1) { if (_counter &gt; 0) { _callback(_err1); _counter = 0; } } else { if (--_counter === 0) _done(); } });} AsyncParallelHook 钩子的特点： 支持异步风格； 并行执行回调队列，不需要做任何等待； 与 SyncHook 一样，不关心回调的执行结果。 实践应用综上，Tapable 合计提供了 10 种钩子，支持同步、异步、熔断、循环、waterfall 等功能特性，以此支撑起 Webpack复杂的构建需求。虽然多数情况下不需要手动调用 Tapable，但编写插件时可以借助这些知识，识别 Hook类型与执行特性后，正确地调用，正确地实现交互。 例如：对于 compiler.hooks.done 钩子，官网介绍： 这是一个 AsyncSeriesHook 钩子，意味着： 支持异步语法，可以用 tap/tapAsync/tapPromise 方式注册回调； Webpack 会按照注册顺序串行执行回调； Webpack 不关心回调的返回值，但可以通过 callback 函数传递 Error 信息。 又或者，对于 compilation.hooks.optimizeChunkModules 钩子，官网介绍： 这是一个 SyncBailHook 钩子，因此： 不支持异步语法，只能用 tap 注册回调； 若任意回调有返回值，则中断 Hook 流程，后面回调不再执行，所以使用时需要谨慎。 其它 Hook 也能用类似方法，参照分析出钩子的应用技巧。 提示：Webpack 官方文档并没有覆盖介绍所有钩子，必要时建议读者直接翻阅 Webpack 源码，分析钩子类型。 Hook 动态编译至此，Webpack 中用到的 Hook 子类都已介绍完毕，不同 Hook 适用于不同场景，解决不同问题，而它们底层都基于 Tapable 的“动态编译”实现，可以说，理解了动态编译，也就掌握了 Tapable 的核心实现逻辑。 动态编译是一个非常大胆的设计，不同 Hook 所谓的同步、异步、bail、waterfall、loop 等回调规则都是 Tapable 根据 Hook 类型、参数、回调队列等参数，调用 new Function 语句动态拼装出一段控制执行流程的 JavaScript 代码实现控制的。例如： 12345678const { SyncHook } = require(&quot;tapable&quot;);const sleep = new SyncHook();sleep.tap(&quot;test&quot;, () =&gt; { console.log(&quot;callback A&quot;);});sleep.call(); 调用 sleep.call 时，Tapable 内部处理流程大致为： 编译过程主要涉及三个实体： tapable/lib/SyncHook.js ：定义 SyncHook 的入口文件； tapable/lib/Hook.js ：SyncHook 只是一个代理接口，内部实际上调用了 Hook 类，由 Hook 负责实现钩子的逻辑（其它钩子也是一样的套路）； tapable/lib/HookCodeFactory.js ：动态编译出 call、callAsync、promise 函数内容的工厂类，注意，其他钩子也都会用到 HookCodeFactory 工厂函数。 SyncHook （其他钩子类似)）调用 call 后，Hook 基类收集上下文信息并调用 createCall 及子类传入的 compiler 函数；compiler 调用 HookCodeFactory 进而使用 new Function 方法动态拼接出回调执行函数。上面例子对应的生成函数： 1234567(function anonymous() { &quot;use strict&quot;; var _context; var _x = this._x; var _fn0 = _x[0]; _fn0();}); 那么问题来了，通过 new Function、eval 等方式实现的动态编译，存在诸如性能、安全性等方面的问题，所以社区很少见到类似的设计，真的有必要用这种方式实现 Hook 吗？ 这放在 SyncHook 这种简单场景确实大可不必，但若是更复杂的 Hook，如 AsyncSeriesWaterfallHook： 12345678910111213141516171819202122232425262728293031323334const { AsyncSeriesWaterfallHook } = require(&quot;tapable&quot;);const sleep = new AsyncSeriesWaterfallHook([&quot;name&quot;]);sleep.tapAsync(&quot;test1&quot;, (name, cb) =&gt; { console.log(`执行 A 回调： 参数 name=${name}`); setTimeout(() =&gt; { cb(undefined, &quot;tecvan2&quot;); }, 100);});sleep.tapAsync(&quot;test&quot;, (name, cb) =&gt; { console.log(`执行 B 回调： 参数 name=${name}`); setTimeout(() =&gt; { cb(undefined, &quot;tecvan3&quot;); }, 100);});sleep.tapAsync(&quot;test&quot;, (name, cb) =&gt; { console.log(`执行 C 回调： 参数 name=${name}`); setTimeout(() =&gt; { cb(undefined, &quot;tecvan4&quot;); }, 100);});sleep.callAsync(&quot;tecvan&quot;, (err, name) =&gt; { console.log(`回调结束， name=${name}`);});// 运行结果：// 执行 A 回调： 参数 name=tecvan// 执行 B 回调： 参数 name=tecvan2// 执行 C 回调： 参数 name=tecvan3// 回调结束， name=tecvan4 AsyncSeriesWaterfallHook 的特点是异步 + 串行 + 前一个回调的返回值会传入下一个回调，对应生成函数： 123456789101112131415161718192021222324252627282930313233343536373839404142(function anonymous(name, _callback) { &quot;use strict&quot;; var _context; var _x = this._x; function _next1() { var _fn2 = _x[2]; _fn2(name, function (_err2, _result2) { if (_err2) { _callback(_err2); } else { if (_result2 !== undefined) { name = _result2; } _callback(null, name); } }); } function _next0() { var _fn1 = _x[1]; _fn1(name, function (_err1, _result1) { if (_err1) { _callback(_err1); } else { if (_result1 !== undefined) { name = _result1; } _next1(); } }); } var _fn0 = _x[0]; _fn0(name, function (_err0, _result0) { if (_err0) { _callback(_err0); } else { if (_result0 !== undefined) { name = _result0; } _next0(); } });}); 核心逻辑： 生成函数将回调队列各个项封装为 _next0/_next1 函数，这些 next 函数内在逻辑高度相似； 按回调定义的顺序，逐次执行，上一个回调结束后，才调用下一个回调，例如生成代码中的第 39 行、27 行。 相比于用递归、循环之类的手段实现 AsyncSeriesWaterfallHook，这段动态生成的函数逻辑确实会更清晰，更容易理解，这种场景下用动态编译，确实是一个不错的选择。 Tapable 提供的大多数特性都是基于 Hook + HookCodeFactory 实现的，如果大家对此有兴趣，可以在 tapable/lib/Hook.js 的 CALL_DELEGATE/CALL_ASYNC_DELEGATE/PROMISE_DELEGATE 几个函数打断点： 之后，使用 ndb 命令断点调试，查看动态编译出的代码： 高级特性：Intercept除了通常的 tap/call 之外，tapable 还提供了简易的中间件机制 —— intercept 接口，例如 123456789101112131415161718const sleep = new SyncHook();sleep.intercept({ name: &quot;test&quot;, context: true, call() { console.log(&quot;before call&quot;); }, loop() { console.log(&quot;before loop&quot;); }, tap() { console.log(&quot;before each callback&quot;); }, register() { console.log(&quot;every time call tap&quot;); },}); intercept 支持注册如下类型的中间件： 签名 解释 call (...args) =&gt; void 调用call/callAsync/promise时触发 tap (tap: Tap) =&gt; void 调用call类函数后，每次调用回调之前触发 loop (...args) =&gt; void 仅loop型的钩子有效，在循环开始之前触发 register (tap: Tap) =&gt; Tap | undefined 调用tap/tapAsync/tapPromise时触发 其中 register 在每次调用 tap 时被调用；其他三种中间件的触发时机大致如下： 123456789101112131415161718192021222324252627var _context;const callbacks = [fn1, fn2];var _interceptors = this.interceptors;// 调用 call 函数，立即触发_interceptors.forEach((intercept) =&gt; intercept.call(_context));var _loop;var cursor = 0;do { _loop = false; // 每次循环开始时触发 `loop` _interceptors.forEach((intercept) =&gt; intercept.loop(_context)); // 触发 `tap` var _fn0 = callbacks[0]; _interceptors.forEach((intercept) =&gt; intercept.tap(_context, _fn0)); var _result0 = _fn0(); if (_result0 !== undefined) { _loop = true; } else { var _fn1 = callbacks[1]; // 再次触发 `tap` _interceptors.forEach((intercept) =&gt; intercept.tap(_context, _fn1)); var _result1 = _fn1(); if (_result1 !== undefined) { _loop = true; } }} while (_loop); intercept 特性在 Webpack 内主要被用作进度提示，如 Webpack/lib/ProgressPlugin.js 插件中，分别对 compiler.hooks.emit 、compiler.hooks.afterEmit 钩子应用了记录进度的中间件函数。其他类型的插件应用较少。 高级特性：HookMapTapable 还有一个值得注意的特性 —— HookMap，它提供了一种集合操作能力，能够降低创建与使用的复杂度，用法比较简单： 1234567891011const { SyncHook, HookMap } = require(&quot;tapable&quot;);const sleep = new HookMap(() =&gt; new SyncHook());// 通过 for 函数过滤集合中的特定钩子sleep.for(&quot;statement&quot;).tap(&quot;test&quot;, () =&gt; { console.log(&quot;callback for statement&quot;);});// 触发 statement 类型的钩子sleep.get(&quot;statement&quot;).call(); HookMap 能够用于实现的动态获取钩子功能，例如在 Webpack 的 lib/parser.js 文件中，parser 文件主要完成将资源内容解析为 AST 集合，之后遍历 AST 并以 HookMap 方式对外通知遍历到的内容。 例如，遇到表达式的时候触发 Parser.hooks.expression 钩子，问题是 AST 结构和内容都很复杂，如果所有情景都以独立的钩子实现，那代码量会急剧膨胀。这种场景就很适合用 HookMap 解决，以 expression 为例： 123456789101112131415161718192021222324252627282930class Parser { constructor() { this.hooks = { // 定义钩子 // 这里用到 HookMap ，所以不需要提前遍历枚举所有 expression 场景 expression: new HookMap(() =&gt; new SyncBailHook([&quot;expression&quot;])), }; } // 不同场景下触发钩子 walkMemberExpression(expression) { const exprName = this.getNameForExpression(expression); if (exprName &amp;&amp; exprName.free) { // 触发特定类型的钩子 const expressionHook = this.hooks.expression.get(exprName.name); if (expressionHook !== undefined) { const result = expressionHook.call(expression); if (result === true) return; } } // ... } walkThisExpression(expression) { const expressionHook = this.hooks.expression.get(&quot;this&quot;); if (expressionHook !== undefined) { expressionHook.call(expression); } }} 上例代码第 15、25 行都通过 this.hooks.expression.get(xxx) 语句动态获取对应钩子实例，之后再调用 call 触发。HookMap 的消费逻辑与普通 Hook 类似，只需要增加 for 函数过滤出实际监听的 Hook 实例即可，如： 123456789101112131415161718192021222324252627282930313233343536373839404142// 钩子消费逻辑// 选取 CommonJsStuffPlugin 仅起示例作用class CommonJsStuffPlugin { apply(compiler) { compiler.hooks.compilation.tap( &quot;CommonJsStuffPlugin&quot;, (compilation, { normalModuleFactory }) =&gt; { const handler = (parser, parserOptions) =&gt; { // 通过 for 精确消费钩子 parser.hooks.expression .for(&quot;require.main.require&quot;) .tap( &quot;CommonJsStuffPlugin&quot;, ParserHelpers.expressionIsUnsupported( parser, &quot;require.main.require is not supported by Webpack.&quot; ) ); parser.hooks.expression .for(&quot;module.parent.require&quot;) .tap( &quot;CommonJsStuffPlugin&quot;, ParserHelpers.expressionIsUnsupported( parser, &quot;module.parent.require is not supported by Webpack.&quot; ) ); parser.hooks.expression .for(&quot;require.main&quot;) .tap( &quot;CommonJsStuffPlugin&quot;, ParserHelpers.toConstantDependencyWithWebpackRequire( parser, &quot;__Webpack_require__.c[__Webpack_require__.s]&quot; ) ); // ... }; } ); }} 借助这种能力就不需要为每一种情况都单独创建 Hook，只需要在使用时动态创建、获取对应实例即可，能有效降低开发与维护成本。 总结为了应对构建场景下各种复杂需求，Webpack 内部使用了多种类型的 Hook，分别用于实现同步、异步、熔断、串行、并行的流程逻辑，开发插件时需要注意识别 Hook 类型，据此做出正确的调用与交互逻辑。","link":"/2023/02/01/webpack/plugin/3.hook/"},{"title":"loader进阶","text":"loader 开发高级介绍 使用 schema-utilsWebpack，以及 Webpack 生态下的诸多 Loader、Plugin 基本上都会提供若干“ 配置项 ”，供用户调整组件的运行逻辑，这些组件内部通常都会使用 schema-utils 工具库校验用户传入的配置是否满足要求。 因此，若开发的 Loader 需要对外暴露配置项，建议也尽量使用这一工具，基本用法： 安装依赖： 1yarn add -D schema-utils 编写配置对象的 Schema 描述，例如： 1234567891011// options.json{ &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: { &quot;name&quot;: { &quot;type&quot;: &quot;boolean&quot; } }, &quot;required&quot;: [&quot;name&quot;], &quot;additionalProperties&quot;: false} 在 Loader 中调用 schema-utils 校验配置对象： 1234567891011121314151617import { validate } from &quot;schema-utils&quot;;import schema from &quot;./options.json&quot;;// 调用 schema-utils 完成校验export default function loader(source) { const options = this.getOptions(); validate(schema, options); return source;}// Webpack5 之后还可以借助 Loader Context 的 `getOptions` 接口完成校验export default function loader(source) { const options = this.getOptions(schema); return source;} 之后，若用户传入不符合 Schema 描述的参数对象，会报类似下面这种错误提示： schema-utils 的校验能力很强，能够完美支撑起 Webpack 生态下非常复杂的参数校验需求，但官方文档非常语焉不详，翻阅源码后发现，它底层主要依赖于 ajv ，这是一个应用广泛、功能强大且性能优异的校验工具： 提示：ajv 在对象校验、JSON 序列化/反序列化方面的性能表现非常突出，许多知名开源框架 如：ESLint、fast-json-stringify、middy、swagger、tailwind 等底层都依赖于 ajv，值得学习、复用到业务项目中。 ajv 功能非常完备，基本上已经覆盖了“使用 JSON 描述对象约束”的所有场景，更多信息参考 官网。 ajv 数据描述格式基础知识： schema-utils 内部使用 ajv 的 JSON-Schema 模式实现参数校验，而 JSON-Schema 是一种以 JSON 格式描述数据结构的 公共规范，使用时至少需要提供 type 参数，如： 123{ &quot;type&quot;: &quot;number&quot;} ajv 默认支持七种基本数据类型。 number：数值型，支持整数、浮点数，支持如下校验规则： maximum、minimum：属性值必须大于等于 minimum ，且小于等于 maximum； exclusiveMaximum、exclusiveMinimum：属性值必须大于 exclusiveMinimum ，且小于 exclusiveMinimum； multipleOf：属性值必须为 multipleOf 的整数倍，例如对于 multipleOf = 5，则 10/20/5 均符合预期，但 8/9/1 等不符合预期。 interger：整数型，与 number 类似，也支持上面介绍的 maximum 等校验规则； string：字符串型，支持如下校验规则： maxLength、minLength：限定字符串的最大长度、最小长度； pattern：以正则表达式方式限定字符串内容； format：声明字符串内容格式，schema-utils 底层调用了 [ajv-formats](https://github.com/ajv-validator/ajv-formats) 插件，开箱支持 date/ipv4/regex/uuid 等格式。 boolean：bool 值； array：数组型，支持如下校验属性： maxItems、minItems：限定数组的最多、最少的元素数量； uniqueItems：限定数组元素是否必须唯一，不可重复； items：声明数组项的 Schema 描述，数组项内可复用 JSON-Schema 的任意规则，从而形成嵌套定义结构； null：空值，常用于复合 type 类型，如 type = ['object', 'null'] 支持传入对象结构或 null 值； object：对象结构，这是一个比较负责的结构，支持如下校验属性： maxProperties / minProperties：限定对象支持的最多、最少属性数量； required：声明哪些属性不可为空，例如 required = ['name', 'age'] 时，传入的值必须至少提供 name/age 属性； properties：定义特定属性的 Schema 描述，与 array 的 items 属性类似，支持嵌套规则，例如： 12345678910{ type: &quot;object&quot;, properties: { foo: {type: &quot;string&quot;}, bar: { type: &quot;number&quot;, minimum: 2 } }} patternProperties：同样用于定义对象属性的 Schema，但属性名支持正则表达式形式，例如： 1234567{ type: &quot;object&quot;, patternProperties: { &quot;^fo.*$&quot;: {type: &quot;string&quot;}, &quot;^ba.*$&quot;: {type: &quot;number&quot;} }} additionalProperties：限定对象是否可以提供除 properties、patternProperties 之外的属性； 除此之外，Schema 节点还支持一些通用的规则字段，包括： enum：枚举数组，属性值必须完全等于(Deep equal)这些值之一，例如： 12345678910111213// JSON-Schema{ &quot;type&quot;: &quot;string&quot;, &quot;enum&quot;: [ &quot;fanwenjie&quot;, &quot;tecvan&quot; ]}// 有效值：&quot;fanwenjie&quot;/&quot;tecvan&quot;// 无效值，如：&quot;foo bar&quot; 等 const：静态数值，属性值必须完全等于 const 定义，单独看 const 似乎作用不大，但配合 $data 指令的 JSON-Pointer 能力，可以实现关联相等的效果，例如： 12345678910111213141516171819// JSON-Schema{ type: &quot;object&quot;, properties: { foo: {type: &quot;string&quot;}, bar: {const: {$data: &quot;1/foo&quot;}} }}// bar 必须等于 foo，如：{ &quot;foo&quot;: &quot;fanwenjie&quot;, &quot;bar&quot;: &quot;fanwenjie&quot;}// 否则无效：{ &quot;foo&quot;: &quot;fanwenjie&quot;, &quot;bar&quot;: &quot;tecvan&quot;} 这些基础数据类型与校验规则奠定了 ajv 的基础校验能力，使用 schema-utils 时大部分时间都需要与之打交道。 使用 ajv 复合条件指令 除上述介绍的基本类型与基础校验规则外，ajv 还提供了若干复合校验指令： not：数值必须不符合该条件，例如：{type: &quot;number&quot;, not: {minimum: 3}} 时，传入数值必须小于 3； anyof：数值必须满足 anyof 条件之一，这是一个非常实用的指令，例如在 css-loader 中： 12345678910111213141516171819// css-loader/src/options.json{ &quot;additionalProperties&quot;: false, &quot;properties&quot;: { &quot;url&quot;: { &quot;description&quot;: &quot;Enables/Disables 'url'/'image-set' functions handling (https://github.com/webpack-contrib/css-loader#url).&quot;, &quot;anyOf&quot;: [ { &quot;type&quot;: &quot;boolean&quot; }, { &quot;instanceof&quot;: &quot;Function&quot; } ] }, // more properties }, &quot;type&quot;: &quot;object&quot;} 这意味着 css-loader 的 url 配置项只接受 Bool 或函数值。 oneof：数值必须满足且只能满足 oneof 条件之一，例如： 123456789{ type: &quot;number&quot;, oneOf: [{maximum: 3}, {type: &quot;integer&quot;}]}// 下述数值符合要求：1.1、2.1、4、5 等// 下述数值不符合要求：3.5、2、1 等 数值要么是小于等于 3 的浮点数，要么是大于 3 的整数，不在此区间的数值如“3.5/2” 等均不符合要求。 allof：数值必须满足 allof 指定的所有条件，例如： 123456789{ type: &quot;number&quot;, allOf: [{maximum: 3}, {type: &quot;integer&quot;}]}// 下述数值符合要求：1、2、3 等// 下述数值不符合要求：1.1、4、5 等 这要求传入的数值必须小于 3，且必须为整型。 if/then/else：这是一个稍显复杂的三元组复合条件，大致逻辑为：若传入的数值满足 if 条件，则必须同时满足 then 条件；若不满足 if 则必须同时满足 else，其中 else 可选。例如： 123456{ type: &quot;object&quot;, if: {properties: {foo: {minimum: 10}}}, then: {required: [&quot;bar&quot;]}, else: {required: [&quot;baz&quot;]}} 这意味着，若传入的 foo 属性值大于等于 10 时，则必须同时提供 then 所要求的 bar 属性；否则必须同时提供 else 所要求的 baz 属性。 总结一下，Webpack 官方选择 ajv 作用配置参数的校验工具，并将其二次封装为 schema-utils 库，供 Webpack 生态下的诸多 Loader、Plugin 使用。 而上面介绍的基础类型、类型校验、复合校验规则等内容是 ajv 非常基础且重要的知识点，三者协作组成 ajv 校验 schema 的框架结构，除此之外还有许多增强 Schema 表述能力的增强指令，包括：$data、$ref、definitions 等，篇幅关系这里不一一列举。同学们也可以参考 Webpack 官方编写的 Schema 文件，学习各种校验规则的写法。 使用 loader-utils在 Webpack5 之前，loader-utils 是一个非常重要的 Loader 开发辅助工具，为开发者提供了诸如 getOptions/getCurrentRequest/parseQuery 等核心接口，这些接口被诸多 Loader 广泛使用，到 Webpack5 之后干脆将这部分能力迁移到 Loader Context，致使 loader-utils 被大幅裁减简化。 被裁减后的 loader-utils 仅保留了四个接口： urlToRequest：用于将模块路径转换为文件路径的工具函数； isUrlRequest：用于判定字符串是否为模块请求路径； getHashDigest：用于计算内容 Hash 值； interpolateName：用于拼接文件名的模板工具； 翻阅大量 Loader 源码后发现，前三个接口使用率极低，实用性不大，因此本文直接跳过，仅侧重介绍 interpolateName 接口。 使用 interpolateName 拼接文件名 Webpack 支持以类似 [path]/[name]-[hash].js 方式设定 output.filename 即输出文件的命名，这一层规则通常不需要关注，但在编写类似 webpack-contrib/file-loader 这种自行输出产物文件的 Loader 时，需要由开发者自行处理产物路径逻辑。 此时可以使用 loader-utils 提供的 interpolateName 方法在 Loader 中以类似 Webpack 的 output.filename 规则拼接资源路径及名称，例如： 123456789101112131415161718192021222324252627282930313233343536// file-loader/src/index.jsimport { interpolateName } from &quot;loader-utils&quot;;export default function loader(content) { const context = options.context || this.rootContext; const name = options.name || &quot;[contenthash].[ext]&quot;; // 拼接最终输出的名称 const url = interpolateName(this, name, { context, content, regExp: options.regExp, }); let outputPath = url; // ... let publicPath = `__webpack_public_path__ + ${JSON.stringify(outputPath)}`; // ... if (typeof options.emitFile === &quot;undefined&quot; || options.emitFile) { // ... // 提交、写出文件 this.emitFile(outputPath, content, null, assetInfo); } // ... const esModule = typeof options.esModule !== &quot;undefined&quot; ? options.esModule : true; // 返回模块化内容 return `${esModule ? &quot;export default&quot; : &quot;module.exports =&quot;} ${publicPath};`;}export const raw = true; 代码的核心逻辑： 根据 Loader 配置，调用 interpolateName 方法拼接目标文件的完整路径； 调用上下文 this.emitFile 接口，写出文件； 返回 module.exports = ${publicPath} ，其它模块可以引用到该文件路径。 提示：除 file-loader 外，css-loader、eslint-loader 都有用到该接口，感兴趣的同学请自行前往查阅源码。 interpolateName 功能稍弱于 Webpack 的 Template String 规则，仅支持如下占位符： [ext]：原始资源文件的扩展名，如 .js； [name]：原始文件名； [path]：原始文件相对 context 参数的路径； [hash]：原始文件的内容 Hash 值，与 output.file 类似同样支持 [hash:length] 指定 Hash 字符串的长度； [contenthash]：作用、用法都与上述 [hash] 一模一样。 综合示例：Vue-loader接下来，再结合 vue-loader 源码进一步学习 Loader 开发的进阶技巧。vue-loader 是一个综合性很强的示例，它借助 Webpack 与组件的一系列特性巧妙地解决了：如何区分 Vue SFC 不同代码块，并复用其它 Loader 处理不同区块的内容？ 先从结构说起，vue-loader 内部实际上包含了三个组件： lib/index.js 定义的 Normal Loader，负责将 Vue SFC 不同区块转化为 JavaScript import 语句，具体逻辑下面细讲； lib/loaders/pitcher.js 定义的 Pitch Loader，负责遍历的 rules 数组，拼接出完整的行内引用路径； lib/plugin.js 定义的插件，负责初始化编译环境，如复制原始 rules 配置等； 三者协作共同完成对 SFC 的处理，使用时需要用户同时注册 Normal Loader 和 Plugin，如： 12345678910111213const VueLoaderPlugin = require(&quot;vue-loader/lib/plugin&quot;);module.exports = { module: { rules: [ { test: /.vue$/, use: [{ loader: &quot;vue-loader&quot; }], }, ], }, plugins: [new VueLoaderPlugin()],}; vue-loader 运行过程大致上可以划分为两个阶段： 预处理阶段：动态修改 Webpack 配置，注入 vue-loader 专用的一系列 module.rules； 内容处理阶段：Normal Loader 配合 Pitch Loader 完成文件内容转译。 预处理阶段vue-loader 插件会在 apply 函数中动态修改 Webpack 配置，核心代码如下： 12345678910111213141516171819202122232425262728293031323334353637class VueLoaderPlugin { apply(compiler) { // ... const rules = compiler.options.module.rules; // ... const clonedRules = rules .filter((r) =&gt; r !== rawVueRules) .map((rawRule) =&gt; cloneRule(rawRule, refs)); // ... // global pitcher (responsible for injecting template compiler loader &amp; CSS // post loader) const pitcher = { loader: require.resolve(&quot;./loaders/pitcher&quot;), resourceQuery: (query) =&gt; { if (!query) { return false; } const parsed = qs.parse(query.slice(1)); return parsed.vue != null; }, // ... }; // replace original rules compiler.options.module.rules = [pitcher, ...clonedRules, ...rules]; }}function cloneRule(rawRule, refs) { // ...}module.exports = VueLoaderPlugin; 拆开来看，插件主要完成两个任务： 初始化并注册 Pitch Loader：代码第 16 行，定义 pitcher 对象，指定 loader 路径为 require.resolve('./loaders/pitcher') ，并将 pitcher 注入到 rules 数组首位。 这种动态注入的好处是用户不用关注 —— 不去看源码根本不知道还有一个 pitcher loader，而且能保证 pitcher 能在其他 rule 之前执行，确保运行顺序。 复制 rules 配置：代码第 8 行遍历 compiler.options.module.rules 数组，也就是用户提供的 Webpack 配置中的 module.rules 项，对每个 rule 执行 cloneRule 方法复制规则对象。 之后，将 Webpack 配置修改为 [pitcher, ...clonedRules, ...rules] 。感受一下实际效果，例如： 12345678910111213141516171819202122232425262728module.exports = { module: { rules: [ { test: /.vue$/i, use: [{ loader: &quot;vue-loader&quot; }], }, { test: /\\.css$/i, use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;], }, { test: /\\.js$/i, exclude: /node_modules/, use: { loader: &quot;babel-loader&quot;, options: { presets: [[&quot;@babel/preset-env&quot;, { targets: &quot;defaults&quot; }]], }, }, }, ], }, plugins: [ new VueLoaderPlugin(), new MiniCssExtractPlugin({ filename: &quot;[name].css&quot; }), ],}; 这里定义了三个 rule，分别对应 vue、js、css 文件。经过 plugin 转换之后的结果大概为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263module.exports = { module: { rules: [ { loader: &quot;/node_modules/vue-loader/lib/loaders/pitcher.js&quot;, resourceQuery: () =&gt; {}, options: {}, }, { resource: () =&gt; {}, resourceQuery: () =&gt; {}, use: [ { loader: &quot;/node_modules/mini-css-extract-plugin/dist/loader.js&quot;, }, { loader: &quot;css-loader&quot; }, ], }, { resource: () =&gt; {}, resourceQuery: () =&gt; {}, exclude: /node_modules/, use: [ { loader: &quot;babel-loader&quot;, options: { presets: [[&quot;@babel/preset-env&quot;, { targets: &quot;defaults&quot; }]], }, ident: &quot;clonedRuleSet-2[0].rules[0].use&quot;, }, ], }, { test: /\\.vue$/i, use: [ { loader: &quot;vue-loader&quot;, options: {}, ident: &quot;vue-loader-options&quot; }, ], }, { test: /\\.css$/i, use: [ { loader: &quot;/node_modules/mini-css-extract-plugin/dist/loader.js&quot;, }, { loader: &quot;css-loader&quot; }, ], }, { test: /\\.vue$/i, exclude: /node_modules/, use: [ { loader: &quot;babel-loader&quot;, options: { presets: [[&quot;@babel/preset-env&quot;, { targets: &quot;defaults&quot; }]], }, ident: &quot;clonedRuleSet-2[0].rules[0].use&quot;, }, ], }, ], },}; 转换之后生成 6 个 rule，按定义的顺序分别为： 针对 xx.vue&amp;vue 格式路径生效的规则，只用了 vue-loader 的 Pitch 作为 Loader； 被复制的 CSS 处理规则，use 数组与开发者定义的规则相同； 被复制的 JS 处理规则，use 数组也跟开发者定义的规则相同； 开发者定义的 vue-loader 规则，内容及配置都不变； 开发者定义的 css 规则，用到 css-loader、mini-css-extract-plugin loader； 开发者定义的 js 规则，用到 babel-loader。 可以看到，第 2、3 项是从开发者提供的配置中复制过来的，内容相似，只是 cloneRule 在复制过程会给这些规则重新定义 resourceQuery 函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function cloneRule(rawRule, refs) { const rules = ruleSetCompiler.compileRules( `clonedRuleSet-${++uid}`, [ { rules: [rawRule], }, ], refs ); const conditions = rules[0].rules .map((rule) =&gt; rule.conditions) // shallow flat .reduce((prev, next) =&gt; prev.concat(next), []); // ... const res = Object.assign({}, rawRule, { resource: (resources) =&gt; { currentResource = resources; return true; }, resourceQuery: (query) =&gt; { if (!query) { return false; } const parsed = qs.parse(query.slice(1)); if (parsed.vue == null) { return false; } if (!conditions) { return false; } // 用import路径的lang参数测试是否适用于当前rule const fakeResourcePath = `${currentResource}.${parsed.lang}`; for (const condition of conditions) { // add support for resourceQuery const request = condition.property === &quot;resourceQuery&quot; ? query : fakeResourcePath; if (condition &amp;&amp; !condition.fn(request)) { return false; } } return true; }, }); // ... return res;} cloneRule 内部定义的 resourceQuery 函数对应 module.rules.resourceQuery 配置项，和经常用的 test 差不多，都用于判断资源路径是否适用这个 rule。这里 resourceQuery 核心逻辑就是取出路径中的 lang 参数，伪造一个以 lang 结尾的路径，传入 rule 的 condition 中测试路径名对该 rule 是否生效，例如下面这种会命中 /\\.js$/i 规则： 1import script from &quot;./index.vue?vue&amp;type=script&amp;lang=js&amp;&quot;; vue-loader 正是基于这一规则，为不同内容块 (css/js/template) 匹配、复用用户所提供的 rule 设置。 内容处理阶段插件处理完配置，webpack 运行起来之后，Vue SFC 文件会被多次传入不同的 Loader，经历多次中间形态变换之后才产出最终的 js 结果，大致上可以分为如下步骤： 路径命中 /\\.vue$/i 规则，调用 vue-loader 生成中间结果 A； 结果 A 命中 xx.vue?vue 规则，调用 vue-loader Pitch Loader 生成中间结果 B； 结果 B 命中具体 Loader，直接调用 Loader 做处理。 过程大致为： 举个转换过程的例子： 12345678910111213141516171819// 原始代码import xx from &quot;./index.vue&quot;;// 第一步，命中 vue-loader，转换为：import { render, staticRenderFns,} from &quot;./index.vue?vue&amp;type=template&amp;id=2964abc9&amp;scoped=true&amp;&quot;;import script from &quot;./index.vue?vue&amp;type=script&amp;lang=js&amp;&quot;;export * from &quot;./index.vue?vue&amp;type=script&amp;lang=js&amp;&quot;;import style0 from &quot;./index.vue?vue&amp;type=style&amp;index=0&amp;id=2964abc9&amp;scoped=true&amp;lang=css&amp;&quot;;// 第二步，命中 pitcher，转换为：export * from &quot;-!../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&amp;type=template&amp;id=2964abc9&amp;scoped=true&amp;&quot;;import mod from &quot;-!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-2[0].rules[0].use!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&amp;type=script&amp;lang=js&amp;&quot;;export default mod;export * from &quot;-!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-2[0].rules[0].use!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&amp;type=script&amp;lang=js&amp;&quot;;export * from &quot;-!../../node_modules/mini-css-extract-plugin/dist/loader.js!../../node_modules/css-loader/dist/cjs.js!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&amp;type=style&amp;index=0&amp;id=2964abc9&amp;scoped=true&amp;lang=css&amp;&quot;;// 第三步，根据行内路径规则按序调用loader 每一步的细节，请继续往下看。 第一次执行 vue-loader 在运行阶段，根据配置规则， Webpack 首先将原始的 SFC 内容传入 vue-loader，例如对于下面的代码： 12345678910111213141516171819202122// main.jsimport xx from 'index.vue';// index.vue 代码&lt;template&gt; &lt;div class=&quot;root&quot;&gt;hello world&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() {}, mounted() { console.log(&quot;hello world&quot;); },};&lt;/script&gt;&lt;style scoped&gt;.root { font-size: 12px;}&lt;/style&gt; 此时第一次执行 vue-loader ，执行如下逻辑： 调用 @vue/component-compiler-utils 包的 parse 函数，将 SFC 文本解析为 AST 对象； 遍历 AST 对象属性，转换为特殊的引用路径； 返回转换结果。 对于上述 index.vue 内容，转换结果为： 123456789101112131415161718192021import { render, staticRenderFns } from &quot;./index.vue?vue&amp;type=template&amp;id=2964abc9&amp;scoped=true&amp;&quot;import script from &quot;./index.vue?vue&amp;type=script&amp;lang=js&amp;&quot;export * from &quot;./index.vue?vue&amp;type=script&amp;lang=js&amp;&quot;import style0 from &quot;./index.vue?vue&amp;type=style&amp;index=0&amp;id=2964abc9&amp;scoped=true&amp;lang=css&amp;&quot;/* normalize component */import normalizer from &quot;!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js&quot;var component = normalizer( script, render, staticRenderFns, false, null, &quot;2964abc9&quot;, null)...export default component.exports 注意，这里并没有真的处理 block 里面的内容，而是简单地针对不同类型的内容块生成 import 语句： Script：&quot;./index.vue?vue&amp;type=script&amp;lang=js&amp;&quot; Template: &quot;./index.vue?vue&amp;type=template&amp;id=2964abc9&amp;scoped=true&amp;&quot; Style: &quot;./index.vue?vue&amp;type=style&amp;index=0&amp;id=2964abc9&amp;scoped=true&amp;lang=css&amp;&quot; 这些路径都对应原始的 .vue 路径基础上增加了 vue 标志符及 type、lang 等参数。 执行 Pitch Loader 如前所述，vue-loader 插件会在预处理阶段插入带 resourceQuery 函数的 Pitch Loader： 12345678910const pitcher = { loader: require.resolve(&quot;./loaders/pitcher&quot;), resourceQuery: (query) =&gt; { if (!query) { return false; } const parsed = qs.parse(query.slice(1)); return parsed.vue != null; },}; 其中， resourceQuery 函数命中 xx.vue?vue 格式的路径，也就是说上面 vue-loader 转换后的 import 路径会被 Pitch Loader 命中，做进一步处理。Pitch Loader 的逻辑比较简单，做的事情也只是转换 import 路径： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172const qs = require('querystring')...const dedupeESLintLoader = loaders =&gt; {...}const shouldIgnoreCustomBlock = loaders =&gt; {...}// 正常的loader阶段，直接返回结果module.exports = code =&gt; codemodule.exports.pitch = function (remainingRequest) { const options = loaderUtils.getOptions(this) const { cacheDirectory, cacheIdentifier } = options // 关注点1： 通过解析 resourceQuery 获取loader参数 const query = qs.parse(this.resourceQuery.slice(1)) let loaders = this.loaders // if this is a language block request, eslint-loader may get matched // multiple times if (query.type) { // if this is an inline block, since the whole file itself is being linted, // remove eslint-loader to avoid duplicate linting. if (/\\.vue$/.test(this.resourcePath)) { loaders = loaders.filter(l =&gt; !isESLintLoader(l)) } else { // This is a src import. Just make sure there's not more than 1 instance // of eslint present. loaders = dedupeESLintLoader(loaders) } } // remove self loaders = loaders.filter(isPitcher) // do not inject if user uses null-loader to void the type (#1239) if (loaders.some(isNullLoader)) { return } const genRequest = loaders =&gt; { ... } // Inject style-post-loader before css-loader for scoped CSS and trimming if (query.type === `style`) { const cssLoaderIndex = loaders.findIndex(isCSSLoader) if (cssLoaderIndex &gt; -1) { ... return query.module ? `export { default } from ${request}; export * from ${request}` : `export * from ${request}` } } // for templates: inject the template compiler &amp; optional cache if (query.type === `template`) { .​.. // console.log(request) // the template compiler uses esm exports return `export * from ${request}` } // if a custom block has no other matching loader other than vue-loader itself // or cache-loader, we should ignore it if (query.type === `custom` &amp;&amp; shouldIgnoreCustomBlock(loaders)) { return `` } const request = genRequest(loaders) return `import mod from ${request}; export default mod; export * from ${request}`} 核心功能是遍历用户定义的 rule 数组，拼接出完整的行内引用路径，例如： 123456// 开发代码：import xx from &quot;index.vue&quot;;// 第一步，通过vue-loader转换成带参数的路径import script from &quot;./index.vue?vue&amp;type=script&amp;lang=js&amp;&quot;;// 第二步，在 pitcher 中解读loader数组的配置，并将路径转换成完整的行内路径格式import mod from &quot;-!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-2[0].rules[0].use!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&amp;type=script&amp;lang=js&amp;&quot;; 第二次执行 vue-loader 通过上面 vue-loader -&gt; Pitch Loader 处理后，会得到一个新的行内路径，例如： 1import mod from &quot;-!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-2[0].rules[0].use!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&amp;type=script&amp;lang=js&amp;&quot;; 以这个 import 语句为例，之后 Webpack 会按照下述逻辑运行： 调用 vue-loader 处理 index.js 文件； 调用 babel-loader 处理上一步返回的内容。 这就给了 vue-loader 第二次执行的机会，再回过头来看看 vue-loader 的代码： 1234567891011121314151617181920212223242526272829303132333435363738module.exports = function (source) { // ... const { target, request, minimize, sourceMap, rootContext, resourcePath, resourceQuery = &quot;&quot;, } = loaderContext; // ... const descriptor = parse({ source, compiler: options.compiler || loadTemplateCompiler(loaderContext), filename, sourceRoot, needMap: sourceMap, }); // if the query has a type field, this is a language block request // e.g. foo.vue?type=template&amp;id=xxxxx // and we will return early if (incomingQuery.type) { return selectBlock( descriptor, loaderContext, incomingQuery, !!options.appendExtension ); } //... return code;};module.exports.VueLoaderPlugin = plugin; 第二次运行时由于路径已经带上了 type 参数，会命中上面第 26 行的判断语句，进入 selectBlock 函数，这个函数的逻辑很简单： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849module.exports = function selectBlock( descriptor, loaderContext, query, appendExtension) { // template if (query.type === `template`) { if (appendExtension) { loaderContext.resourcePath += &quot;.&quot; + (descriptor.template.lang || &quot;html&quot;); } loaderContext.callback( null, descriptor.template.content, descriptor.template.map ); return; } // script if (query.type === `script`) { if (appendExtension) { loaderContext.resourcePath += &quot;.&quot; + (descriptor.script.lang || &quot;js&quot;); } loaderContext.callback( null, descriptor.script.content, descriptor.script.map ); return; } // styles if (query.type === `style` &amp;&amp; query.index != null) { const style = descriptor.styles[query.index]; if (appendExtension) { loaderContext.resourcePath += &quot;.&quot; + (style.lang || &quot;css&quot;); } loaderContext.callback(null, style.content, style.map); return; } // custom if (query.type === &quot;custom&quot; &amp;&amp; query.index != null) { const block = descriptor.customBlocks[query.index]; loaderContext.callback(null, block.content, block.map); return; }}; 至此，就可以完成从 Vue SFC 文件中抽取特定 Block 内容，并复用用户定义的其它 Loader 加载这些 Block。 小结vue-loader 的核心逻辑总结为： 首先给原始文件路径增加不同的参数，后续配合 resourceQuery 参数就可以分开处理这些内容，这样的实现相比于一次性处理，逻辑更清晰简洁，更容易理解； 经过 Normal Loader、Pitch Loader 两个阶段后，SFC 内容会被转化为 import xxx from '!-babel-loader!vue-loader?xxx' 格式的引用路径，以此复用用户配置。","link":"/2023/01/01/webpack/loader/2.loader%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6/"},{"title":"loader基础","text":"loader 开发基础介绍 如何扩展 Webpack？有两种主流方式，一是 Loader —— 主要负责将资源内容翻译成 Webpack 能够理解、处理的 JavaScript 代码；二是 Plugin —— 深度介入 Webpack 构建过程，重塑 构建逻辑。 相对而言，Loader 的职责更单一，入门成本相对较低。 接下来集中介绍“ 如何开发一个 Loader ”： Loader 的基本形态与输入输出； 如何使用 Loader Context 上下文接口，并结合一些知名开源项目展开介绍部分常用接口； 如何为 Loader 编写自动测试代码； 深入剖析 Loader 链式调用模型。 为什么需要 Loader？为什么 Webpack 需要设计出 Loader 这一扩展方式？本质上是因为计算机世界中的文件资源格式实在太多，不可能一一穷举， 那何不将” 解析 “资源这部分任务开放出去，由第三方实现呢？Loader 正是为了将文件资源的“读”与“处理”逻辑解耦，Webpack 内部只需实现对标准 JavaScript 代码解析/处理能力，由第三方开发者以 Loader 方式补充对特定资源的解析逻辑。 提示：Webpack5 之后增加了 Parser 对象，事实上已经内置支持图片、JSON 等格式的内容，不过这并不影响对 Loader 这一概念的理解。 实现上，Loader 通常是一种 mapping 函数形式，接收原始代码内容，返回翻译结果，如： 1234module.exports = function (source) { // 执行各种代码计算 return modifySource;}; 在 Webpack 进入构建阶段后，首先会通过 IO 接口读取文件内容，之后调用 LoaderRunner 并将文件内容以 source 参数形式传递到 Loader 数组，source 数据在 Loader 数组内可能会经过若干次形态转换，最终以标准 JavaScript 代码提交给 Webpack 主流程，以此实现内容翻译功能。 Loader 函数签名如下： 123module.exports = function (source, sourceMap?, data?) { return source;}; Loader 接收三个参数，分别为： source：资源输入，对于第一个执行的 Loader 为资源文件的内容；后续执行的 Loader 则为前一个 Loader 的执行结果，可能是字符串，也可能是代码的 AST 结构； sourceMap: 可选参数，代码的 sourcemap 结构； data: 可选参数，其它需要在 Loader 链中传递的信息，比如 posthtml/posthtml-loader 就会通过这个参数传递额外的 AST 对象。 其中 source 是最重要的参数，大多数 Loader 要做的事情就是将 source 转译为另一种形式的 output ，比如 webpack-contrib/raw-loader 的核心源码： 123456789101112//...export default function rawLoader(source) { // ... const json = JSON.stringify(source) .replace(/\\u2028/g, &quot;\\\\u2028&quot;) .replace(/\\u2029/g, &quot;\\\\u2029&quot;); const esModule = typeof options.esModule !== &quot;undefined&quot; ? options.esModule : true; return `${esModule ? &quot;export default&quot; : &quot;module.exports =&quot;} ${json};`;} 这段代码的作用是将文本内容包裹成 JavaScript 模块，例如： 12345// sourceI am 范文杰// outputmodule.exports = &quot;I am 范文杰&quot; 经过模块化包装之后，这段文本内容变成 Webpack 可以理解的 JavaScript，其它 Module 也就能引用、使用它了。 需要注意，Loader 中执行的各种资源内容转译操作通常都是 CPU 密集型 —— 这放在 JavaScript单线程架构下可能导致性能问题；又或者异步 Loader 会挂起后续的加载器队列直到异步 Loader触发回调，稍微不注意就可能导致整个加载器链条的执行时间过长。 为此，Webpack 默认会缓存 Loader 的执行结果直到资源或资源依赖发生变化，开发者需要对此有个基本的理解，必要时可以通过 this.cachable 显式声明不作缓存： 12345module.exports = function (source) { this.cacheable(false); // ... return output;}; Loader 简单示例接下来尝试编写一个简单的 Loader Demo，理解如何开发、调试、使用自定义 Loader 组件。示例代码结构如下： 1234567loader-custom├─ src│ ├─ cjs.js│ ├─ index.js│ └─ options.json├─ package.json└─ babel.config.js 核心代码 src/index.js 内容如下： 123456789101112131415161718192021import { validate } from &quot;schema-utils&quot;;import schema from &quot;./options.json&quot;;export default function loader(source) { const { version, webpack } = this; const options = this.getOptions(); validate(schema, options, &quot;Loader&quot;); const newSource = ` /** * Loader API Version: ${version} * Is this in &quot;webpack mode&quot;: ${webpack} */ /** * Original Source From Loader */ ${source}`; return newSource;} 提示：也可以在 Loader 代码中插入 debugger 语句，配合 ndb 工具启动调试模式。 代码逻辑很简单，核心功能只是在原来 source 上拼接了一些文本，但该有的东西也都有了： 通过 this.getOptions 接口获取 Loader 配置对象； 使用 schema-utils 的 validate 接口校验 Loader 配置是否符合预期，配置 Schema 定义在 src/options.json 文件； 返回经过修改的内容。 开发完成后，可以通过 module.rules 测试该 Loader，如： 123456789101112131415161718const path = require(&quot;path&quot;);module.exports = { // ... module: { rules: [ { test: /\\.js$/, use: [ { // 传入示例 Loader 的绝对路径 loader: path.resolve(__dirname, &quot;../dist/index.js&quot;), }, ], }, ], },}; 也可以将 resolveLoader.modules 配置指向到 Loader 所在目录，Webpack 会在该目录查找加载器，如： 12345678const path = require(&quot;path&quot;);module.exports = { //... resolveLoader: { modules: [&quot;node_modules&quot;, path.resolve(__dirname, &quot;loaders&quot;)], },}; 接下来，开始使用 Loader 上下文接口实现更丰富的功能。 使用上下文接口 提示：本节内容主要围绕 Webpack5 展开，Webpack4 稍有差异，不作单独解释。 除了作为内容转换器外，Loader 运行过程还可以通过一些上下文接口，有限制地影响 Webpack 编译过程，从而产生内容转换之外的副作用。上下文接口将在运行 Loader 时以 this 方式注入到 Loader 函数： Webpack 官网对 Loader Context 已经有比较详细的说明，这里简单介绍几个比较常用的接口： fs：Compilation 对象的 inputFileSystem 属性，可以通过这个对象获取更多资源文件的内容； resource：当前文件路径； resourceQuery：文件请求参数，例如 import &quot;./a?foo=bar&quot; 的 resourceQuery 值为 ?foo=bar； callback：可用于返回多个结果； getOptions：用于获取当前 Loader 的配置对象； async：用于声明这是一个异步 Loader，开发者需要通过 async 接口返回的 callback 函数传递处理结果； emitWarning：添加警告； emitError：添加错误信息，注意这不会中断 Webpack 运行； emitFile：用于直接写出一个产物文件，例如 file-loader 依赖该接口写出 Chunk 之外的产物； addDependency：将 dep 文件添加为编译依赖，当 dep 文件内容发生变化时，会触发当前文件的重新构建； 取消 Loader 缓存需要注意，Loader 中执行的各种资源内容转译操作通常都是 CPU 密集型 —— 这放在 JavaScript单线程架构下可能导致性能问题；又或者异步 Loader 会挂起后续的加载器队列直到异步 Loader触发回调，稍微不注意就可能导致整个加载器链条的执行时间过长。 为此，Webpack 默认会缓存 Loader 的执行结果直到模块或模块所依赖的其它资源发生变化，也可以通过 this.cacheable 接口显式关闭缓存： 12345module.exports = function (source) { this.cacheable(false); // ... return output;}; 在 Loader 中返回多个结果简单的 Loader 可直接 return 语句返回处理结果，复杂场景还可以通过 callback 接口返回更多信息，供下游 Loader 或者 Webpack 本身使用，例如在 webpack-contrib/eslint-loader 中： 12345export default function loader(content, map) { // ... linter.printOutput(linter.lint(content)); this.callback(null, content, map);} 通过 this.callback(null, content, map) 语句，同时返回转译后的内容与 sourcemap 内容。callback 的完整签名如下： 1234567891011this.callback( // 异常信息，Loader 正常运行时传递 null 值即可 err: Error | null, // 转译结果 content: string | Buffer, // 源码的 sourcemap 信息 sourceMap?: SourceMap, // 任意需要在 Loader 间传递的值 // 经常用来传递 ast 对象，避免重复解析 data?: any); 在 Loader 返回异步结果涉及到异步或 CPU 密集操作时，Loader 中还可以以异步形式返回处理结果，例如 webpack-contrib/less-loader 的核心逻辑： 12345678910111213141516171819202122232425import less from &quot;less&quot;;async function lessLoader(source) { // 1. 获取异步回调函数 const callback = this.async(); // ... let result; try { // 2. 调用less 将模块内容转译为 css result = await (options.implementation || less).render(data, lessOptions); } catch (error) { // ... } const { css, imports } = result; // ... // 3. 转译结束，返回结果 callback(null, css, map);}export default lessLoader; 在 less-loader 中，包含三个重要逻辑： 调用 this.async 获取异步回调函数，此时 Webpack 会将该 Loader 标记为异步加载器，会挂起当前执行队列直到 callback 被触发； 调用 less 库将 less 资源转译为标准 css； 调用异步回调 callback 返回处理结果。 this.async 返回的异步回调函数签名与上一节介绍的 this.callback 相同，此处不再赘述。 在 Loader 中直接写出文件Loader Context 的 emitFile 接口可用于直接写出新的产物文件，例如在 file-loader 中： 123456789101112131415161718192021export default function loader(content) { const options = getOptions(this); validate(schema, options, { name: &quot;File Loader&quot;, baseDataPath: &quot;options&quot;, }); // ... if (typeof options.emitFile === &quot;undefined&quot; || options.emitFile) { // ... this.emitFile(outputPath, content, null, assetInfo); } const esModule = typeof options.esModule !== &quot;undefined&quot; ? options.esModule : true; return `${esModule ? &quot;export default&quot; : &quot;module.exports =&quot;} ${publicPath};`;}export const raw = true; 借助 emitFile 接口，能够在 Webpack 构建主流程之外提交更多产物，这有时候是必要的，除上面提到的 file-loader 外，response-loader 、mermaid-loader 等也依赖于 emitFile 实现构建功能。 在 Loader 中添加额外依赖Loader Context 的 addDependency 接口用于添加额外的文件依赖，当这些依赖发生变化时，也会触发重新构建，例如在 less-loader 中包含这样一段代码： 123456789101112try { result = await (options.implementation || less).render(data, lessOptions);} catch (error) { // ...}const { css, imports } = result;imports.forEach((item) =&gt; { // ... this.addDependency(path.normalize(item));}); 代码中首先调用 less 库编译文件内容，之后遍历所有 @import 语句(result.imports 数组)，调用 this.addDependency 函数将 import 到的文件都注册为依赖，此后这些资源文件发生变化时都会触发重新编译。 为什么 less-loader 需要这么处理？因为 less 工具本身已经会递归所有 Less 文件树，一次性将所有 .less 文件打包在一起，例如在 a.less 中 @import (less) './b.less' ，a、b 文件会被 less 打包在一起。这里面的文件依赖对 Webpack 来说是无感知的，如果不用 addDependency 显式声明依赖，后续 b.less 文件的变化不会触发 a.less 重新构建，不符合预期啊。 所以，addDependency 接口适用于那些 Webpack 无法理解隐式文件依赖的场景。除上例 less-loader，babel-loader 也是一个特别经典的案例。在 babel-loader 内部会添加对 Babel 配置文件如 .babelrc 的依赖，当 .babelrc 内容发生变化时，也会触发 babel-loader 重新运行。 此外，Loader Context 还提供了下面几个与依赖处理相关的接口： addContextDependency(directory: String)：添加文件目录依赖，目录下内容变更时会触发文件变更； addMissingDependency(file: String)：用于添加文件依赖，效果与 addDependency 类似； clearDependencies()：清除所有文件依赖。 处理二进制资源有时候期望以二进制方式读入资源文件，例如在 file-loader、image-loader 等场景中，此时只需要添加 export const raw = true 语句即可，如： 12345export default function loader(source) { /* ... */}export const raw = true; 之后，loader 函数中获取到的第一个参数 source 将会是 Buffer 对象形式的二进制内容。 在 Loader 中正确处理日志Webpack 内置了一套 infrastructureLogging 接口，专门用于处理 Webpack 内部及各种第三方组件的日志需求，与 log4js、winston 等日志工具类似，infrastructureLogging 也提供了根据日志分级筛选展示功能，从而将日志的写逻辑与输出逻辑解耦。 提示：作为对比，假如使用 console.log 等硬编码方式输出日志信息，用户无法过滤这部分输出，可能会造成较大打扰，体感很不好。 因此，在编写 Loader 时也应该尽可能复用 Webpack 内置的这套 Logging 规则，方法很简单，只需使用 Loader Context 的 getLogger 接口，如： 12345678export default function loader(source) { const logger = this.getLogger(&quot;xxx-loader&quot;); // 使用适当的 logging 接口 // 支持：verbose/log/info/warn/error logger.info(&quot;information&quot;); return source;} getLogger 返回的 logger 对象支持 verbose/log/info/warn/error 五种级别的日志，最终用户可以通过 infrastructureLogging.level 配置项筛选不同日志内容，例如： 1234567module.exports = { // ... infrastructureLogging: { level: &quot;warn&quot;, }, // ...}; 在 Loader 中正确上报异常Webpack Loader 中有多种上报异常信息的方式： 使用 logger.error，仅输出错误日志，不会打断编译流程，效果： 使用 this.emitError 接口，同样不会打断编译流程，效果： 与 logger.error 相比，emitError 不受 infragstrustureLogging 规则控制，必然会强干扰到最终用户；其次，emitError 会抛出异常的 Loader 文件、代码行、对应模块，更容易帮助定位问题。 使用 this.callback 接口提交错误信息，但注意导致当前模块编译失败，效果与直接使用 throw 相同，用法： 12345export default function loader(source) { this.callback(new Error(&quot;发生了一些异常&quot;)); return source;} 之后，Webpack 会将 callback 传递过来的错误信息当做模块内容，打包进产物文件： 总的来说，这些方式各自有适用场景，尽量按如下规则择优选用： 一般应尽量使用 logger.error，减少对用户的打扰； 对于需要明确警示用户的错误，优先使用 this.emitError； 对于已经严重到不能继续往下编译的错误，使用 callback 。 为 Loader 编写单元测试在 Loader 中编写单元测试收益非常高，一方面对开发者来说，不用重复手动测试各种特性；一方面对于最终用户来说，带有一定测试覆盖率的项目通常意味着更高、更稳定的质量。常规的 Webpack Loader 单元测试流程大致如下： 创建在 Webpack 实例，并运行 Loader； 获取 Loader 执行结果，比对、分析判断是否符合预期； 判断执行过程中是否出错。 如何运行 Loader？ 有两种办法，一是在 node 环境下运行调用 Webpack 接口，用代码而非命令行执行编译，很多框架都会采用这种方式，例如vue-loader、stylus-loader、babel-loader等，优点是运行效果最接近最终用户，缺点是运行效率相对较低（可以忽略）。 以 posthtml/posthtml-loader 为例，它会在启动测试之前创建并运行 Webpack 实例： 1234567891011121314151617181920212223// posthtml-loader/test/helpers/compiler.js 文件module.exports = function (fixture, config, options) { config = { /*...*/ }; options = Object.assign({ output: false }, options); // 创建 Webpack 实例 const compiler = webpack(config); // 以 MemoryFS 方式输出构建结果，避免写磁盘 if (!options.output) compiler.outputFileSystem = new MemoryFS(); // 执行，并以 promise 方式返回结果 return new Promise((resolve, reject) =&gt; compiler.run((err, stats) =&gt; { if (err) reject(err); // 异步返回执行结果 resolve(stats); }) );}; 提示：上面的示例中用到 compiler.outputFileSystem = new MemoryFS() 语句将 Webpack 设定成输出到内存，能避免写盘操作，提升编译速度。 另外一种方法是编写一系列 mock 方法，搭建起一个模拟的 Webpack 运行环境，例如 emaphp/underscore-template-loader ，优点是运行速度更快，缺点是开发工作量大通用性低，了解即可。 如何校验 Loader 执行结果？ 上例运行结束之后会以 resolve(stats) 方式返回执行结果，stats 对象中几乎包含了编译过程所有信息，包括：耗时、产物、模块、chunks、errors、warnings 等等，可以从 stats 对象中读取编译最终输出的产物，例如 style-loader： 1234567891011121314// style-loader/src/test/helpers/readAsset.js 文件function readAsset(compiler, stats, assets) =&gt; { const usedFs = compiler.outputFileSystem const outputPath = stats.compilation.outputOptions.path const queryStringIdx = targetFile.indexOf('?') if (queryStringIdx &gt;= 0) { // 解析出输出文件路径 asset = asset.substr(0, queryStringIdx) } // 读文件内容 return usedFs.readFileSync(path.join(outputPath, targetFile)).toString()} 解释一下，这段代码首先计算 asset 输出的文件路径，之后调用 outputFileSystem 的 readFile 方法读取文件内容。 接下来，有两种分析内容的方法： 调用 Jest 的 expect(xxx).toMatchSnapshot() 断言，判断当前运行结果是否与之前的运行结果一致，从而确保多次修改的结果一致性，很多框架都大量用了这种方法； 解读资源内容，判断是否符合预期，例如 less-loader 的单元测试中会对同一份代码跑两次 less 编译，一次由 Webpack 执行，一次直接调用 less 库，之后分析两次运行结果是否相同。 对此有兴趣的同学，强烈建议看看 less-loader 的 test 目录。 如何判断执行过程是否触发异常？ 最后，还需要判断编译过程是否出现异常，同样可以从 stats 对象解析： 1234export default getErrors = (stats) =&gt; { const errors = stats.compilation.errors.sort(); return errors.map((e) =&gt; e.toString());}; 大多数情况下都希望编译没有错误，此时只要判断结果数组是否为空即可。某些情况下可能需要判断是否抛出特定异常，此时可以 expect(xxx).toMatchSnapshot() 断言，用快照对比更新前后的结果。 链式调用模型详解举个例子，为了读取 less 文件，通常需要同时配置多个加载器： 12345678910module.exports = { module: { rules: [ { test: /\\.less$/i, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], }, ], },}; 示例针对 .less 后缀的文件设定了 less、css、style 三个 Loader，Webpack 启动后会以一种所谓“链式调用”的方式按 use 数组顺序从后到前调用 Loader： 首先调用 less-loader 将 Less 代码转译为 CSS 代码； 将 less-loader 结果传入 css-loader，进一步将 CSS 内容包装成类似 module.exports = &quot;${css}&quot; 的 JavaScript 代码片段； 将 css-loader 结果传入 style-loader，在运行时调用 injectStyle 等函数，将内容注入到页面的 &lt;style&gt; 标签。 三个 Loader 分别完成内容转化工作的一部分，形成从右到左的执行链条。链式调用这种设计有两个好处，一是保持单个 Loader 的单一职责，一定程度上降低代码的复杂度；二是细粒度的功能能够被组装成复杂而灵活的处理链条，提升单个 Loader 的可复用性。 不过，这只是链式调用的一部分，这里面有两个问题： Loader 链条一旦启动之后，需要所有 Loader 都执行完毕才会结束，没有中断的机会 —— 除非显式抛出异常； 某些场景下并不需要关心资源的具体内容，但 Loader 需要在 source 内容被读取出来之后才会执行。 为了解决这两个问题，Webpack 在 Loader 基础上叠加了 pitch 的概念。 Q: 什么是 pitch？ Webpack 允许在 Loader 函数上挂载名为 pitch 的函数，运行时 pitch 会比 Loader 本身更早执行，例如： 12345678910const loader = function (source) { console.log(&quot;后执行&quot;); return source;};loader.pitch = function (requestString) { console.log(&quot;先执行&quot;);};module.exports = loader; Pitch 函数的完整签名： 12345function pitch( remainingRequest: string, previousRequest: string, data = {}): void {} 包含三个参数： remainingRequest : 当前 loader 之后的资源请求字符串； previousRequest : 在执行当前 loader 之前经历过的 loader 列表； data : 与 Loader 函数的 data 相同，用于传递需要在 Loader 传播的信息。 这些参数不复杂，但与 requestString 紧密相关，看个例子加深了解： 12345678910module.exports = { module: { rules: [ { test: /\\.less$/i, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], }, ], },}; css-loader.pitch 中拿到的参数依次为： 123456// css-loader 之后的 loader 列表及资源路径remainingRequest = less-loader!./xxx.less// css-loader 之前的 loader 列表previousRequest = style-loader// 默认值data = {} pitch 函数调度逻辑 Pitch 翻译成中文是抛、球场、力度、事物最高点等，它背后折射的是一整套 Loader 被执行的生命周期概念。 实现上，Loader 链条执行过程分三个阶段：pitch、解析资源、执行，设计上与 DOM 的事件模型非常相似，pitch对应到捕获阶段；执行对应到冒泡阶段；而两个阶段之间 Webpack 会执行资源内容的读取、解析操作，对应 DOM 事件模型的 AT_TARGET阶段： pitch 阶段按配置顺序从左到右逐个执行 loader.pitch 函数(如果有的话)，开发者可以在 pitch 返回任意值中断后续的链路的执行： 那么为什么要设计 pitch 这一特性呢？ 在分析了 style-loader、vue-loader、to-string-loader 等开源项目之后，感觉关键字是： 阻断 ！ 回顾一下前面提到过的 less 加载链条： less-loader ：将 less 规格的内容转换为标准 css； css-loader ：将 css 内容包裹为 JavaScript 模块； style-loader ：将 JavaScript 模块的导出结果以 link 、style 标签等方式挂载到 html 中，让 css 代码能够正确运行在浏览器上。 实际上， style-loader 只是负责让 CSS 在浏览器环境下跑起来，并不需要关心具体内容，很适合用 pitch 来处理，核心代码： 123456789101112131415161718192021222324252627282930313233343536373839404142// ...// Loader 本身不作任何处理const loaderApi = () =&gt; {};// pitch 中根据参数拼接模块代码loaderApi.pitch = function loader(remainingRequest) { //... switch (injectType) { case &quot;linkTag&quot;: { return `${ esModule ? `...` : // 引入 runtime 模块 `var api = require(${loaderUtils.stringifyRequest( this, `!${path.join(__dirname, &quot;runtime/injectStylesIntoLinkTag.js&quot;)}` )}); // 引入 css 模块 var content = require(${loaderUtils.stringifyRequest( this, `!!${remainingRequest}` )}); content = content.__esModule ? content.default : content;` } // ...`; } case &quot;lazyStyleTag&quot;: case &quot;lazySingletonStyleTag&quot;: { //... } case &quot;styleTag&quot;: case &quot;singletonStyleTag&quot;: default: { // ... } }};export default loaderApi; 关键点： loaderApi 为空函数，不做任何处理； loaderApi.pitch 中拼接结果，导出的代码包含： 引入运行时模块 runtime/injectStylesIntoLinkTag.js； 复用 remainingRequest 参数，重新引入 css 文件。 运行后，关键结果大致如： 12var api = require(&quot;xxx/style-loader/lib/runtime/injectStylesIntoLinkTag.js&quot;);var content = require(&quot;!!css-loader!less-loader!./xxx.less&quot;); 注意了，到这里 style-loader 的 pitch 函数返回这一段内容，后续的 Loader 就不会继续执行，当前调用链条中断了： 之后，Webpack 继续解析、构建 style-loader 返回的结果，遇到 inline loader 语句： 1var content = require(&quot;!!css-loader!less-loader!./xxx.less&quot;); 所以从 Webpack 的角度看，对同一个文件实际调用了两次 loader 链，第一次在 style-loader 的 pitch 中断，第二次根据 inline loader 的内容跳过了 style-loader。 总结Loader 主要负责将资源内容转换为 Webpack 能够理解的 JavaScript 代码形式，开发时可以借助 Loader Context 提供的丰富接口实现各种各样的诉求。此外，也需要结合 Loader 的链式调用模型，尽可能设计出复用性更强，更简洁的资源加载器。","link":"/2023/01/01/webpack/loader/1.loader%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"},{"title":"Suspense","text":"Suspense 原理与异步 &lt;Suspense&gt; 组件的实现原理，本质上就是通过一个计数器 deps 来记录需要被处理的依赖数量，当异步状态执行完成后，响应的计数器进行递减，当所有 deps 清空时，则达到统一完成态。于此同时，如果有父子嵌套的情况出现，会根据父节点的 suspense 状态来判断是否需要统一处理 effects &lt;Suspense&gt; 是一个内置组件，用来在组件树中协调对异步依赖的处理。可以更好的完成组件树父组件对子组件的多个嵌套异步依赖关系的管理，当父组件处于等待中时，允许自定义挂载一个加载中状态。 上图中，红色字体代表的是组件有异步的 setup() 。 通过 &lt;Suspense&gt; 组件可以很容易实现在组件异步加载时统一展示加载中状态，在所有组件完成加载时，再统一展示： 1234567&lt;Suspense&gt; &lt;!-- 具有深层异步依赖的组件 --&gt; &lt;Dashboard /&gt; &lt;!-- 在 #fallback 插槽中显示 “正在加载中” --&gt; &lt;template #fallback&gt; Loading... &lt;/template&gt;&lt;/Suspense&gt; Suspense 挂载&lt;Suspense&gt; 组件和所有内置组件一样，也是有初始化挂载的过程， Vue 对 &lt;Suspense&gt; 组件的源码定义： 1234567891011121314export const SuspenseImpl = { name: 'Suspense', // Suspense 组件标识符 __isSuspense: true, process(...) { if (n1 == null) { // 初始化挂载的逻辑 } else { // diff 的逻辑 } }, create: createSuspenseBoundary, normalize: normalizeSuspenseChildren} process 的执行时机和 &lt;Teleport&gt; 组件是一致的，会在 patch 的时候根据组件的 shapeFlag 标志来判断是否需要执行 process 函数的调用。 12345678910111213141516171819202122232425262728293031const patch = (n1, n2, container, anchor, ...) =&gt; { // ... const { type, ref, shapeFlag } = n2 switch (type) { // 根据 type 类型处理 case Text: // 对文本节点的处理 processText(n1, n2, container, anchor) break // 这里省略了一些其他节点处理，比如注释、Fragment 节点等等 // ... default: // 根据 shapeFlag 来处理 // ... else if (__FEATURE_SUSPENSE__ &amp;&amp; shapeFlag &amp; ShapeFlags.SUSPENSE) { // 对 Suspense 节点进行处理 type.process( n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals ); } }} Suspense 的初始化挂载逻辑，这块的代码集中在 mountSuspense 中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function mountSuspense( vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) { const { p: patch, o: { createElement }, } = rendererInternals; // 创建隐藏容器，用来实例化挂载 default 插槽内的内容 const hiddenContainer = createElement(&quot;div&quot;); // 构造一个 suspense 对象，并赋值给 vnode.suspense const suspense = (vnode.suspense = createSuspenseBoundary( vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals )); // 离线挂载 default 插槽内的内容 patch( null, (suspense.pendingBranch = vnode.ssContent), hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds ); // 如果有异步依赖 if (suspense.deps &gt; 0) { // 触发 onPending，onFallback 钩子函数 triggerEvent(vnode, &quot;onPending&quot;); triggerEvent(vnode, &quot;onFallback&quot;); // 初始化挂载 fallback 插槽内容 patch( null, vnode.ssFallback, container, anchor, parentComponent, // fallback tree 不会有 suspense context null, isSVG, slotScopeIds ); // 将 fallback vnode 设置为 activeBranch setActiveBranch(suspense, vnode.ssFallback); } else { // 如果 suspense 没有异步依赖，直接调用 resolve suspense.resolve(); }} 关键变量的含义： ssContent 代表的是 default 插槽内的内容的 vnode。 ssFallback 代表的是 fallback 插槽内的内容的 vnode。 activeBranch 代表的是当前激活的分支，就是挂载到页面中的 vnode。 pendingBranch 代表的是正处于 pending 状态的分支，一般指还未被激活的 default 插槽内的内容中的 vnode 整个 mountSuspense 的过程，首先会创建一个隐藏的 DOM 元素，该元素将作为 default 插槽内容的初始化挂载容器。然后创建了一个 suspense 变量，该变量内部包含了一些的对 &lt;Suspense&gt; 组件的处理函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859function createSuspenseBoundary( vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) { // ... const suspense = { vnode, parent, parentComponent, isSVG, container, hiddenContainer, anchor, deps: 0, pendingId: 0, timeout: typeof timeout === &quot;number&quot; ? timeout : -1, activeBranch: null, pendingBranch: null, isInFallback: true, isHydrating, isUnmounted: false, effects: [], resolve(resume = false) { // ... }, fallback(fallbackVNode) { // ... }, move(container, anchor, type) { // ... }, next() { // ... }, registerDep(instance, setupRenderEffect) { // ... }, unmount(parentSuspense, doRemove) { // ... }, }; return suspense;} 这个 createSuspenseBoundary 函数本身其实并没有做太多的事情，本质上就是为了构造一个 suspense 对象。 接下来会进入到对 default 容器中的内容进行 patch 的过程。patch对于 &lt;Suspense&gt; 组件来说，setup 会返回个 promise。查看该情况： 1234567891011function setupStatefulComponent(instance, isSSR) { // ... // 对于 setup 返回是个 promise 的情况 if (isPromise(setupResult)) { setupResult.then(unsetCurrentInstance, unsetCurrentInstance); if (__FEATURE_SUSPENSE__) { // 在 suspense 模式下，为实例 asyncDep 赋值为 setupResult instance.asyncDep = setupResult; } }} 对于 Suspense 组件来说，其中的 default 内容的 setup 如果返回的是个 pormise 对象的话，则会为将 setup 函数执行的结果 setupResult 赋值给实例属性 asyncDep。 在渲染器执行 mountComponent 的时候，如果存在 asyncDep 变量，则会调用 suspense 上的 registerDep 方法，并为 default 中的插槽节点创建了一个占位符： 1234567891011121314151617181920212223const mountComponent = ( initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; { // ... // 依赖于 suspense 的异步 setup if (__FEATURE_SUSPENSE__ &amp;&amp; instance.asyncDep) { parentSuspense &amp;&amp; parentSuspense.registerDep(instance, setupRenderEffect); // 为插槽 vnode 创建注释节点 if (!initialVNode.el) { const placeholder = (instance.subTree = createVNode(Comment)); processCommentNode(null, placeholder, container, anchor); } return; } // ...}; 这里的 parentSuspense 就是 default 插槽内的第一个父级 suspense 对象。接下来看看 registerDep 的执行逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172function createSuspenseBoundary( vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) { // ... const suspense = { // ... registerDep(instance, setupRenderEffect) { // 是否有异步未处理的分支 const isInPendingSuspense = !!suspense.pendingBranch; if (isInPendingSuspense) { // deps 这里会被递增，记录依赖的异步数量 suspense.deps++; } // asyncDep promise 执行 instance.asyncDep .catch((err) =&gt; { // setup return 的 promise 异常捕获 handleError(err, instance, ErrorCodes.SETUP_FUNCTION); }) .then((asyncSetupResult) =&gt; { // 处理一些异常结果 if ( instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId ) { return; } instance.asyncResolved = true; const { vnode } = instance; // setup 处理完成调用 handleSetupResult(instance, asyncSetupResult, false); // 占位内容，就是 mountComponent 中创建的注释节点 const placeholder = !hydratedEl &amp;&amp; instance.subTree.el; // 执行 render 挂载节点 setupRenderEffect( instance, vnode, // 找到注释占位内容的父节点，作为容器节点，也就是之前创建的隐藏 dom parentNode(hydratedEl || instance.subTree.el), hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized ); // 移除占位符 if (placeholder) { remove(placeholder); } // 更新 vnode el 属性 updateHOCHostEl(instance, vnode.el); // 当所有的异步依赖处理完成后执行 suspense.resolve() if (isInPendingSuspense &amp;&amp; --suspense.deps === 0) { suspense.resolve(); } }); }, }; return suspense;} 这里在执行 createSuspenseBoundary 函数的时候， suspense.deps这个变量记录着需要处理的异步数量，比如上面的图例： 这里生成的 deps = 3。 然后会对 instance.asyncDep 的执行结果进行处理，如果有异常，则进入到 handleError 的逻辑，handleError 内部会调用 onErrorCaptured 钩子，可以监听到组件的错误。 如果正常返回，则会进入到 then 的处理逻辑中，这里的处理主要做了以下几件事儿： 首先对一些异常场景进行降级，这里的异常场景包含了组件实例在异步执行完成后被卸载，或者 Suspense 实例被卸载等情况。 然后就是为组件设置 render 函数。如果 setup promise 返回的时候函数，那么这里也会将这个函数设置为渲染函数。 接着就是通过 setupRenderEffect 函数的调用，完成渲染函数的调用执行，生成 DOM 节点 最后，根据 deps 判断是否所有的异步依赖都已执行完，如果执行完，则进入 suspense.resolve() 的逻辑。 回到 mountSuspense 函数体当中，如果存在异步依赖，此时的 suspense.deps &gt; 0 会进入到对异步处理的逻辑中： 123456789101112131415161718// 触发 onPending，onFallback 钩子函数triggerEvent(vnode, &quot;onPending&quot;);triggerEvent(vnode, &quot;onFallback&quot;);// 初始化挂载 fallback 插槽内容patch( null, vnode.ssFallback, container, anchor, parentComponent, // fallback tree 不会有 suspense context null, isSVG, slotScopeIds);// 将 fallback vnode 设置为 activeBranchsetActiveBranch(suspense, vnode.ssFallback); 这里的核心逻辑就是在 default 插槽中的异步未执行完成时，先挂载 fallback 的内容。然后将 activeBranch 设置为 fallback。 如果不存在异步依赖，suspense.deps = 0 此时，也会直接执行 suspense.resolve()。 接下来，看看这个 resolve 到底做了哪些事： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273function createSuspenseBoundary( vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) { // ... const suspense = { // ... resolve(resume = false) { const { vnode, activeBranch, pendingBranch, pendingId, effects, parentComponent, container, } = suspense; // 服务端渲染的逻辑，这里不关心 if (suspense.isHydrating) { suspense.isHydrating = false; } else if (!resume) { // ... let { anchor } = suspense; // 卸载当前激活分支，即 fallback if (activeBranch) { anchor = next(activeBranch); unmount(activeBranch, parentComponent, suspense, true); } if (!delayEnter) { // 将 default 容器中的内容移动到可视区域 move(pendingBranch, container, anchor, MoveType.ENTER); } } // 将 pendingBranch 设置为激活分支 setActiveBranch(suspense, pendingBranch); suspense.pendingBranch = null; suspense.isInFallback = false; // 获取父节点 let parent = suspense.parent; // 标记是否还有未处理完成的 suspense let hasUnresolvedAncestor = false; while (parent) { if (parent.pendingBranch) { // 如果存在还未处理完的父级 suspense，将当前 effect 合并到父级当中 parent.effects.push(...effects); hasUnresolvedAncestor = true; break; } parent = parent.parent; } // 全部处理完suspense，一次性 queuePostFlushCb if (!hasUnresolvedAncestor) { queuePostFlushCb(effects); } suspense.effects = []; // 调用 onResolve 钩子函数 triggerEvent(vnode, &quot;onResolve&quot;); }, }; return suspense;} 卸载 fallback 的插槽内容，因为已经完成了异步逻辑，所以没必要了。 将之前缓存在内存中的 default 节点移动到可是区域。 遍历父节点，找到是否还有未完成的 suspense 节点，将当前的渲染 effects 合并到父节点上进行统一更新。 触发 onResolve 钩子函数。 第三点，会出现子节点已经完成异步依赖执行单父节点还有未完成的异步依赖的情况，示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import { createApp, ref, h, onMounted } from &quot;vue&quot;;// 构造一个异步渲染容器function defineAsyncComponent(comp, delay = 0) { return { setup(props, { slots }) { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(() =&gt; h(comp, props, slots)); }, delay); }); }, };}// 定义一个外层异步组件const AsyncOuter = defineAsyncComponent( { setup: () =&gt; { onMounted(() =&gt; { console.log(&quot;outer mounted&quot;); }); return () =&gt; h(&quot;div&quot;, &quot;async outer&quot;); }, }, 2000);// 定义一个内层异步组件const AsyncInner = defineAsyncComponent( { setup: () =&gt; { onMounted(() =&gt; { console.log(&quot;inner mounted&quot;); }); return () =&gt; h(&quot;div&quot;, &quot;async inner&quot;); }, }, 1000);// 定义一个内层 Suspense 组件const Inner = { setup() { return () =&gt; h(Suspense, null, { default: h(AsyncInner), fallback: h(&quot;div&quot;, &quot;fallback inner&quot;), }); },};createApp({ setup() { return () =&gt; // 定义一个外层 Suspense 组件 h(Suspense, null, { default: h(&quot;div&quot;, [h(AsyncOuter), h(Inner)]), fallback: h(&quot;div&quot;, &quot;fallback outer&quot;), }); },}).mount(&quot;#app&quot;); 这里构造了一个包含了 Suspense 异步渲染的 Outer 组件，Outer 中又包含了另一个通过 Suspense 渲染的 Inner 组件。通过 defineAsyncComponent 函数来模拟组件的异步过程，此时的 AsyncInner 组件是优先于 AsyncOuter 组件的异步完成的，对于这种情况，就满足了存在父的 Suspense 且父级 Suspense 还有 pendingBranch 待处理的情况，那么会把子组件的 suspense.effects 合入父组件当中。 suspense.effects 1234567891011121314151617// queuePostRenderEffect 在 suspense 模式下指的是 queueEffectWithSuspenseexport const queuePostRenderEffect = __FEATURE_SUSPENSE__ ? queueEffectWithSuspense : queuePostFlushCb;export function queueEffectWithSuspense(fn, suspense) { // 针对 suspense 处理，会将渲染函数推送到 suspense.effects 中 if (suspense &amp;&amp; suspense.pendingBranch) { if (isArray(fn)) { suspense.effects.push(...fn); } else { suspense.effects.push(fn); } } else { queuePostFlushCb(fn); }} suspense.effects 在 suspense 模式下，就是通过 queuePostRenderEffect 生成的副作用函数的数组。示例中，会在组件中调用 onMounted 钩子函数，在组件被挂载的时候，就会执行通过 queuePostRenderEffect 函数，将 onMounted 推入 suspense.effects 数组中： 12345678910111213141516171819202122// 设置并运行带副作用的渲染函数const setupRenderEffect = (...) =&gt; { const componentUpdateFn = () =&gt; { if (!instance.isMounted) { // ... const { m } = instance // mounted hook 推入到 suspense.effects if (m) { queuePostRenderEffect(m, parentSuspense) } } else { // ... let { u } = instance // updated hook 推入到 suspense.effects if (u) { queuePostRenderEffect(u, parentSuspense) } } } // ...} 所以上述的示例中，父子组件的 onMounted 钩子将会被在父组件异步完成后统一执行。 Suspense 更新Suspense 更新的逻辑，这块的逻辑都集中在 patchSuspense 函数中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162function patchSuspense( n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) { // 初始化赋值操作 const suspense = (n2.suspense = n1.suspense); suspense.vnode = n2; n2.el = n1.el; // 最新的 default 分支 const newBranch = n2.ssContent; // 最新的 fallback 分支 const newFallback = n2.ssFallback; const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense; // 存在旧的 pendingBranch if (pendingBranch) { suspense.pendingBranch = newBranch; // 新旧分支是属于 isSameVNodeType if (isSameVNodeType(newBranch, pendingBranch)) { // 新旧分支进行 diff patch( pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized ); // 没有依赖则直接 resolve if (suspense.deps &lt;= 0) { suspense.resolve(); } else if (isInFallback) { // 处于 fallback 中，激活分支和 newFallback 进行 diff patch( activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context isSVG, slotScopeIds, optimized ); // 更新激活分支为 newFallback setActiveBranch(suspense, newFallback); } } else { suspense.pendingId++; // ... // 卸载旧分支 unmount(pendingBranch, parentComponent, suspense); // ... // 创建隐藏容器 suspense.hiddenContainer = createElement(&quot;div&quot;); // 处于 fallback 态 if (isInFallback) { // 挂载新的分支到隐藏容器中 patch( null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized ); // 没有依赖则直接 resolve if (suspense.deps &lt;= 0) { suspense.resolve(); } else { // 激活分支和 newFallback 进行 diff patch( activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context isSVG, slotScopeIds, optimized ); setActiveBranch(suspense, newFallback); } } else if (activeBranch &amp;&amp; isSameVNodeType(newBranch, activeBranch)) { // 激活分支和新分支进行 diff patch( activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized ); suspense.resolve(true); } else { // 挂载新分支到隐藏分支 patch( null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized ); if (suspense.deps &lt;= 0) { suspense.resolve(); } } } } else { if (activeBranch &amp;&amp; isSameVNodeType(newBranch, activeBranch)) { // activeBranch 和 newBranch 进行 diff patch( activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized ); setActiveBranch(suspense, newBranch); } else { // ... // 挂载新分支到隐藏分支 patch( null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized ); // ... } }} 这个函数核心作用是通过判断 ssConent、ssFallback、pendingBranch、activeBranch 的内容，进行不同条件的 diff。 diff 完成后的工作和上面初始化的过程是大致一样的，会进行异步依赖 deps 数目的判断，如果没有依赖 deps 则直接进行 suspense.resolve。","link":"/2023/08/05/vue/%E5%85%B6%E4%BB%96/%E5%86%85%E7%BD%AE%E7%BB%84%E4%BB%B6/Suspense/"},{"title":"KeepAlive","text":"KeepAlive 保活原理 组件是通过类似于 LRU 的缓存机制来缓存的，并为缓存的组件 vnode 的 shapeFlag 属性打上 COMPONENT_KEPT_ALIVE 属性，当组件在 processComponent 挂载时，如果存在 COMPONENT_KEPT_ALIVE 属性，则会执行激活函数，激活函数内执行具体的缓存节点挂载逻辑。 缓存不是越多越好，因为所有的缓存节点都会被存在 cache 中，如果过多，则会增加内存负担。 丢弃的方式就是在缓存重新被激活时，之前缓存的 key 会被重新添加到队首，标记为最近的一次缓存，如果缓存的实例数量即将超过指定的那个最大数量，则最久没有被访问的缓存实例将被丢弃。 Vue 内置了 KeepAlive 组件，实现缓存多个组件实例切换时，完成对卸载组件实例的缓存，从而使得组件实例在来会切换时不会被重复创建，又是一个空间换时间的典型例子。示例： 12345&lt;template&gt; &lt;KeepAlive&gt; &lt;component :is=&quot;activeComponent&quot; /&gt; &lt;/KeepAlive&gt;&lt;/template&gt; 当动态组件在随着 activeComponent 变化时，如果没有 KeepAlive 做缓存，那么组件在来回切换时就会进行重复的实例化，这里就是通过 KeepAlive 实现了对不活跃组件的缓存。 123456789101112131415161718const KeepAliveImpl = { // 组件名称 name: `KeepAlive`, // 区别于其他组件的标记 __isKeepAlive: true, // 组件的 props 定义 props: { include: [String, RegExp, Array], exclude: [String, RegExp, Array], max: [String, Number] }, setup(props, {slots}) { // ... // setup 返回一个函数 return () =&gt; { // ... } } KeepAlive 组件中，通过 __isKeepAlive 属性来完成对这个内置组件的特殊标记，这样外部可以通过 isKeepAlive 函数来做区分： 1const isKeepAlive = (vnode) =&gt; vnode.type.__isKeepAlive; 紧接着定义了 KeepAlive 的一些 props： include 表示包含哪些组件可被缓存 exclude 表示排除那些组件 max 则表示最大的缓存数 最后实现了一个 setup 函数，该函数返回了一个函数，那么这个函数将会被当做节点 render 函数。了解了 KeepAlive 的整体骨架后。 KeepAlive 的 render 函数render 函数的源码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384const KeepAliveImpl = { // ... setup(props, { slot }) { // ... return () =&gt; { // 记录需要被缓存的 key pendingCacheKey = null // ... // 获取子节点 const children = slots.default() const rawVNode = children[0] if (children.length &gt; 1) { // 子节点数量大于 1 个，不会进行缓存，直接返回 current = null return children } else if ( !isVNode(rawVNode) || (!(rawVNode.shapeFlag &amp; ShapeFlags.STATEFUL_COMPONENT) &amp;&amp; !(rawVNode.shapeFlag &amp; ShapeFlags.SUSPENSE)) ) { current = null return rawVNode } // suspense 特殊处理，正常节点就是返回节点 vnode let vnode = getInnerChild(rawVNode) const comp = vnode.type // 获取 Component.name 值 const name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp) // 获取 props 中的属性 const { include, exclude, max } = props // 如果组件 name 不在 include 中或者存在于 exclude 中，则直接返回 if ( (include &amp;&amp; (!name || !matches(include, name))) || (exclude &amp;&amp; name &amp;&amp; matches(exclude, name)) ) { current = vnode return rawVNode } // 缓存相关，定义缓存 key const key = vnode.key == null ? comp : vnode.key // 从缓存中取值 const cachedVNode = cache.get(key) // clone vnode，因为需要重用 if (vnode.el) { vnode = cloneVNode(vnode) if (rawVNode.shapeFlag &amp; ShapeFlags.SUSPENSE) { rawVNode.ssContent = vnode } } // 给 pendingCacheKey 赋值，将在 beforeMount/beforeUpdate 中被使用 pendingCacheKey = key // 如果存在缓存的 vnode 元素 if (cachedVNode) { // 复制挂载状态 // 复制 DOM vnode.el = cachedVNode.el // 复制 component vnode.component = cachedVNode.component // 增加 shapeFlag 类型 COMPONENT_KEPT_ALIVE vnode.shapeFlag |= ShapeFlags.COMPONENT_KEPT_ALIVE // 把缓存的 key 移动到到队首 keys.delete(key) keys.add(key) } else { // 如果缓存不存在，则添加缓存 keys.add(key) // 如果超出了最大的限制，则移除最早被缓存的值 if (max &amp;&amp; keys.size &gt; parseInt(max as string, 10)) { pruneCacheEntry(keys.values().next().value) } } // 增加 shapeFlag 类型 COMPONENT_SHOULD_KEEP_ALIVE，避免被卸载 vnode.shapeFlag |= ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE current = vnode // 返回 vnode 节点 return isSuspense(rawVNode.type) ? rawVNode : vnode } }} 返回的这个 render 函数执行的结果就是返回被 KeepAlive 包裹的子节点的 vnode， 只不过在返回子节点的过程中做了很多处理而已，如果子节点数量大于一个，那么将不会被 keepAlive，直接返回子节点的 vnode，如果组件 name 不在用户定义的 include 中或者存在于 exclude 中，也会直接返回子节点的 vnode。 缓存设计缓存步骤，首先定义了一个 pendingCacheKey 变量，用来作为 cache 的缓存 key。对于初始化的 KeepAlive 组件的时候，此时还没有缓存，那么只会将 key 添加到 keys 这样一个 Set 的数据结构中，在组件 onMounted 和 onUpdated 钩子中进行缓存组件的 vnode 收集，因为这个时候收集到的 vnode 节点是稳定不会变的缓存。 123456789const cacheSubtree = () =&gt; { if (pendingCacheKey != null) { // 以 pendingCacheKey 作为key 进行缓存收集 cache.set(pendingCacheKey, getInnerChild(instance.subTree)); }};onMounted(cacheSubtree);onUpdated(cacheSubtree); props 中还有一个 max 变量用来标记最大的缓存数量，这个缓存策略就是类似于 LRU 缓存 的方式实现的。在缓存重新被激活时，之前缓存的 key 会被重新添加到队首，标记为最近的一次缓存，如果缓存的实例数量即将超过指定的那个最大数量，则最久没有被访问的缓存实例将被销毁，以便为新的实例腾出空间。 最后，当缓存的节点被重新激活时，则会将缓存中的节点的 el 属性赋值给新的 vnode 节点，从而减少了再进行 patch 生成 DOM 的过程，这里也说明了 KeepAlive 核心目的就是缓存 DOM 元素。 激活态设计上述源码中，当组件被添加到 KeepAlive 缓存池中时，也会为 vnode 节点的 shapeFlag 添加两额外的两个属性，分别是 COMPONENT_KEPT_ALIVE 和 COMPONENT_SHOULD_KEEP_ALIVE。当一个节点被标记为 COMPONENT_KEPT_ALIVE 时，会在 processComponent 时进行特殊处理： 12345678910111213141516171819202122232425262728const processComponent = (...) =&gt; { if (n1 == null) { // 处理 KeepAlive 组件 if (n2.shapeFlag &amp; ShapeFlags.COMPONENT_KEPT_ALIVE) { // 执行 activate 钩子 ;(parentComponent!.ctx as KeepAliveContext).activate( n2, container, anchor, isSVG, optimized ) } else { mountComponent( n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized ) } } else { // 更新组件 }} 在 processComponent 阶段如果是 keepAlive 的组件，在挂载过程中，不会执行执行 mountComponent 的逻辑，因为已经缓存好了，所以只需要再次调用 activate 激活就好了： 12345678910111213141516171819202122232425262728293031323334353637const KeepAliveImpl = { // ... setup(props, { slot }) { sharedContext.activate = (vnode, container, anchor, isSVG, optimized) =&gt; { // 获取组件实例 const instance = vnode.component! // 将缓存的组件挂载到容器中 move(vnode, container, anchor, MoveType.ENTER, parentSuspense) // 如果 props 有变动，还是需要对 props 进行 patch patch( instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, vnode.slotScopeIds, optimized ) // 执行组件的钩子函数 queuePostRenderEffect(() =&gt; { instance.isDeactivated = false // 执行 onActivated 钩子 if (instance.a) { invokeArrayFns(instance.a) } // 执行 onVnodeMounted 钩子 const vnodeHook = vnode.props &amp;&amp; vnode.props.onVnodeMounted if (vnodeHook) { invokeVNodeHook(vnodeHook, instance.parent, vnode) } }, parentSuspense) } // ... }} activate 激活函数，核心就是通过 move 方法，将缓存中的 vnode 节点直接挂载到容器中，同时为了防止 props 变化导致组件变化，也会执行 patch 方法来更新组件，此时的 patch 函数的调用是会传入新老子节点的，所以只会进行 diff 而不会进行重新创建。 当这一切都执行完成后，最后再通过 queuePostRenderEffect 函数，将用户定义的 onActivated 钩子放到状态更新流程后执行。 卸载态设计另一个标记态：COMPONENT_SHOULD_KEEP_ALIVE，组件的卸载函数 unmount 的设计： 123456789const unmount = (vnode, parentComponent, parentSuspense, doRemove = false) =&gt; { // ... const { shapeFlag } = vnode if (shapeFlag &amp; ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE) { ;(parentComponent!.ctx as KeepAliveContext).deactivate(vnode) return } // ...} 如果 shapeFlag 上存在 COMPONENT_SHOULD_KEEP_ALIVE 属性的话，那么将会执行 ctx.deactivate 方法，deactivate 函数的定义： 12345678910111213141516171819202122232425262728const KeepAliveImpl = { // ... setup(props, { slot }) { // 创建一个隐藏容器 const storageContainer = createElement('div') sharedContext.deactivate = (vnode: VNode) =&gt; { // 获取组件实例 const instance = vnode.component! // 将组件移动到隐藏容器中 move(vnode, storageContainer, null, MoveType.LEAVE, parentSuspense) // 执行组件的钩子函数 queuePostRenderEffect(() =&gt; { // 执行组件的 onDeactivated 钩子 if (instance.da) { invokeArrayFns(instance.da) } // 执行 onVnodeUnmounted const vnodeHook = vnode.props &amp;&amp; vnode.props.onVnodeUnmounted if (vnodeHook) { invokeVNodeHook(vnodeHook, instance.parent, vnode) } instance.isDeactivated = true }, parentSuspense) } // ... }} 卸载态函数 deactivate 核心工作就是将页面中的 DOM 移动到一个隐藏不可见的容器 storageContainer 当中，这样页面中的元素就被移除了。当这一切都执行完成后，最后再通过 queuePostRenderEffect 函数，将用户定义的 onDeactivated 钩子放到状态更新流程后执行。","link":"/2023/08/05/vue/%E5%85%B6%E4%BB%96/%E5%86%85%E7%BD%AE%E7%BB%84%E4%BB%B6/KeepAlive/"},{"title":"Teleport","text":"Teleport 如何实现选择性挂载 Teleport 内置组件的功能是可以将一个组件内部的一部分 vnode 元素 “传送” 到该组件的 DOM 结构外层的位置去挂载。普通组件挂载如下： 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;!-- 这里是 dialog 组件的容器逻辑 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { mounted() { // 在 dom 被挂载完成后，再转移到 body 上 document.body.appendChild(this.$el); }, destroyed() { // 在组件被销毁之前，移除 DOM this.$el.parentNode.removeChild(this.$el); }, };&lt;/script&gt; 这么做确实可是实现挂载到特定容器中，但这样一方面让 Dialog 组件内部需要维护复杂的 DOM 节点转换的逻辑，另一方面导致了浏览器需要进行 2 次刷新操作，一次初始化挂载，一次迁移。 所以 Vue 3 提供了 Teleport 组件，以简便的方式高性能的完成节点的转移工作: 12345&lt;Teleport to=&quot;body&quot;&gt; &lt;div class=&quot;modal&quot;&gt; &lt;p&gt;Hello from the modal!&lt;/p&gt; &lt;/div&gt;&lt;/Teleport&gt; Teleport 的挂载123456789101112131415161718192021222324export const TeleportImpl = { // 组件标记 __isTeleport: true, process(...) { // ... // 初始化的逻辑 if (n1 === null) { // ... } else { // ... // 更新逻辑 } }, // 卸载的逻辑 remove(...) { // ... }, // 移动的逻辑 move: moveTeleport, // ...} 这块的逻辑集中在组件的 process 函数中，process 函数是在渲染器 renderer 的 patch 函数中被调用的，渲染器 patch 函数内部会根据 vnode 的 type 和 shapeFlag 的类型调用不同的处理函数，而 &lt;Teleport&gt; 组件的 process 正是在这里被判断调用的： 12345678910111213141516171819202122232425262728293031const patch = (n1, n2, container, anchor, ...) =&gt; { // ... const { type, ref, shapeFlag } = n2 switch (type) { // 根据 type 类型处理 case Text: // 对文本节点的处理 processText(n1, n2, container, anchor) break // 这里省略了一些其他节点处理，比如注释、Fragment 节点等等 // ... default: // 根据 shapeFlag 来处理 // ... else if (shapeFlag &amp; ShapeFlags.TELEPORT) { // 对 Teleport 节点进行处理 type.process( n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals ); } }} process 中是如何完成对 Teleport 中的节点进行挂载的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677export const TeleportImpl = { // 组件标记 __isTeleport: true, process( n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals ) { // 从内在对象上结构关键功能函数 const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment }, } = internals; // 是否禁用 const disabled = isTeleportDisabled(n2.props); let { shapeFlag, children, dynamicChildren } = n2; // 初始化的逻辑 if (n1 == null) { // 向主视图中插入锚点 const placeholder = (n2.el = __DEV__ ? createComment(&quot;teleport start&quot;) : createText(&quot;&quot;)); const mainAnchor = (n2.anchor = __DEV__ ? createComment(&quot;teleport end&quot;) : createText(&quot;&quot;)); insert(placeholder, container, anchor); insert(mainAnchor, container, anchor); // 获取需要挂载的位置元素，如果目标元素不存在于DOM中，则返回 null const target = (n2.target = resolveTarget(n2.props, querySelector)); // 目标挂载节点的锚点 const targetAnchor = (n2.targetAnchor = createText(&quot;&quot;)); // 如果存在目标元素 if (target) { // 将锚点插入到目标元素当中 insert(targetAnchor, target); isSVG = isSVG || isTargetSVG(target); } const mount = (container: RendererElement, anchor: RendererNode) =&gt; { // teleport 子节点需要是个数组 // 挂载子节点 if (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) { mountChildren( children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ); } }; // 如果禁用 teleport 则直接挂载到当前渲染节点中 if (disabled) { mount(container, mainAnchor); } else if (target) { // 否则，以 targetAnchor 为参照物进行挂载 mount(target, targetAnchor); } } else { // 进入更新逻辑 } },}; teleport 节点在开发环境会被渲染的效果： 1234567&lt;template&gt; &lt;Teleport to=&quot;body&quot;&gt; &lt;div class=&quot;modal&quot;&gt; &lt;p&gt;Hello from the modal!&lt;/p&gt; &lt;/div&gt; &lt;/Teleport&gt;&lt;/template&gt; 上述的模版，的渲染结果如下： 已经被渲染到 body 元素当中，除了这个变化外，之前的容器中，还多了两个额外的注释符： 12&lt;!--teleport start--&gt;&lt;!--teleport end--&gt; 首先，在初始化中，会先创建两个占位符，分别是 placeholder 和 mainAnchor 然后再讲这两个占位符挂载到组件容器中，这两个占位符也就是上文中的注释节点。 接着又创建了一个目标节点的占位符 targetAnchor 这个则会被挂载到目标容器中，只不过这里是个文本节点，所以在 DOM 上没有体现出来，把这里稍微改一下： 1const targetAnchor = (n2.targetAnchor = createComment(&quot;teleport target&quot;)); 再观察 DOM 的渲染结果： 最后再根据 disabled 这个 props 属性来判断当前的节点需要采用哪种方式渲染，如果 disabled = true 则会以 mainAnchor 为参考节点进行挂载，也就是挂载到主容器中，否则会以 targetAnchor 为参考节点进行挂载，挂载到目标元素容器中。至此，完成节点的初始化挂载逻辑。 Teleport 的更新如果 Teleport 组件需要进行更新，则会进入更新的逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105export const TeleportImpl = { // 组件标记 __isTeleport: true, process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) { // 从内在对象上结构关键功能函数 const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: {insert, querySelector, createText, createComment} } = internals // 是否禁用 const disabled = isTeleportDisabled(n2.props) let {shapeFlag, children, dynamicChildren} = n2 // 初始化的逻辑 if (n1 == null) { // ... } else { // 从老节点上获取相关参照系等属性 n2.el = n1.el const mainAnchor = (n2.anchor = n1.anchor)! const target = (n2.target = n1.target)! const targetAnchor = (n2.targetAnchor = n1.targetAnchor)! // 之前是不是禁用态 const wasDisabled = isTeleportDisabled(n1.props) // 当前的渲染容器 const currentContainer = wasDisabled ? container : target // 参照节点 const currentAnchor = wasDisabled ? mainAnchor : targetAnchor isSVG = isSVG || isTargetSVG(target) // 通过 dynamicChildren 更新节点 if (dynamicChildren) { // fast path when the teleport happens to be a block root patchBlockChildren( n1.dynamicChildren!, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds ) traverseStaticChildren(n1, n2, true) } else if (!optimized) { // 全量更新 patchChildren( n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false ) } if (disabled) { if (!wasDisabled) { // enabled -&gt; disabled // 移动回主容器 moveTeleport( n2, container, mainAnchor, internals, TeleportMoveTypes.TOGGLE ) } } else { // 目标元素被改变 if ((n2.props &amp;&amp; n2.props.to) !== (n1.props &amp;&amp; n1.props.to)) { // 获取新的目标元素 const nextTarget = (n2.target = resolveTarget( n2.props, querySelector )) // 移动到新的元素当中 if (nextTarget) { moveTeleport( n2, nextTarget, null, internals, TeleportMoveTypes.TARGET_CHANGE ) } } else if (wasDisabled) { // disabled -&gt; enabled // 移动到目标元素中 moveTeleport( n2, target, targetAnchor, internals, TeleportMoveTypes.TOGGLE ) } } } },} 首先 Teleprot 组件的更新需要和普通节点更新一样进行子节点的 diff。然后会判断 Teleport 组件的 props 是否有变更，主要就是 disabled 和 to 这两个参数。 如果 disabled 变化，无非就是从 可用 -&gt; 不可用 或者从 不可用 -&gt; 可用。从 可用 -&gt; 不可用 就是将原来挂在在 target 容器中的节点重新移动到主容器中，而从 不可用 -&gt; 可用 就是将主容器中的节点再挂载到 target 中。 如果 to 这个参数变化了，那么就需要重新寻找目标节点，再进行挂载。 Teleport 的移除当组件卸载时，需要移除 Teleport 组件，下面是卸载对于 Teleport 组件的处理： 123456789101112131415161718192021const unmount = ( vnode, parentComponent, parentSuspense, doRemove, optiomized) =&gt; { // ... if (shapeFlag &amp; ShapeFlags.TELEPORT) { vnode.type.remove( vnode, parentComponent, parentSuspense, optimized, internals, doRemove ); } // ...}; unmount 卸载函数对于 Teleport 组件的处理就是直接调用 remove 方法： 12345678910111213141516171819202122232425262728export const TeleportImpl = { // 组件标记 __isTeleport: true, remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) { const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode // 如果存在 target，移除 targetAnchor if (target) { hostRemove(targetAnchor!) } // 在未禁用状态下，需要卸载 teleport 的子元素 if (doRemove || !isTeleportDisabled(props)) { hostRemove(anchor!) if (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) { for (let i = 0; i &lt; children.length; i++) { const child = children[i] unmount( child, parentComponent, parentSuspense, true, !!child.dynamicChildren ) } } } }} remove 方法的操作，首先先移除掉 targetAnchor 锚点内容，然后再调用 unmount 函数挨个卸载子组件，从而完成卸载功能。 Teleport 相比于之前的那种挂载方式他的性能优势就在于 Teleport 节点的挂载是在 patch 阶段进行的，也就是在 patch 阶段就确定了需要挂载到哪里，而不会出现先挂在到主容器再迁移到目标容器的情况。","link":"/2023/08/05/vue/%E5%85%B6%E4%BB%96/%E5%86%85%E7%BD%AE%E7%BB%84%E4%BB%B6/Teleport/"},{"title":"Transition","text":"Transition 实现 Transition 组件本身是一个无状态组件，内部本身不渲染任何额外的 DOM 元素，Transition 渲染的是组件嵌套的第一个子元素节点。 如果子元素是应用了 CSS 过渡或动画，Transition 组件会在子元素节点渲染适当时机，动态为子元素节点增加或删除对应的 class。 如果有为 Transition 定义一些钩子函数，那么这些钩子函数会被合入到子节点的关键生命周期 beforeEnter、enter、leave 中调用执行，通过 setTransitionHooks 被设置到子节点的 transition 属性中。 Trasition 组件支持了 CSS 过渡动画、CSS 动画、Javascript 钩子 几种模式 基于 CSS 的过渡效果示例： 123456789101112131415161718&lt;template&gt; &lt;button @click=&quot;show = !show&quot;&gt;Toggle&lt;/button&gt; &lt;Transition&gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/Transition&gt;&lt;/template&gt;&lt;style&gt; .v-enter-active, .v-leave-active { transition: opacity 0.5s ease; } .v-enter-from, .v-leave-to { opacity: 0; }&lt;/style&gt; 官网 css 过渡动画类名定义： v-enter-from：进入动画的起始状态。在元素插入之前添加，在元素插入完成后的下一帧移除。 v-enter-active：进入动画的生效状态。应用于整个进入动画阶段。在元素被插入之前添加，在过渡或动画完成之后移除。这个 class 可以被用来定义进入动画的持续时间、延迟与速度曲线类型。 v-enter-to：进入动画的结束状态。在元素插入完成后的下一帧被添加 (也就是 v-enter-from 被移除的同时)，在过渡或动画完成之后移除。 v-leave-from：离开动画的起始状态。在离开过渡效果被触发时立即添加，在一帧后被移除。 v-leave-active：离开动画的生效状态。应用于整个离开动画阶段。在离开过渡效果被触发时立即添加，在过渡或动画完成之后移除。这个 class 可以被用来定义离开动画的持续时间、延迟与速度曲线类型。 v-leave-to：离开动画的结束状态。在一个离开动画被触发后的下一帧被添加 (也就是 v-leave-from 被移除的同时)，在过渡或动画完成之后移除。 这里存在几个问题： 硬编码了 transiton 动画，没有实现 animate 动画。 不够抽象，难以复用到后续组件。 Vue 实现Transition 组件： 1234export const Transition = (props, { slots }) =&gt; h(BaseTransition, resolveTransitionProps(props), slots);Transition.displayName = &quot;Transition&quot;; Transition 组件是一个函数式组件，本身就是一个渲染函数 Vue 对 Transtion 内置组件的功能定义就是只是一个 容器 ，一个搬运工，需要渲染 DOM，那就不需要 template，本身不需要维护任何状态。所以这里直接通过一个函数式组件定义了 Transition 组件。 该组件核心功能就是一个渲染 BaseTransition 组件，并为期传入处理好的 props 和内部挂载的 slot。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104const BaseTransitionImpl = { name: `BaseTransition`, props: { // ... }, setup(props, { slots }) { // 当前渲染的组价实例 const instance = getCurrentInstance()! const state = useTransitionState() return () =&gt; { /** * 这里都是进入状态需要定义的内容 */ // 获取子节点 const children = slots.default &amp;&amp; getTransitionRawChildren(slots.default(), true) if (!children || !children.length) { return } let child = children[0] // 这里 props 不需要响应式追踪，为了更好的性能，去除响应式 const rawProps = toRaw(props) const { mode } = rawProps // 获取当前的容器节点 const innerChild = getKeepAliveChild(child) if (!innerChild) { return emptyPlaceholder(child) } // 获取进入状态的调用函数 const enterHooks = resolveTransitionHooks( innerChild, rawProps, state, instance ) // 为子节点添加进入 hooks 属性 setTransitionHooks(innerChild, enterHooks) /** * 下面都是离开状态需要定义的内容 */ // 离开状态中，之前的节点就是旧节点了 const oldChild = instance.subTree const oldInnerChild = oldChild &amp;&amp; getKeepAliveChild(oldChild) let transitionKeyChanged = false if ( oldInnerChild &amp;&amp; oldInnerChild.type !== Comment &amp;&amp; (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged) ) { // 获取离开状态的调用函数 const leavingHooks = resolveTransitionHooks( oldInnerChild, rawProps, state, instance ) // 为子节点添加离开 hooks 属性 setTransitionHooks(oldInnerChild, leavingHooks) // out-in 模式状态切换 if (mode === 'out-in') { state.isLeaving = true // 返回空的占位符节点，当离开过渡结束后，重新渲染组件 leavingHooks.afterLeave = () =&gt; { state.isLeaving = false // 当 active = false 时，被卸载状态不需要更新 if (instance.update.active !== false) { instance.update() } instance.update() } return emptyPlaceholder(child) } else if (mode === 'in-out' &amp;&amp; innerChild.type !== Comment) { // in-out 模式状态切换，延迟移除 leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) =&gt; { // 先缓存需要移除的节点 const leavingVNodesCache = getLeavingNodesForType( state, oldInnerChild ) leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild el._leaveCb = () =&gt; { earlyRemove() el._leaveCb = undefined delete enterHooks.delayedLeave } enterHooks.delayedLeave = delayedLeave } } } // 返回子节点 return child } }} BaseTransitionImpl 的 setup 函数，核心就干了三件事儿： Step 1: 为 Transition 下的子节点添加 enterHooks。 Step 2: 为 Transition 下的子节点添加 leavingHooks。 Step 3: 处理完成后直接返回子节点作为渲染内容。 1. hooks 功能hooks 来源： 123456const leavingHooks = resolveTransitionHooks( oldInnerChild, rawProps, state, instance); rawProps 是 Transition 组件 render 函数中传入的 props 参数。 1234567891011121314151617181920212223242526272829function resolveTransitionProps(rawProps) { const baseProps = {}; // ... for (const key in rawProps) { if (!(key in DOMTransitionPropsValidators)) { baseProps[key] = rawProps[key]; } } const { name = &quot;v&quot;, type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to`, } = rawProps; // ... return extend(baseProps, { onEnter: makeEnterHook(false), onLeave: () =&gt; {}, // .... });} Vue 会在特定阶段为节点增加或删除特定 class。而这个 props 正是为了所谓的 特定的阶段 量身打造的 钩子 函数。要实现进入节点的 v-enter-from、v-enter-active、v-enter-to 类名的添加，只需要在 onEnter 进入钩子内实现逻辑： 1234567891011121314151617const makeEnterHook = (isAppear) =&gt; { return (el, done) =&gt; { // 移除 v-enter-to、v-enter-active 类名 const resolve = () =&gt; finishEnter(el, isAppear, done); // 下一帧渲染时 nextFrame(() =&gt; { // 删除 v-enter-from 类名 removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass); // 添加 v-enter-to 类名 addTransitionClass(el, isAppear ? appearToClass : enterToClass); // 动画结束时，执行 resolve 函数，即删除 v-enter-to、v-enter-active 类名 if (!hasExplicitCallback(hook)) { whenTransitionEnds(el, type, enterDuration, resolve); } }); };}; 2. hooks 执行时机hooks 将会在特定时间执行，用来对 class 进行增加或删除。比如 enter-from 至 enter-to 阶段的过渡或者动画效果的 class 被添加到DOM 元素上。考虑到 Vue 在 patch 阶段已经有生成对应的 DOM （只不过还没有被真实的挂载到页面上而已）。所以只需要在 patch 阶段做对应的 class 增删即可。 比如进入阶段的钩子函数，将会在 mountElement 中被调用： 12345678910111213141516171819// 挂载元素节点const mountElement = (vnode,...args) =&gt; { let el; let vnodeHook; const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode; // ... if (needCallTransitionHooks*) { // 执行 beforeEnter 钩子 transition.beforeEnter(el); } // ... if ((vnodeHook = props &amp;&amp; props.onVnodeMounted) || needCallTransitionHooks || dirs) { // post 各种钩子 至后置执行任务池 queuePostRenderEffect(() =&gt; { // 执行 enter 钩子 needCallTransitionHooks &amp;&amp; transition.enter(el); }, parentSuspense); }}; 离开阶段的钩子函数，在 remove 节点的时候被调用： 1234567891011121314151617181920212223242526// 移除 Vnodeconst remove = vnode =&gt; { const { type, el, anchor, transition } = vnode; // ... const performRemove = () =&gt; { hostRemove(el); if (transition &amp;&amp; !transition.persisted &amp;&amp; transition.afterLeave) { // 执行 afterLeave 钩子 transition.afterLeave(); } }; if (vnode.shapeFlag &amp; 1 ShapeFlags.ELEMENT &amp;&amp; transition &amp;&amp; !transition.persisted) { const { leave, delayLeave } = transition; // 执行 leave 钩子 const performLeave = () =&gt; leave(el, performRemove); if (delayLeave) { // 执行 delayLeave 钩子 delayLeave(vnode.el, performRemove, performLeave); } else { performLeave(); } }}; 状态流转图： JavaScript 钩子&lt;Transition&gt; 组件在动画过渡的各个阶段定义了很多钩子函数，可以通过在钩子函数内部自定义实现各种动画效果。 123456789101112&lt;Transition @before-enter=&quot;onBeforeEnter&quot; @enter=&quot;onEnter&quot; @after-enter=&quot;onAfterEnter&quot; @enter-cancelled=&quot;onEnterCancelled&quot; @before-leave=&quot;onBeforeLeave&quot; @leave=&quot;onLeave&quot; @after-leave=&quot;onAfterLeave&quot; @leave-cancelled=&quot;onLeaveCancelled&quot;&gt; &lt;!-- ... --&gt;&lt;/Transition&gt; onEnter，这些钩子函数在源码中会被合并到 Transiton 下子节点的 transition 属性上。这块的实现主要是通过 setTransitionHooks 函数来实现的： 1234567891011121314151617181920212223242526272829303132const BaseTransitionImpl = { name: `BaseTransition`, props: { // ... }, setup(props, { slots }) { return () =&gt; { // 获取进入状态的调用函数 const enterHooks = resolveTransitionHooks( innerChild, rawProps, state, instance ); // 为子节点添加进入 hooks 属性 setTransitionHooks(innerChild, enterHooks); // ... // 返回子节点 return child; }; },};// 为 vnode 添加 transition 属性function setTransitionHooks(vnode, hooks) { // ... vnode.transition = hooks;} hooks 是通过 resolveTransitionHooks 函数调用生成的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566export function resolveTransitionHooks(vnode, props, state, instance) { // 传入的各个钩子函数 const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled, } = props; // 定义调用钩子函数的方法 const callHook = (hook, args) =&gt; { hook &amp;&amp; callWithAsyncErrorHandling( hook, instance, ErrorCodes.TRANSITION_HOOK, args ); }; // 钩子函数定义 const hooks = { mode, persisted, beforeEnter(el) { let hook = onBeforeEnter; // ... // 执行 onBeforeEnter callHook(hook, [el]); }, enter(el) { let hook = onEnter; // ... // 执行 onEnter callAsyncHook(hook, [el, done]); }, leave(el, remove) { // ... // 执行 onBeforeLeave callHook(onBeforeLeave, [el]); const done = (el._leaveCb = (cancelled?) =&gt; { // ... // 执行 onLeave callAsyncHook(onLeave, [el, done]); }); }, clone(vnode) { return resolveTransitionHooks(vnode, props, state, instance); }, }; return hooks;} 一个最基础的 hooks 主要包含 beforeEnter、enter、leave 这几个阶段，将会在 patch 的环节中被执行，执行的逻辑就是 Vue 官网上描述的逻辑。 除了这几个关键阶段之外，Transiton 还支持一个 mode 来指定动画的过渡时机，举个例子，如果 mode === 'out-in'，先执行离开动画，然后在其完成之后再执行元素的进入动画。那么这个时候就需要 延迟渲染进入动画 ，则会为 leavingHooks 额外添加一个新的钩子：afterLeave，该钩子将会在离开后执行，表示着离开后再更新 DOM。 1234567891011121314const BaseTransitionImpl = { setup() { // ... if (mode === &quot;out-in&quot;) { state.isLeaving = true; // 返回空的占位符节点，当离开过渡结束后，重新渲染组件 leavingHooks.afterLeave = () =&gt; { state.isLeaving = false; instance.update(); }; return emptyPlaceholder(child); } },};","link":"/2023/08/05/vue/%E5%85%B6%E4%BB%96/%E5%86%85%E7%BD%AE%E7%BB%84%E4%BB%B6/Transition/"},{"title":"next搭建ssr","text":"基于 next 搭建 react 下的 ssr nextjs 是业内相对成熟的 SSR 服务器端渲染框架，有完善的数据同步能力，除服务器端外，还提供了静态渲染和较多开箱即用的优化能力，减少项目的开发成本。 在项目开发中，规范的 lint、 IDE 提示及调试能力一直是影响开发者开发项目效率和质量的关键因素。针对服务器端渲染，因为涉及客户端和 Api 层这几点就显得更为重要，规范的 lint、 IDE提示可以更有效地开发和规避问题，至于调试能力，因为服务器端的存在，不能像客户端渲染一样，直接在浏览器中断点调试，也需要增加额外的配置来支持。 项目初始化先对 nextjs 的项目进行初始化，nextjs 提供了脚手架来初始化项目，执行下面的命令来初始化项目： 1npx create-next-app@latest --typescript 其中 next-env.d.ts 是 nextjs 的类型文件，可以保证 ts 选择 nextjs 相关的类型，通常不需要修改，可以在提交后加到 .gitignore 中。next.config.js 是 nextjs 的构建配置，底层也是基于 Webpack 去打包的。 1234567891011121314// next.config.jsconst path = require(&quot;path&quot;);module.exports = { reactStrictMode: true, swcMinify: true, webpack: (config) =&gt; { config.resolve.alias = { ...config.resolve.alias, &quot;@&quot;: path.resolve(__dirname), }; return config; },}; tsconfig.json 中也需要加一下对应的别名解析识别（baseurl , paths）。 12345678910111213141516171819202122232425// tsconfig.json{ &quot;compilerOptions&quot;: { &quot;target&quot;: &quot;es5&quot;, &quot;lib&quot;: [&quot;dom&quot;, &quot;dom.iterable&quot;, &quot;esnext&quot;], &quot;allowJs&quot;: true, &quot;skipLibCheck&quot;: true, &quot;strict&quot;: true, &quot;forceConsistentCasingInFileNames&quot;: true, &quot;noEmit&quot;: true, &quot;esModuleInterop&quot;: true, &quot;module&quot;: &quot;esnext&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;resolveJsonModule&quot;: true, &quot;isolatedModules&quot;: true, &quot;jsx&quot;: &quot;preserve&quot;, &quot;incremental&quot;: true, &quot;baseUrl&quot;: &quot;./&quot;, &quot;paths&quot;: { &quot;@/*&quot;: [&quot;./*&quot;] } }, &quot;include&quot;: [&quot;next-env.d.ts&quot;, &quot;**/*.ts&quot;, &quot;**/*.tsx&quot;], &quot;exclude&quot;: [&quot;node_modules&quot;]} 到这里项目其实就已经初步初始化完成了，执行npm run dev打开 http://localhost:3000 就可以看到一个 nextjs 的默认服务器端渲染页面。 代码 Lint &amp; commit lintnextjs 已经内置了开箱的 eslint 能力，不需要自己进行相关的配置，可以执行下面的脚本来自动生成对应的 lint，可以覆盖大部分场景。 1npm run lint commitlint 的部分可以参照原理中 commitlint 的配置，不过需要把对应钩子下 lint 的脚本改成对应的 nextjs lint。 123456// .husky/pre-commit#!/usr/bin/env sh. &quot;$(dirname -- &quot;$0&quot;)/_/husky.sh&quot;npx commitlint --edit $1npm run lint 模块化代码提示写页面肯定会涉及样式，所以样式的配置也是很重要的。使用 sass 等超类来替代 css，相比 css， sass 等超类提供了变量定义和函数的能力，可以避免一些重复的 css 代码，使得样式的可维护性和复用性更高。sass 有支持两种语法， sass 和 scss，作为 css 超集。 Nextjs 已经提供了对 css 和 sass 的支持，所以不需要配置相关 webpack loader，只需要安装一下 sass 的依赖即可。 1npm install sass --save-dev 通常针对一个大型项目，定义多级嵌套的组件来提高页面的复用性，组件之间的样式命名是很容易重复的，所以针对非组件库的业务代码，通常会使用 css 模块化来进行相关的样式定义。 模块化会在编译的时候将样式的类名加上对应唯一的哈希值来进行区分，从而解决样式类名重复的问题，nextjs 已经内置了这部分能力，只需要将类名定义为[name].module.(css|scss)即可，不过模块化的样式调用不能直接用字符串，需要用引用的方式，比如下面的例子： 123456789101112import { FC } from &quot;react&quot;;import styles from &quot;./index.module.scss&quot;;interface IProps {}export const Demo: FC&lt;IProps&gt; = ({}) =&gt; { return ( &lt;div className={styles.demo}&gt; &lt;h1 className={styles.title}&gt;demo&lt;/h1&gt; &lt;/div&gt; );}; 不过 nextjs 并没有支持对模块化代码的识别，在页面中执行输入styles.并不会有相关的代码提示，要实现这个能力，需要用到 typescript-plugin-css-modules，这个依赖可以给 IDE 提供模块化相关的类型，配合 typescript 使用就能实现 css 的类型提示，首先安装一下依赖。 1npm install typescript-plugin-css-modules --save-dev 然后需要在 tsconfig.json 中加上对应的组件（plugins），使得 ts-server 解析的过程中，可以进行样式的识别。 1234567891011121314151617181920212223242526// tsconfig.json{ &quot;compilerOptions&quot;: { &quot;target&quot;: &quot;es5&quot;, &quot;lib&quot;: [&quot;dom&quot;, &quot;dom.iterable&quot;, &quot;esnext&quot;], &quot;allowJs&quot;: true, &quot;skipLibCheck&quot;: true, &quot;strict&quot;: true, &quot;forceConsistentCasingInFileNames&quot;: true, &quot;noEmit&quot;: true, &quot;esModuleInterop&quot;: true, &quot;module&quot;: &quot;esnext&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;resolveJsonModule&quot;: true, &quot;isolatedModules&quot;: true, &quot;jsx&quot;: &quot;preserve&quot;, &quot;incremental&quot;: true, &quot;baseUrl&quot;: &quot;./&quot;, &quot;paths&quot;: { &quot;@/*&quot;: [&quot;./*&quot;] }, &quot;plugins&quot;: [{ &quot;name&quot;: &quot;typescript-plugin-css-modules&quot; }] }, &quot;include&quot;: [&quot;next-env.d.ts&quot;, &quot;**/*.ts&quot;, &quot;**/*.tsx&quot;], &quot;exclude&quot;: [&quot;node_modules&quot;]} 打开 vscode 的 setting.json 文件，可以通过 ctrl + shift + p打开，选择 settings profiles：export settings profile。 加上下面的配置，typescript.tsserver.pluginPaths 是为了引入 ts-server 需要用中间件组件，而 typescript.tsdk 和 typescript.enablePromptUseWorkspaceTsdk 是为了指出 ts的位置，保证工作空间可以正常使用 ts 的相关 sdk 能力。 123456{ // ...前面的保持原状就可以 &quot;typescript.tsserver.pluginPaths&quot;: [&quot;typescript-plugin-css-modules&quot;], &quot;typescript.tsdk&quot;: &quot;node_modules/typescript/lib&quot;, &quot;typescript.enablePromptUseWorkspaceTsdk&quot;: true} 完成后 reload window 即可，同样可以通过上面的快捷键打开。 &gt;reload 然后用脚手架生成的代码试验一下，把 home 的模块化引用换成 scss，去掉一个类名，重新按., 可以看到已经可以了。 服务器端调试能力服务器端渲染一个静态页面的过程，请求会在服务器端执行，并且将数据注入到页面中，意味着这部分逻辑并不在客户端执行，所以在服务器端执行的时候，我们是不能直接用 Chrome 的 network 来调试的，那上面只能调试直接在客户端执行的脚本。 nextjs 也有内置相关的调试能力来帮助我们进行调试，我们只需要为 dev 命令加一个--inspect的 node option 就行，首先来安装 cross-env 的依赖来支持跨平台的环境变量添加： 1npm install cross-env --save-dev 然后在 package.json 中，加一条 debugger 的命令： 12345678// package.json{ // ... &quot;scripts&quot;: { &quot;dev&quot;: &quot;next dev&quot;, &quot;debugger&quot;: &quot;cross-env NODE_OPTIONS='--inspect' next dev&quot; }} 执行它并重新打开 http://localhost:3000，我们可以看到一个绿色的 nodejs 的小图标，点开会打开一个新的 network，这个就是服务器端 server 的 network，服务器端执行的相关代码断点可以在上面进行调试。 我们在 home 处加一个 debugger 试验一下，已经可以进行调试了。","link":"/2022/11/01/ssr/react/next/1.%E6%90%AD%E5%BB%BAnextjs%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93%E9%A1%B9%E7%9B%AE/"},{"title":"AST","text":"前几节课我们针对官网的常见需求进行了学习，包括主题化、多媒体适配、动画、分页、组件实现等，相信大家后面面对官网的常见需求，都会有自己的思路，同时我们的官网现在也已经实现了大部分功能，麻雀虽小五脏俱全。从这节课开始，我们将开始学习性能优化篇，针对一些常见性能优化问题展开学习。 官网需求的交互中，通常会有一些高分辨率图片用于展示，这些图片通常体积大、加载时间长，且占页面区域较大，如果在网速较快的情况下可能尚可，但是在低网速，类似fast 3G， slow 3G 的场景下，几百 kb，甚至几 mb的图片资源加载是难以忍受的，加上区域大，很可能会出现页面内容已经加载完成，但是图片区域长时间留白的问题。这节课我们将一起讨论下，高分辨率图在低网速下加载时，应该如何减少加载时间，达到首屏优化的目的。 静态样式首先我们先切两个大图，加在首页的位置，大小控制在 500kb 上下的清晰度（500px * 500px 2x) 即可，这种在快速 3g 的网速下，通常需要请求几十秒左右可以完全加载，可以用来说明我们这个场景。 12345678// ./pages/global.scsshtml[data-theme=&quot;dark&quot;] { --home-background-icon: url(&quot;../public/home_bg_dark.png&quot;);}html[data-theme=&quot;light&quot;] { --home-background-icon: url(&quot;../public/home_bg_light.png&quot;);} 123// ./pages/index.tsx// ...&lt;div className={styles.header}&gt;&lt;/div&gt; 12345678// ./pages/index.module.scss.header { background-image: var(--home-background-icon); background-size: 18.75rem 18.75rem; background-repeat: no-repeat; width: 18.75rem; height: 18.75rem;} 样式最后是这样的，图片的大小大致在 700kb， 正常 4g 网络下的加载时长为 7ms 左右。 我们把网速切换至 fast 3g，看看这个图片的加载时长需要多久。 可以看到需要 4s，远远超过其他的静态资源，这意味着我们页面元素加载出来后，用户需要再等好几秒图片才能缓缓加载出来，虽然现在低网速用户群体不多，但我们还是要考虑一下怎么做。针对这个问题，我在实际业务开发中有尝试过几个方案，在这里和大家分享讨论一下。 navigator.connection.effectiveType The effectiveType read-only property of the NetworkInformationinterface returns the effective type of the connection meaning one of‘slow-2g’, ‘2g’, ‘3g’, or ‘4g’. This value is determined using acombination of recently observed, round-trip time and downlink values. 这是 MDN 2020 年 网络信息接口提案中提出的最新BOM 属性，我们可以通过这个 BOM 来获取当前的流量状态，根据不同的流量状态进行图片清晰度的选择，在较低网速下的场景，我们可以选择优先加载0.5x 或是 1x 的图片，同时我们也加载 2x 的大图，通过隐藏 DOM 的方式隐性加载，然后监听 2x 资源的 onload事件，在资源加载完成时，进行类的切换即可。 这种方案在低网速下的效果是所有方案中最好的 ，用户的感知视角是，他只需要等待 0.5x 到 1x 的模糊图加载时长，不会有区域的大面积留白，同时最后也可以体验到高清图的交互。 不过这种方案毕竟还是一个实验性属性，兼容性各方面并不是很好，只有较少的浏览器支持这个属性，大家可以看下面 MDN 中显示已支持的浏览器类型。 可以看到在 IOS 上这个属性都还不支持，所以我们不采用这个方案，等过段时间如果成为了正式属性，我是更推荐大家用这种方式根据实际场景进行优化的。感兴趣的同学可以下来自己尝试一下，还是挺有意思的，思路参照上面的就可。需要注意的有两点： 考虑到兼容性问题，navigator.connection.effectiveType 的使用需要进行判空处理，避免因为 navigator.connection is not defined 的报错阻塞页面渲染，可以写成navigator?.connection?.effectiveType来进行调用。 因为是 BOM，在前面的实现篇、需求进阶篇等课程中，我们多次提到因为同构的原理，我们的模板页面会同时执行在服务器端和客户端，在服务器端是没有 BOM 等属性的注入的，如果是在 hook 以外的地方调用，我们需要对第一个元素进行判空，采用typeof navigator !== &quot;undefined&quot; &amp;&amp; navigator?.connection?.effectiveType的方式调用。 responsive images / picture浏览器有提供响应式图片的能力，分别是 img srcset 和 picture，它们都支持根据不同的像素场景自动选取不同的元素来进行适配，下面是两个 MDN 的使用例子。 12345678910// img srcset&lt;img srcset=&quot;elva-fairy-480w.jpg 480w, elva-fairy-800w.jpg 800w&quot;sizes=&quot;(max-width: 600px) 480px, 800px&quot;src=&quot;elva-fairy-800w.jpg&quot;alt=&quot;Elva dressed as a fairy&quot;&gt;// picture&lt;picture&gt; &lt;source srcset=&quot;/media/cc0-images/surfer-240-200.jpg&quot; media=&quot;(min-width: 800px)&quot;&gt; &lt;img src=&quot;/media/cc0-images/painted-hand-298-332.jpg&quot; alt=&quot;&quot; /&gt;&lt;/picture&gt; img srcset 直接根据像素比来选取适合的静态资源加载，而对于 picture, user agent 会检查每个 &lt;source&gt; 的 srcset、media 和 type 属性，来选择最匹配页面当前布局、显示设备特征等的兼容图像。 这种方案兼容性很强，不过缺陷也很明显，针对 PC端的确是需要高清图且低网速的场景，它没办法做任何处理。且如果在低像素场景下，低分辨率的图也没办法满足需求时，这个方案也是束手无策的，它的本质还是根据不同页宽来调整资源的分辨率，没办法改变高分辨率资源加载时间长的现状。 不过这两种方案在 C 端中也有广泛的应用，对于多媒体设备，可以针对不同页宽设备选取不同分辨率的资源，对性能也是有很大提高的，同学们感兴趣可以下来尝试一下。 webp WebP is a modern image format that provides superior lossless and lossycompression for images on the web. Using WebP, webmasters and webdevelopers can create smaller, richer images that make the web faster. Webp 是谷歌推出的一种新的格式，简单来说，它可以通过 jpg、 png等主流资源格式转换，达到无损画质的效果，并且相比正常的图片资源，压缩体积会减少到 40% 以上，大量主流浏览器已经支持了 webp，并且最近IOS14 及以上设备的 safari 浏览器也已经新增对 webp 的支持，只有少部分 IOS 低版本还不兼容。 这是我比较推荐大家使用的方案 ，我们以我们的 demo 官网项目为例试验一下。 首先，我们针对静态样式部分的资源进行 webp 相关的转换，转换的方式很简单，大家可以在 google 上搜索 png to webp，有很多开源免费的转换器可以帮助我们进行资源的转换。 资源压缩后，我们可以看到 webp 对应的大小为 456kb，相比当初的 700kb 减少了近 40%，接下来我们把它加到代码中，试验一下 3g 场景下实际加载的时间可以优化多少。 12345678910// ./pages/global.scsshtml[data-theme=&quot;dark&quot;] { // ... --home-background-icon-webp: url(&quot;../public/home_bg_dark.webp&quot;);}html[data-theme=&quot;light&quot;] { // ... --home-background-icon-webp: url(&quot;../public/home_bg_light.webp&quot;);} 因为一些浏览器还不支持 webp， 所以我们需要对它的兼容性进行判断，在资源请求的请求头 accept 字段中，包含了当前浏览器所支持的静态资源类型，我们可以通过这个字段来进行判断。 12345// ./utils/index.tsexport const getIsSupportWebp = (context: AppContext) =&gt; { const { headers = {} } = context.ctx.req || {}; return headers.accept?.includes(&quot;image/webp&quot;);}; 我们可以在 _app.tsx 中对所有的组件进行 isSupportWebp 的注入，这样我们每个页面模板都可以拿到这个字段。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// ./pages/_app.tsximport type { AppProps, AppContext } from &quot;next/app&quot;;import App from &quot;next/app&quot;;import { Layout, ILayoutProps } from &quot;@/components/layout&quot;;import Head from &quot;next/head&quot;;import axios from &quot;axios&quot;;import { getIsMobile, getIsSupportWebp, LOCALDOMAIN } from &quot;@/utils&quot;;import { ThemeContextProvider } from &quot;@/stores/theme&quot;;import { UserAgentProvider } from &quot;@/stores/userAgent&quot;;import { LanguageContextProvider } from &quot;@/stores/language&quot;;import &quot;./global.scss&quot;;export interface IComponentProps { isMobile?: boolean; isSupportWebp?: boolean;}const MyApp = ( data: AppProps &amp; ILayoutProps &amp; { isMobile: boolean; isSupportWebp: boolean }) =&gt; { const { Component, pageProps, navbarData, footerData, isMobile, isSupportWebp, } = data; return ( &lt;div&gt; &lt;Head&gt; &lt;title&gt;{`A Demo for 《SSR 实战：官网开发指南》(${ isMobile ? &quot;移动端&quot; : &quot;pc端&quot; })`}&lt;/title&gt; &lt;meta name=&quot;description&quot; content={`A Demo for 《SSR 实战：官网开发指南》(${ isMobile ? &quot;移动端&quot; : &quot;pc端&quot; })`} /&gt; &lt;link rel=&quot;icon&quot; href=&quot;/favicon.ico&quot; /&gt; &lt;/Head&gt; &lt;LanguageContextProvider&gt; &lt;ThemeContextProvider&gt; &lt;UserAgentProvider&gt; &lt;Layout navbarData={navbarData} footerData={footerData}&gt; &lt;Component {...pageProps} isMobile={isMobile} isSupportWebp={isSupportWebp} /&gt; &lt;/Layout&gt; &lt;/UserAgentProvider&gt; &lt;/ThemeContextProvider&gt; &lt;/LanguageContextProvider&gt; &lt;/div&gt; );};MyApp.getInitialProps = async (context: AppContext) =&gt; { const pageProps = await App.getInitialProps(context); const { data = {} } = await axios.get(`${LOCALDOMAIN}/api/layout`); return { ...pageProps, ...data, isMobile: getIsMobile(context), isSupportWebp: getIsSupportWebp(context), };};export default MyApp; 接下来我们只需要在 index.tsx 中引入对应的 webp 资源就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134import type { NextPage } from &quot;next&quot;;import styles from &quot;./index.module.scss&quot;;import cName from &quot;classnames&quot;;import { useContext, useEffect, useRef, useState } from &quot;react&quot;;import { ThemeContext } from &quot;@/stores/theme&quot;;import { Pagination } from &quot;@douyinfe/semi-ui&quot;;import axios from &quot;axios&quot;;import { LOCALDOMAIN } from &quot;@/utils&quot;;import { IArticleIntro } from &quot;./api/articleIntro&quot;;import App from &quot;next/app&quot;;import { IComponentProps } from &quot;./_app&quot;;interface IProps { title: string; description: string; articles: { list: { label: string; info: string; link: string; }[]; total: number; };}const Home: NextPage&lt;IProps &amp; IComponentProps&gt; = ({ title, description, articles, isSupportWebp,}) =&gt; { const [content, setContent] = useState(articles); const mainRef = useRef&lt;HTMLDivElement&gt;(null); const { theme } = useContext(ThemeContext); useEffect(() =&gt; { mainRef.current?.classList.remove(styles.withAnimation); window.requestAnimationFrame(() =&gt; { mainRef.current?.classList.add(styles.withAnimation); }); }, [theme]); return ( &lt;div className={styles.container}&gt; &lt;main className={cName([styles.main, styles.withAnimation])} ref={mainRef} &gt; &lt;div className={cName({ [styles.header]: true, [styles.headerWebp]: isSupportWebp, })} &gt;&lt;/div&gt; &lt;h1 className={styles.title}&gt;{title}&lt;/h1&gt; &lt;p className={styles.description}&gt;{description}&lt;/p&gt; &lt;div className={styles.grid}&gt; {content?.list?.map((item, index) =&gt; { return ( &lt;div key={index} className={styles.card} onClick={(): void =&gt; { window.open( item.link, &quot;blank&quot;, &quot;noopener=yes,noreferrer=yes&quot; ); }} &gt; &lt;h2&gt;{item.label} &amp;rarr;&lt;/h2&gt; &lt;p&gt;{item.info}&lt;/p&gt; &lt;/div&gt; ); })} &lt;div className={styles.paginationArea}&gt; &lt;Pagination total={content?.total} pageSize={6} onPageChange={(pageNo) =&gt; { axios .post(`${LOCALDOMAIN}/api/articleIntro`, { pageNo, pageSize: 6, }) .then(({ data }) =&gt; { setContent({ list: data.list.map((item: IArticleIntro) =&gt; { return { label: item.label, info: item.info, link: `${LOCALDOMAIN}/article/${item.articleId}`, }; }), total: data.total, }); }); }} /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/main&gt; &lt;/div&gt; );};Home.getInitialProps = async (context) =&gt; { const { data: homeData } = await axios.get(`${LOCALDOMAIN}/api/home`); const { data: articleData } = await axios.post( `${LOCALDOMAIN}/api/articleIntro`, { pageNo: 1, pageSize: 6, } ); return { title: homeData.title, description: homeData.description, articles: { list: articleData.list.map((item: IArticleIntro) =&gt; { return { label: item.label, info: item.info, link: `${LOCALDOMAIN}/article/${item.articleId}`, }; }), total: articleData.total, }, };};export default Home; 12345// ./pages/index.module.scss// ....headerWebp { background-image: var(--home-background-icon-webp);} 然后我们来看看效果，fast 3g 下对应资源的加载时间 从 4s 减少到了 3s，优化了近 25%！ webp 的小彩蛋同学们可能对 webp 的原理并不清楚，这里值得一提的是，为什么 webp 可以在保证无损画质的前提下，缩小这么多体积呢？很有意思的一件事是，当处于极快网速的情况下， webp 相比同画质的 png 的加载时间反而会更长 ，即使它相比其他类型的资源，体积上缩小了整整 40% 以上。为什么会有这样的现象呢？ webp 的低体积并不是毫无代价的，webp 在压缩过程中进行了分块、帧内预测、量化等操作，这些操作是减少 webp体积的核心原因，不过作为交换的是，相比 jpg、 png 等资源，它具备更长的解析时长，不过这个是不受网速等影响的，因为是浏览器内置的能力。 所以这也是为什么在极快网速的情况下，webp 的加载时间有时会呈现为负优化的原因，因为减少的资源请求时间不足够抵消掉额外的解析时间，不过这个时间差值并不长，几毫秒在用户体验的过程中是无伤大雅的。 但是在低网速的场景下，这个优化比例是极高的，因为 40%的体积大小，对于低网速场景下，请求时间将会是质的提高，相比之下，几毫秒的解析时长就无关紧要了。上面我们测试的是 fast3g，同学们可以下来试试 slow 3g 的效果，随着网络质量的变差，这个优化会更加显著！ 小结这一节课我们学习了怎么针对低网速场景对高分辨率图片进行首屏优化，我们分别对比了 navigator.connection.effectiveType、 responsive images / picture 和 webp 三种方案。 其中 navigator.connection.effectiveType 仍然处于 MDN 提案试验属性的阶段，兼容性不高，虽然效果很理想，但是并不建议大家使用。 responsive images / picture 可以针对不同页宽的图片选取不同的资源，在 C 端优化中有广泛的使用，但是并不能解决我们低网速高分辨率加载时间长的痛点。 最推荐大家使用的是 google 推出的一个新的格式 webp，虽然仍然未适配所有的浏览器，但是主流的浏览器和 IOS高版本浏览器都已经支持了这个方案，它通过更细致的解析，可以大幅度减少同画质资源的体积，虽然会有相对更多一些的解析时长，但是在低网速场景，优化的体积可以大幅度地减少加载时间，从而优化首屏，随着网络质量的变差，这个优化会更加显著。 IOS 是我们站点一种常用的设备类型，相比安卓和 PC 等浏览器，它具备更多自己的特性，我们实际开发中往往需要兼容这些场景。下一节课我们将来探讨，针对 IOS 常见的橡皮筋和 300ms delay 问题，我们可以怎么去优化解决。","link":"/2023/02/01/ssr/react/next/10.%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96,%E9%92%88%E5%AF%B9%E5%A4%A7%E5%9B%BE%E4%BD%8E%E7%BD%91%E9%80%9F%E5%8A%A0%E8%BD%BD%E5%9C%BA%E6%99%AF/"},{"title":"AST","text":"上节课我们学习了针对低网速场景，怎么对高分辨率图进行首屏优化，我们使用了 webp 的方式优化了静态资源的加载，对低网速下的首屏场景进行了优化。与首屏优化同样常见的，还有 IOS 的兼容场景。 移动端的 Web 应用用户有不少的比例是 IOS 相关设备，IOS 与安卓的规则和标准不尽相同，我们需要对这些场景进行兼容。这一节课我们就 IOS 最常见的 300ms delay 和橡皮筋问题来一起探讨一下解决的方案。 300 ms delay我们平时的开发中，事件的触发大部分都是立刻响应，但是在 IOS 中，移动端的触摸事件会有 300ms 的延迟。使用过 IOS的同学应该知道，IOS 浏览器有一个特点，可以通过双击来对屏幕页面进行缩放，这是导致 300ms延迟的核心原因。因为当一个用户点击链接后，浏览器没办法判定用户是想双击缩放，还是进行点击事件触发，所以 IOS Safari 会统一等待300ms，来判断用户是否会再次点击屏幕。 Meta 禁用缩放这个是我比较推荐的方案 ，因为 300ms 延迟的初衷是为了解决点击和缩放没办法区分的问题，针对不需要缩放的页面，我们可以通过禁用缩放来解决。事实上，大部分移动端页面都是可以避免缩放的，通过交互等样式的兼容即可。 12345// ./pages/_app.tsx// head加这两行即可// ...&lt; meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot; &gt;&lt; meta name=&quot;viewport&quot; content=&quot;initial-scale=1,maximum-scale=1&quot; &gt; 更改视口尺寸Chrome 32 版本中 Chrome 浏览器对包含 width=device-width 或者比 viewport 更小的页面禁用双击缩放，我们只需要加上下面的meta 头，就可以在 IOS 中的 chrome 浏览器解决 300ms delay 的问题，这个方案的好处是，并不会完全禁用缩放。但是IOS 默认的 Safari 浏览器没有支持这个能力，所以我们可以加上这个 meta 头来兼容视口尺寸，但并不作为这个的解决方案。 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; Touch-action在 W3C 草案 中，有提出一个 touch-action css 属性，通过设置 touch-action: none可以移除目标元素的 300ms delay，如果这个日后可以被主流浏览器支持，我更推荐大家用这种方式针对区域进行灵活的限制。 fastclick这是一个老牌的解决 300ms 延迟的轻量 JS 库，可以通过 npm 安装，且使用方式简单。 1234567window.addEventListener( &quot;load&quot;, () =&gt; { FastClick.attach(document.body); }, false); 这个依赖我也有试用过，但是我觉得并不是一个好的方案，不建议大家使用 fastclick 的方式解决这个问题，有几个原因： 对 TS 兼容性太差，fastclick 基于 JS ，虽然有 ts for fastclick 的依赖，但是不被原作者认可，并且类型定义存在问题，直接引入依赖存在问题，需要自行进入模块定义中修改，具体可参照 www.codenong.com/cs106613514… 。 包体过大，且包八年没再维护。 不能直接用于 SSR ，里面有直接用到 BOM ，在服务器端渲染的时候会有相关报错，没找到比较好的插件可以兼容这个问题。 对 fastclick 感兴趣的同学可以下来试试，最终还是建议大家采用 meta 禁用缩放的方式，兼容性和效果相对是比较理想的。 橡皮筋问题 IOS 上，当页面滚动到顶部或底部仍可向下或向上拖拽，并伴随一个弹性的效果。该效果被称为“rubber band”——橡皮筋，十分贴切。 IOS 和安卓不同，即使页面没有设置滚动，仍然可以拉扯，给人一种橡皮筋的感觉，如果是 Mac 系统的同学，可以打开 Chrome 模拟查看我们的页面，可以看到下面的效果。 那么怎么去解决这个问题呢？我们来讨论一下。 overflow 给定宽高 / 禁用 touchmove 事件大家如果尝试搜索橡皮筋的解决方案，会发现很多文章都会采用下面这两种方案去解决。但是，这两种方案是完全不可取的，会完全禁用掉下滑的滚动，对即使有滚动的页面也会影响到原有的滚动。 123456html,body { width: 100%; height: 100%; overflow: hidden；;} 1234567document.body.addEventListener( &quot;touchmove&quot;, function (e) { e.preventDefault(); }, { passive: false }); 监听滚动禁用这是我之前开发时候想到的比较 hack 的方案，IOS 橡皮筋的原理还是通过滚动，只不过与安卓不同的是，当到边界状态时，仍允许滚动，如果我们替 IOS 禁用边界的情况，理论上就可以实现对橡皮筋效果的禁用。针对上述思路，我曾经有实现如下 hook。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import { useEffect } from 'react';export const useForbidIosScroll = (): void =&gt; { let startEvent: TouchEvent; const cancelEvent = (e: TouchEvent): void =&gt; { // 有个瑕疵就是，如果是大惯性的那种滚动，浏览器该事件并不接受你禁用当前正在执行的动作 // 导致如果猛地滑动会出页面边界 if (e.cancelable) { e.preventDefault(); } }; const checkScroll = (e: TouchEvent): void =&gt; { const startY = Number(startEvent?.touches[0].pageY); const endY = Number(e?.touches[0].pageY); // 下滑且滑动到底 if (startY &gt; endY &amp;&amp; window.scrollY + window.innerHeight &gt;= document.body.scrollHeight) { cancelEvent(e); } // 上滑且滑动到顶 if (startY &lt; endY &amp;&amp; window.scrollY &lt;= 0) { cancelEvent(e); } }; useEffect(() =&gt; { const start = (e: TouchEvent): void =&gt; { startEvent = e; }; const end = (e: TouchEvent): void =&gt; { checkScroll(e); }; window.addEventListener('touchstart', start); window.addEventListener('touchmove', end, { passive: false }); return (): void =&gt; { window.removeEventListener('touchstart', start); window.removeEventListener('touchmove', end); }; }, []);}; 这个效果其实并不是很理想，即使脚本已经走到我们中断的逻辑，滚动的行为在到达边界的时候仍然不会中止。感兴趣的同学可以 cancelEvent 方法中加一个 debugger 断点验证。 The scroll event cannot be canceled. ( scroll 事件无法取消。) But you can do it by canceling these interaction events 到谷歌浏览器开发者文档里可以查看到，浏览器的事件其实分为两种，cancelable（可暂停）和 uncancelable（不可暂停），能够通过阻止默认事件的和阻止冒泡的都是可暂停的事件，滚动事件和鼠标滚轮事件，在触发的瞬间，就已经决定了要滚动到终点再停止，你只能暂停可能会影响滚动的前提的 导线事件 ，我们这个场景下，滚动事件就已经是起源的操作，不存在间接触发，所以不行。 最终方案有一个很简单的方案，并且可以完美解决14 | 自定义组件: 如何实现一个动画弹窗组件？中提到的滚动栏丢失的问题，我们给 body 进行隐藏，然后对根节点设置 100 页宽的高度， 将外部 body 的滚动移动到页面内，这样外界的滚动相关的问题都会解决 ，因为我们页面采用的实际是内部滚动。 1234567891011121314// ./pages/global.scss.forbidScroll { height: 100vh; overflow: hidden;}body { //... overflow: hidden;}#__next { height: 100vh; overflow: auto;} 大家可以看看改后的效果，发现橡皮筋的功能已经禁用了，大家可以再把之前解决弹窗的那部分代码移除，问题应该同样解决了，因为我们现在页面采用的是页面内部 div 的滚动，外部 body 的滚动相关的问题也随之解决。 小结这节课我们学习了 IOS 300ms delay 和橡皮筋问题的缘由和解决方案，我们对比了几种不同的方案，通过 meta 解决了 300ms delay，以及移除外部滚动，改用页面内滚动的方式解决了橡皮筋问题，并且我们还得到了一个意外的收获，之前在14 | 自定义组件: 如何实现一个动画弹窗组件？ 中遇到的滚动栏丢失问题也因为禁用外部滚动，改用页面内滚动而随之解决。 当然 IOS 的问题还远不止此，作为一名 C 端开发者，我们不仅要考虑常规的 B 端 ie等兼容问题，移动端的兼容问题我们也需要着重关注，后续大家遇到这类问题，大家没有思路可以到 MDN或是浏览器的开发文档中看看最新的草案，评估兼容性，可能会有额外的收获。 到这里，我们性能优化篇也就画上句号了，我们官网大部分的功能都已经实现了，从下一节课开始，我们将开始进入部署篇的学习，为上线和之后的运营做准备。下一节课，我们将先首先来学习如何对官网项目进行压力测试。","link":"/2023/02/01/ssr/react/next/11.%E8%AE%BE%E5%A4%87%E5%85%BC%E5%AE%B9/"},{"title":"AST","text":"在实际的开发中，我们会用一些集群服务器进行服务的部署，在不同的公司，这些环境可能被称为预发布环境或是泳道等。 通常在上线前，我们会对这些小流量环境进行预估流量的压测，来预估目前的小流量集群服务器能否承载对应的流量，进而评估一下，我们使用多少服务器集群部署服务，才能足够承载流量，又不至于浪费服务器资源。 在字节内部，我们有一套闭环的压测链路解决方案，来保证整个流程的维稳，但是有一些小公司或是个体团队的同学可能并没有压测等平台，也没有专业的测开同学可以协助进行分析集群分析，有没有什么 MVP 的方案可以进行简单快捷的方式进行压测，又可以得到我们需要的数据呢？ 通常针对并发的压测，业内推荐的方案大部分是 Jmeter，它是一款基于 Java实现，支持接口并发、模拟协议请求等能力的测试工具。不过本节课我们不使用 Jmeter 来进行压测，一方面它安装上不够轻量，因为基于 Java实现，所以我们需要配置 Java 的环境变量；另一方面，Jmeter提供了很多额外的能力，包括功能测试和回归测试等，我们这节课的核心需求是对官网应用“并发量”进行判定，这些功能我们都是用不上的。 我们来对比一下三个常见的开源方案，都是比较轻量且适合开发使用的压测工具，需要注意的是，本节课的压测是基于本地服务压测，对于实际上线，需要先部署在测试服务器，然后对测试环境内网域名进行压测，进而判断能否承受预估的 QPS，从而对服务集群进行扩容等操作。 Ps：不清楚怎么部署的同学可以移步到20 | 应用上线: 从官网服务域名的申请备案到服务部署 进行学习。 WebBench github.com/EZLippi/Web… Webbench 是一个在 Linux 下使用的非常简单的网站压测工具。它使用 fork() 模拟多个客户端同时访问我们设定的 URL，测试网站在压力下工作的性能，最多可以模拟 3 万个并发连接去测试网站的负载能力。 WebBench 不能支持 Windows，只能在 Linux 等类 UNIX 系统下使用，我们以 macOS 系统为例安装试试。 首先我们需要安装一下 brew，这是一个针对 macOS 和 Linux 的包管理工具，终端里直接执行下面的命令就好，很多使用 mac 系统的同学可能已经装过这个了，安装完在终端里直接输入 brew 看下有没有正常输出即可。 1/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot; 然后我们装一下 wget，它是 Linux 下的一个安装文件的工具，对应的安装包我们可以通过它下载下来。 1brew install wget 最后我们来装一下 WebBench。 12345wget http://www.ha97.com/code/webbench-1.5.tar.gztar zxvf webbench-1.5.tar.gz // 解压cd webbench-1.5makemake install 安装完以后，我们可以在终端中输入 WebBench 验证一下。 我们需要关注的参数有两个： -c: 并发量； -t: 运行时间。 我们对我们的服务简单压测试验下看看。 可以看到 200 并发，咱们本地服务是 hold 住的， 2000 并发就会出现大规模请求异常的情况，不过这个结果算比较简陋的，加上对环境和安装步骤上相对苛刻一些，所以我并不推荐大家使用这个方案。 wrk github.com/wg/wrk wrk 是一款针对 HTTP 协议的基准测试工具，它能够在单机多核 CPU 的条件下，使用系统自带的高性能 I/O 机制，如 epoll、kqueue 等，通过多线程和事件模式，对目标机器产生大量的负载。 wrk 是一款轻量级的性能测试工具，支持大多数类 UNIX 系统，不支持 Windows。不同的类 UNIX 系统安装方式也略有差异，下面以 macOS 系统为例。 我们来装一下 wrk。 1brew install wrk 装完可以在终端执行一下 wrk -v验证一下。 上面执行完以后我们可以看到它列出了 wrk 相关的参数，其中我们常用到的有三个参数： -c: 保持打开状态的 HTTP 连接总数； -d: 测试时长； -t: 使用线程。 其中连接数（c）会平分给每个线程，比如设置 -c200 -t8，那么将启用 8 个线程，每个线程处理 200/8 个请求，我们可以对 bing 搜索简单试验一下，具体参数其实大部分都是一样的，我们在 autocannon 的部分统一介绍。 其实，这个方案更多是给后端同学测吞吐率用的，包括线程等参数，具体的值不好衡量，对前端不算那么友好，感兴趣的同学可以下来试试看。 autocannon github.com/mcollina/au… 一个用 Node 编写的 HTTP/1.1 基准测试工具，受到 wrk 和 wrk2 的极大启发，支持 HTTP 管道和 HTTPS。autocannon 可以产生比 wrk 和 wrk2 更多的负载。 autocannon 是用 Node 编写的 HTTP/1.1 基准测试工具，它可以同时支持 Windows、 Mac 和 Linux 的环境，而且作为 一个 npm 包，使用上比较符合前端的开发习惯，安装更为方便，使用方式也很轻量，很推荐大家使用这种方式。 1npm i autocannon -g Autocannon 有提供一些参数来对应不同压测指数，我们常用的有 3 个： -c: 要使用的并发连接数。默认值：10 ； -p: 使用流水线请求的数量。默认值：1 ； -d: 运行秒数。默认值：10 。 同样，我们来对我们的服务做一个简单尝试，首先测试一下默认值的效果。 1autocannon http://127.0.0.1:3000 在这个 10s 的执行过程，我们如果切回 nextjs-demo 是可以看到我们的服务在飞快请求的。 最后我们可以得到这样一个数据。 这个表格怎么看呢，我给大家介绍一下每个指标对应啥，我们先看每列的指标： 2.5% / 50% / 97.5% / 99%：整个过程百分比所对应的值； Avg: 平均值； Stdev: 标准差； Max: 最大值。 对于每行的指标含义是这样的： Latency: 耗时(毫秒)； Req/Sec: QPS，吞吐量，每秒请求数； Bytes/Sec: 每秒请求字节数。 这些指标通常在对具体接口或是页面 case by case 的性能分析中会有使用，服务器资源判定我们只需要关注请求时间是否过长，或是是否存在大面积报错即可，这里我们可以看到大部分数值是正常的，也没有报错等信息。 接下来我们把并发量提高到 200， 再来看下效果，可以看到我们的服务仍然是可以 hold 住的。 1autocannon -c 200 http://127.0.0.1:3000 接下来，我们把并发量提高到 2000，再看看会得到怎样的结果。 从数据上看，我们发现所有的数据都清 0 了，说明在这个并发量下单服务器的计算支撑不下去，最下面的请求数据中也有显示 3k 个错误， 2k 个超时。 这时候我们切回 nextjs-demo 的终端可以看到，我们的服务已经崩掉了，没办法承载 2000 的并发量，如果业务需要，这时候就需要考虑给服务器集群进行扩容操作了。 小结这节课我们学习了怎么对官网应用进行上线前压测，通常大公司可能会有自己的一套压测解决方案，对于没有压测资源的同学可以采用一些轻量的开源工具来对服务进行压力测试。 我们对比了 WebBench、 wrk、 autocannon 三种开源方案，其中 WebBench 和 wrk 只能用于 Linux环境，而且压测的信息和配置不够轻量，相比之下，我更推荐大家使用 autocannon 的方案，它基于 nodejs开发，具备更符合我们开发习惯的配置和使用方式。 我们通过 autocannon 对服务进行了多个并发量的压测对比，分析出在 2000 并发下，我们的服务是支撑不住的，需要通过集群扩容等方式支持。 目前我们还只是对本地服务进行测试，正常的上线流程中，大家需要先去申请测试服务器的资源，在测试服务器上压测评估后再部署线上服务器。 我们的官网在上线后，常常需要取用户操作的数据进行 pv 等相关分析，这时候我们就需要进行一些基础的数据埋点，并且进行统计分析，下节课我们就来学习如何对用户的数据进行上报分析。","link":"/2023/02/01/ssr/react/next/12.%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"title":"AST","text":"上一节课我们对需要的 layout 数据进行相关的可视化配置，通过访问 http://localhost:1337/api/layouts?populate=deep 可以拿到我们需要的数据。 不过这样的数据是有一些乱的，有几个可以优化的点： 请求参数populate=deep是每次请求都需要带上的，我们需要所有深度的数据； 我们需要的是 data 中的数据，layout 只有一个，不需要分页相关的部分（meta）； 针对每个结构体，Strapi 为它们套上了 attributes 和 id，这个是不利于我们调用的，因为没有覆盖对应 ts 类型，会增加很多不必要的调试成本； 每个结构体都加上了 createdAt、 publishedAt、updatedAt 三个字段，实际上针对这个需求，我们是不需要这些字段的，随着接口层级的增加，过多不被使用的字段会增加我们接口的复杂度和可维护性 CMS 接口优化现在，根据上面说的几个问题，我们来优化一下我们定义的 CMS 接口，下面的内容基于github.com/czm12904337… 仓库，同学们可以对着仓库一步步来实践。 自定义返回 &amp; 移除非必要属性 同学们应该还记得，上一节课我们在介绍项目结构的时候，有提到 src/api/* 的目录下，存放着我们结构体接口的定义，其中controllers 存放着接口的控制器，每当客户端请求路由时，操作都会执行业务逻辑代码并发回响应，我们可以在其中重写 api的相关方法（find、findOne、 update 等）。 以 layout 为例，我们首先为 layout 接口加上默认的populate=deep参数，这样我们每次请求的时候就不用再加了。 12345678910111213141516171819// ./src/api/layout/controllers/layout.js&quot;use strict&quot;;/** * layout controller */const { createCoreController } = require(&quot;@strapi/strapi&quot;).factories;module.exports = createCoreController(&quot;api::layout.layout&quot;, ({ strapi }) =&gt; ({ async find(ctx) { ctx.query = { ...ctx.query, populate: &quot;deep&quot;, }; const { data } = await super.find(ctx); return data; },})); 这时候我们再尝试直接访问 http://localhost:1337/api/layouts，可以看到已经不需要加 populate 参数就可以拿到联表的数据了。 然后咱们针对上面提到的 attributes、id 和时间相关的字段定义两个深度遍历的函数来对应去除。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// ./src/utils/index.js/** * 移除对象中自动创建的时间字段 * @param obj * @returns */const removeTime = (obj) =&gt; { const { createdAt, publishedAt, updatedAt, ...params } = obj || {}; Object.getOwnPropertyNames(params).forEach((item) =&gt; { if (typeof params[item] === &quot;object&quot;) { if (Array.isArray(params[item])) { params[item] = params[item].map((item) =&gt; { return removeTime(item); }); } else { params[item] = removeTime(params[item]); } } }); return params;};/** * 移除属性和id * @param {*} obj * @returns */const removeAttrsAndId = (obj) =&gt; { const { attributes, id, ...params } = obj || {}; const newObj = { ...attributes, ...params }; Object.getOwnPropertyNames(newObj).forEach((item) =&gt; { if (typeof newObj[item] === &quot;object&quot;) { if (Array.isArray(newObj[item])) { newObj[item] = newObj[item].map((item) =&gt; { return removeAttrsAndId(item); }); } else { newObj[item] = removeAttrsAndId(newObj[item]); } } }); return newObj;};module.exports = { removeTime, removeAttrsAndId,}; 然后我们对 layout 的 find 函数返回的数据调用进行处理。 1234567891011121314151617181920// ./src/api/layout/controllers/layout.js&quot;use strict&quot;;const { removeTime, removeAttrsAndId } = require(&quot;../../../utils/index.js&quot;);/** * layout controller */const { createCoreController } = require(&quot;@strapi/strapi&quot;).factories;module.exports = createCoreController(&quot;api::layout.layout&quot;, ({ strapi }) =&gt; ({ async find(ctx) { ctx.query = { ...ctx.query, populate: &quot;deep&quot;, }; const { data } = await super.find(ctx); return removeAttrsAndId(removeTime(data[0])); },})); 再访问 http://localhost:1337/api/layouts 试试，可以看到已经精简很多了，只包含了我们需要的元信息。 接口增加跨域限制 Strapi 的接口默认不做跨域限制的，这样所有的域名都可以调用我们的接口，安全性是存在问题的，我们可以在掘金下调用试试。 没有跨域的报错，我们预期允许访问的域名只有 http://localhost:3000 和 http://localhost:1337。我们上节课有提到 config 中有相关的中间件配置，我们可以在 config/middlewares.js 中加上跨域的限制。 1234567891011121314151617181920// ./config/middlewares.jsmodule.exports = [ &quot;strapi::errors&quot;, &quot;strapi::security&quot;, { name: &quot;strapi::cors&quot;, config: { enabled: true, headers: &quot;*&quot;, origin: [&quot;http://localhost:3000&quot;, &quot;http://localhost:1337&quot;], }, }, &quot;strapi::poweredBy&quot;, &quot;strapi::logger&quot;, &quot;strapi::query&quot;, &quot;strapi::body&quot;, &quot;strapi::session&quot;, &quot;strapi::favicon&quot;, &quot;strapi::public&quot;,]; 然后我们再到掘金中试一下，发现已经会有跨域的警告了。 BFF 接口定义CMS 接口配置好了以后还不能直接在页面中调用，我们需要配置一层 BFF层，即服务于前端的数据层。因为我们通常配置的数据是站在结构体的角度的，并不一定可以由前端调用，往往还需要复杂的数据处理，为了提高数据层的复用程度，我们增加BFF 层，将 CMS 接口包一层，进行相关处理后，前端页面只调用我们定义的 BFF 层接口，不直接与 CMS 配置的接口产生交互。 在定义接口前，我们得先来了解一下 Nextjs 接口的路由是怎么配置的? 与静态页面类似，Nextjs 接口也采用文件约定式路由的方式进行配置，可以分为预定义路由、动态路由和全捕获路由，如下面的例子： 123// ./pages/api/home/test.js =&gt; api/home/test 预定义路由// ./pages/api/home/[testId].js =&gt; api/home/test, api/home/1, api/home/23 动态路由// ./pages/api/home/[...testId].js =&gt; api/home/test, api/home/test/12 全捕获路由 如果一个相同的路由，比如api/home/test，按照优先级来匹配三者，会按照预定义路由 &gt; 动态路由 &gt; 全捕获路由的顺序来匹配。 这也很好理解，因为三者匹配的精准度是逐渐下降的，如果说预定义路由是精准匹配，后两者只是模糊匹配，虽然也满足匹配场景，但是只是作为兜底，优先会以预定义路由为准。 知道了 Api 路由的原理，下面来开发我们的 BFF 层，首先定义一个接口层 ./pages/api/layout.ts， 因为后续我们会经常用到本地域名 和 CMS 域名，所以我们拿一个变量来存储它们，后续根据环境区分也很方便。 123// ./utils/index.tsexport const LOCALDOMAIN = &quot;http://127.0.0.1:3000&quot;;export const CMSDOMAIN = &quot;http://127.0.0.1:1337&quot;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// ./pages/api/layout.tsimport type { NextApiRequest, NextApiResponse } from &quot;next&quot;;import axios from &quot;axios&quot;;import { ILayoutProps } from &quot;../../components/layout&quot;;import { CMSDOMAIN } from &quot;@/utils&quot;;import { isEmpty } from &quot;lodash&quot;;const getLayoutData = ( req: NextApiRequest, res: NextApiResponse&lt;ILayoutProps&gt;) =&gt; { axios.get(`${CMSDOMAIN}/api/layouts`).then((result) =&gt; { const { copy_right, link_lists, public_number, qr_code, qr_code_image, site_number, title, } = result.data || {}; res.status(200).json({ navbarData: {}, footerData: { title, linkList: link_lists?.data?.map((item: any) =&gt; { return { title: item.title, list: item?.links?.data?.map((_item: any) =&gt; { return { label: _item.label, link: isEmpty(_item.link) ? &quot;&quot; : _item.link, }; }), }; }), qrCode: { image: `${CMSDOMAIN}${qr_code_image.data.url}`, text: qr_code, }, copyRight: copy_right, siteNumber: site_number, publicNumber: public_number, }, }); });};export default getLayoutData; 这部分代码有两个需要稍微提一下的地方： NextApiResponse 类型是 Nextjs 提供的 response 类型，它提供了一个泛型，来作为整个接口和后续请求的返回，我们可以把需要的数据类型作为泛型传进去，保证整体代码有 ts 的 lint。 这里我们返回数据用的是 json，针对数据的响应，Nextjs 有提供下面的响应 Api， 大家可以根据自己的需求选用不同的响应 Api。 res.status(code)- 设置状态码的功能。code必须是有效的 HTTP 状态码。 res.json(body)- 发送 JSON 响应。body必须是可序列化的对象。 res.send(body)- 发送 HTTP 响应。body可以是 a string，anobject或 aBuffer。 res.redirect([status,] path)- 重定向到指定的路径或 URL。status必须是有效的 HTTP 状态码。如果未指定，status默认为“307”“临时重定向”。 res.revalidate(urlPath)-使用.按需重新验证页面getStaticProps。urlPath必须是一个string。 到这里我们 BFF 接口就定义好了，我们改造一下 layout 部分的数据注入，换用接口数据。 12345678910111213141516171819202122232425262728293031323334353637383940// ./pages/_app.tsximport &quot;../styles/globals.css&quot;;import type { AppProps, AppContext } from &quot;next/app&quot;;import App from &quot;next/app&quot;;import { Layout, ILayoutProps } from &quot;@/components/layout&quot;;import Head from &quot;next/head&quot;;import axios from &quot;axios&quot;;import { LOCALDOMAIN } from &quot;@/utils&quot;;const MyApp = (data: AppProps &amp; ILayoutProps) =&gt; { const { Component, pageProps, navbarData, footerData } = data; return ( &lt;div&gt; &lt;Head&gt; &lt;title&gt;A Demo for 《深入浅出SSR官网开发指南》&lt;/title&gt; &lt;meta name=&quot;description&quot; content=&quot;A Demo for 《深入浅出SSR官网开发指南》&quot; /&gt; &lt;link rel=&quot;icon&quot; href=&quot;/favicon.ico&quot; /&gt; &lt;/Head&gt; &lt;Layout navbarData={navbarData} footerData={footerData}&gt; &lt;Component {...pageProps} /&gt; &lt;/Layout&gt; &lt;/div&gt; );};MyApp.getInitialProps = async (context: AppContext) =&gt; { const pageProps = await App.getInitialProps(context); const { data = {} } = await axios.get(`${LOCALDOMAIN}/api/layout`); return { ...pageProps, ...data, };};export default MyApp; 启动一下页面访问 http://localhost:3000 看一下效果，可以看到已经可以了。 中间件小彩蛋使用过 Express 的同学应该知道中间件的概念，Express是基于路由和中间件的框架，通过链式调用的方式来对接口进行一些统一的处理，不过 Nextjs 中没有这样的概念，因为约定式路由的关系，Nextjs 中更多是模块的调用思想，针对接口的请求类型只是一个判断搞定。 1234567export default (req, res) =&gt; { if (req.method === 'GET') { // do something for the get scene } else if (req.method === 'POST') { // do something for the post scene }} 对于相关中间件的调用，也只需要引入模块执行即可， 例如下面 Nextjs 官网调用跨域中间件的例子： 123456789101112131415161718192021222324252627import Cors from &quot;cors&quot;;// Initializing the cors middlewareconst cors = Cors({ methods: [&quot;GET&quot;, &quot;HEAD&quot;],});// Helper method to wait for a middleware to execute before continuing// And to throw an error when an error happens in a middlewarefunction runMiddleware(req, res, fn) { return new Promise((resolve, reject) =&gt; { fn(req, res, (result) =&gt; { if (result instanceof Error) { return reject(result); } return resolve(result); }); });}async function handler(req, res) { // Run the middlewareawait runMiddleware(req, res, cors) // Rest of the API logic res.json({ message: &quot;Hello Everyone!&quot; });}export default handler; 我个人也是更推荐这种写法的，模块化的写法使得代码结构更为清晰，复用性上也更舒服，符合平常客户端的开发方式，不过习惯 Express开发模式的同学也可以按照下面的方式来适配一下对应的能力，开源社区有开发提供了 next-connect的依赖来补全这部分的能力，我们先来安装一下依赖。 1npm install next-connect -save 然后上面的 layout 接口按照下面改造一下即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import type { NextApiRequest, NextApiResponse } from &quot;next&quot;;import axios from &quot;axios&quot;;import { ILayoutProps } from &quot;../../components/layout&quot;;import { CMSDOMAIN } from &quot;@/utils&quot;;import { isEmpty } from &quot;lodash&quot;;import nextConnect from &quot;next-connect&quot;;const getLayoutData = nextConnect() // .use(any middleware) .get((req: NextApiRequest, res: NextApiResponse&lt;ILayoutProps&gt;) =&gt; { axios.get(`${CMSDOMAIN}/api/layouts`).then((result) =&gt; { const { copy_right, link_lists, public_number, qr_code, qr_code_image, site_number, title, } = result.data || {}; res.status(200).json({ navbarData: {}, footerData: { title, linkList: link_lists?.data?.map((item: any) =&gt; { return { title: item.title, list: item?.links?.data?.map((_item: any) =&gt; { return { label: _item.label, link: isEmpty(_item.link) ? &quot;&quot; : _item.link, }; }), }; }), qrCode: { image: `${CMSDOMAIN}${qr_code_image.data.url}`, text: qr_code, }, copyRight: copy_right, siteNumber: site_number, publicNumber: public_number, }, }); }); });export default getLayoutData; 需要引入中间件，只需要类似 Express 的方式就行了，用 use 来链式调用即可。我更推荐 Nextjs 官网模块调用的写法，相对是更为清晰的，大家可以按照自己的开发习惯自行选用。 小结这两节课我们学习怎么通过 Strapi 搭建一个符合我们自己业务场景的 CMS，并定义了对应的 find接口用于后续的查询，然后自定义移除了一些不必要的属性，便于接口交互。然后我们定义了自己的 BFF层，用于我们官网页面数据的注入，整个数据链路我们都已经走完了，后面遇到类似的数据流转，大家也可以举一反三进行开发。 值得一提的是，Strapi 的能力还远不及此，它包含 Api 鉴权，审批配置等更多的能力可以帮助我们进行官网的规范维护，同时它提供了很多 openApi 来支持相关不同的业务场景，是一个非常优秀值得尝试的开源项目。感兴趣和有更多需求的同学可以阅读 Strapi 官方文档 做更多的尝试~ 到这节课我们实战篇的内容就全部完成了，学到这里，大家应该对官网项目的静态页面到数据流转都有了较深刻的了解了。从下一节课开始，我们将就一些常见的官网需求展开，就 case 来讲解这些需求场景我们应该怎么去开发实现。","link":"/2023/02/01/ssr/react/next/4.nextjs%E4%B8%AD%E9%A1%B5%E9%9D%A2%E6%95%B0%E6%8D%AE%E6%B5%81%E8%BD%AC/"},{"title":"strapi","text":"使用 strapi 搭建 cms 基于 Strapi，可以快速针对业务场景搭建一套对应的 CMS，包括增删改查和联表等较复杂场景，都可以通过可视化的配置实现。对于自定义较高的场景，它也暴露了相关的参数进行自定义，可以使用较少的开发量去实现特殊场景，下面就通过 Strapi 来实现官网后台的数据配置。 项目初始化首先执行 Strapi 提供的脚手架命令来初始化项目。 1npx create-strapi-app nextjs-cms --quickstart 它会在当前目录生成名为 nextjs-cms 的项目，并且会自动运行，也可以进入到项目目录中执行脚本运行。 12npm installnpm run develop 会打开一个登录页，按照指示配置一下账号密码，登录一下就可以了。 数据的可视化配置1.结构体的定义在完成上面的登录后，可以进到 Strapi 的管理页面。 其中content manager是 Api 的数据，而content-type builder对应 Api 的结构体，例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950footerData: { title: &quot;Demo&quot;, linkList: [ { title: &quot;技术栈&quot;, list: [ { label: &quot;react&quot;, }, { label: &quot;typescript&quot;, }, { label: &quot;ssr&quot;, }, { label: &quot;nodejs&quot;, }, ], }, { title: &quot;了解更多&quot;, list: [ { label: &quot;掘金&quot;, link: &quot;https://juejin.cn/user/2714061017452557&quot;, }, { label: &quot;知乎&quot;, link: &quot;https://www.zhihu.com/people/zmAboutFront&quot;, }, { label: &quot;csdn&quot;, }, ], }, { title: &quot;联系我&quot;, list: [{ label: &quot;微信&quot; }, { label: &quot;QQ&quot; }], }, ], qrCode: { image: code, text: &quot;xxxxxxx&quot;, }, copyRight: &quot;Copyright © 2022 xxx. 保留所有权利&quot;, siteNumber: &quot;粤ICP备XXXXXXXX号-X&quot;, publicNumber: &quot;粤公网安备 xxxxxxxxxxxxxx号&quot;, }, } 针对这样一个结构体，想修改其中内容，首先切到 content-type builder。 大家打开的时候应该只有一个 User，这几个结构体是我后面创建的，可以看到，这其中定义的其实就是我们需要的对应字段和它们的类型，如果需要创建一个新的结构体，我们点击create new collection type。 填完display name后，对应的单数和复数 id 它会自动生成，就是右边的两项，name 我们填需要的结构体就可以，至于右边的 tab 是一些高级配置，我们这里用不到可以先不管它。 然后为我们的结构体创建一些字段，常见的类型包括文本、boolean 值、富文本，这些这里都是有的，咱们以 title 举例，因为是一个字符串，所以我们点 text。 咱们这个直接用短文本就好，然后高级配置我们可以选个必填和唯一。 对应的字段就加好了，对于别的部分，我们用相同的方式加进来就可以，稍微特殊一些的字段是 linkList，可以看到它其实是一个对象数组，我们先把 footdata 的关系按照思维导图梳理一下。 按照数据结构可以发现，footerdata 和 linklist，它们是一对多的关系，而 linklist中又包含多个 link，也是一对多的关系，所以要描述这部分字段，光 layout 一个结构体是不够的，我们需要创建 linklist 和link，然后给它们之间来建立对应的关系。 确定了思路，我们按照上面的来创建好 linklist 和 link 的结构体。 那 linklist 和 link 的关系我们应该怎么建立呢？可以按之前说的，我们在 linklist 结构体中，点新建字段。 然后我们点击 relation 属性，这个属性我们用来联立结构体之间的数据库关系。 这里说一下从属和普通联合的区别，如果是从属关系，对应的属性会加到需要关联的结构体，并不会体现在当前表，可以理解为 a 是 b 的一个属性。如果是普通的联合，图中 icon 带有箭头的，是将 b 作为属性加到 a 中，每次切换下面也有对应的英文描述，大家可以结合理解。 根据上面我们说的关系，这里应该是选最后一个，也就是一对多，link 是作为 linklist 的属性来存在的，我们可以点完成，发现就已经加上了。 接下来，我们按照上面的原理配置完所有的结构体即可。 2. 结构体数据的写入定义完结构体以后，需要为结构体加入一些数据，通常在开发完后，运营相关的同学配置，就只要进行这一步就可以了，别的部分就不需要再调整了，点击content manager。 数据的配置需要按照从子到父的原则，很好理解，因为 layout 有相关的字段依赖于 linklist， linklist 又依赖于 link，所以只有 link 配置完以后，才可以进行 linklist 和 layout 的配置，以 link 和 linklist 举例。 切到 link 的部分，点击 create new entry，可以进到下面的页面，输入完内容以后，可以进行保存，这里保存有两个按钮，一个是 save， 一个是 publish，如果点击 publish 会生效到实际 cdn， 这里可以先点击 publish，实际场景下运营配置的时候可以点 save，在 review 没问题后再发布即可。 配置完大致是这样的： 然后我们配置 linklist 的部分，同样是点create new entry。 除了基本的字段，右侧还会有对应关联的字段，勾选我们需要的就可以关联上了。 保存完成后，可以看到对应的关联对象内容，确认无误就行了。 3. Api 权限配置及上线结构体和数据定义完成后，已经完成大半了，现在问题是我们应该在哪里配置我们的 Api，使得有个 cdn 可以看到呢？ 点击settings -&gt; Roles，这里是权限配置的部分，包含作者权限和公共权限，因为需要所有的人可以看到我们的接口，所以点 public 右侧的 🖊（如果有特别需求的同学，可以点击 add new role 新增权限角色，再进行后续的步骤。 可以看到，之前定义的结构体，左侧对应结构体支持的类型，右侧对应结构体接口的指向 Api 路由。因为要给对应的接口配置全查和单查的能力，所以勾选上 find 和 findOne。 因为 layout 依赖于 link 和 link-list，所以 link 和 link-list 的结构体也需勾选上 find 和 findOne，完成这些后，访问 http://localhost:1337/api/layouts。 Strapi 默认是不会填充联表关系的，可以在路由后加populate=*，这个入参的意义是为所有的关系填充一级关系。 可以看到现在已经有了，不过这个入参只能填充一级深度，如果有两层这种写法就不行了，引用一个官网的例子。 strapi-plugin-populate-deep，这是基于 Strapi 的一个深度插件，配置复杂结构体，切到项目目录下的终端安装一下。 1npm install strapi-plugin-populate-deep --save 然后重启一下，访问 http://localhost:1337/api/layouts?populate=deep 。 deep 参数的含义为使用默认的最大深度填充请求，即 5 层，如果 5 层不满足大家的需求，需要更多，入参的调整也很方便，比如针对 10 层的场景，只需要传递入参 populate=deep,10就可以，相比原生复杂的语法定义好理解很多~ 项目结构 &amp; 调试上面通过可视化配置了一个接口，不过 Strapi 的能力远不止此，它提供了大量的 openApi ，可以支持自定义接口的开发。 这其中最需要关注的有三个文件夹： .tmp/data.db: 项目的 db 文件，存放有 user、结构体、Api 鉴权等所有数据，默认使用 SQLite，可以使用 navicat for SQLite 打开看看。 config/ *. : config 目录下包含着项目使用的配置，比如数据库、中间件等配置，可以通过它来换用别的数据库或是进行跨域网关等操作。以数据库文件举例，可以看到，其中使用着 SQlite 的数据库，并指向了上面提到的 db 文件路径。 src/api/*: 这其中定义着之前配置的结构体，可以在这其中对配置的 Api 数据进行拦截进行一些额外的处理等自定义操作。 因为是一个服务器端项目，所以肯定也需要在服务器层进行接口的调试，调试的方式很简单，只需要在 VSCode 的 debugger 控制台下运行项目，然后正常 debugger 即可。","link":"/2022/11/01/ssr/react/next/3.%E5%9F%BA%E4%BA%8Estrapi%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E6%95%B0%E6%8D%AE%E9%85%8D%E7%BD%AE/"},{"title":"next实现页面链路","text":"实现页面的路由跳转等 模板页面渲染 通用 layout Nextjs 模板页面的写法和 React 的用法是相同的。web 应用的路由页面之间通常会有共同的页面元素，比如页首、页尾，对于这种页面，通常会定义对应的组件在入口文件中引用，这样所有的页面就都可以有相同的页面组件了，而不在需要在每个页面中去单独调用 类名库 classnames，它可以用函数式的方式来处理一些相对复杂的类场景。 1npm install classnames --save 先定义一下页首的组件： 1234567891011121314151617// ./components/navbar/index.tsximport { FC } from &quot;react&quot;;import styles from &quot;./styles.module.scss&quot;;import Image from &quot;next/image&quot;;import logoLight from &quot;@/public/logo_light.png&quot;;export interface INavBarProps {}export const NavBar: FC&lt;INavBarProps&gt; = ({}) =&gt; { return ( &lt;div className={styles.navBar}&gt; &lt;a href=&quot;http://localhost:3000/&quot;&gt; &lt;Image src={logoLight} alt=&quot;Demo&quot; width={70} height={20} /&gt; &lt;/a&gt; &lt;/div&gt; );}; 123456789101112131415// ./components/navbar/styles.module.scss.navBar { display: flex; align-items: center; justify-content: space-between; background-color: hsla(0, 0%, 100%, 0.5); backdrop-filter: blur(8px); width: 100%; height: 64px; position: sticky; top: 0; left: 0; padding: 20px 32px; z-index: 100;} 引用了 next/image 内置的 Image 标签，相比平常的 img 标签，Nextjs 会根据导入的图像来确认宽高，从而规避累积布局移位 (CLS) 的问题，可以在布局阶段提前进行相关区域预留位置，而不是加载中再进行移位。 再定义一下页尾的组件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// ./components/footer/index.tsximport { FC } from &quot;react&quot;;import Image from &quot;next/image&quot;;import publicLogo from &quot;@/public/public_logo.png&quot;;import styles from &quot;./styles.module.scss&quot;;import cName from &quot;classnames&quot;;interface ILink { label: string; link?: string;}interface ILinkList { title: string; list: ILink[];}interface IQRCode { image: string; text: string;}export interface IFooterProps { title: string; linkList: ILinkList[]; qrCode: IQRCode; copyRight: string; siteNumber: string; // 站点备案号 publicNumber: string; // 公安备案号}export const Footer: FC&lt;IFooterProps&gt; = ({ title, linkList, qrCode, copyRight, siteNumber, publicNumber,}) =&gt; { return ( &lt;div className={styles.footer}&gt; &lt;div className={styles.topArea}&gt; &lt;h1 className={styles.footerTitle}&gt;{title}&lt;/h1&gt; &lt;div className={styles.linkListArea}&gt; {linkList?.map((item, index) =&gt; { return ( &lt;div className={styles.linkArea} key={`linkArea${index}`}&gt; &lt;span className={styles.title}&gt;{item.title}&lt;/span&gt; &lt;div className={styles.links}&gt; {item.list?.map((_item, _index) =&gt; { return ( &lt;div className={cName({ [styles.link]: _item.link, [styles.disabled]: !_item.link, })} onClick={(): void =&gt; { _item.link &amp;&amp; window.open( _item.link, &quot;blank&quot;, &quot;noopener=yes,noreferrer=yes&quot; ); }} key={`link${_index}`} &gt; {_item.label} &lt;/div&gt; ); })} &lt;/div&gt; &lt;/div&gt; ); })} &lt;/div&gt; &lt;/div&gt; &lt;div className={styles.bottomArea}&gt; &lt;div className={styles.codeArea}&gt; &lt;div&gt; &lt;Image src={qrCode?.image} alt={qrCode?.text} width={56} height={56} &gt;&lt;/Image&gt; &lt;/div&gt; &lt;div className={styles.text}&gt;{qrCode?.text}&lt;/div&gt; &lt;/div&gt; &lt;div className={styles.numArea}&gt; &lt;span&gt;{copyRight}&lt;/span&gt; &lt;span&gt;{siteNumber}&lt;/span&gt; &lt;div className={styles.publicLogo}&gt; &lt;div className={styles.logo}&gt; &lt;Image src={publicLogo} alt={publicNumber} width={20} height={20} &gt;&lt;/Image&gt; &lt;/div&gt; &lt;span&gt;{publicNumber}&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; );}; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// ./components/footer/styles.module.scss.footer { padding: 70px 145px; background-color: #f4f5f5; .topArea { display: flex; justify-content: space-between; .footerTitle { font-weight: 500; font-size: 36px; line-height: 36px; color: #333333; margin: 0; } .linkListArea { display: flex; .linkArea { display: flex; flex-direction: column; margin-left: 160px; .title { font-weight: 500; font-size: 14px; line-height: 20px; color: #333333; margin-bottom: 40px; } .links { display: flex; flex-direction: column; font-weight: 400; font-size: 14px; line-height: 20px; .link { color: #333333; cursor: pointer; margin-bottom: 24px; } .disabled { color: #666; cursor: not-allowed; margin-bottom: 24px; } } } } } .bottomArea { display: flex; justify-content: space-between; .codeArea { display: flex; flex-direction: column; .text { color: #666; } } .numArea { color: #666; display: flex; flex-direction: column; align-items: flex-end; font-weight: 400; font-size: 14px; line-height: 20px; span { margin-bottom: 12px; } .publicLogo { display: flex; .logo { margin-right: 4px; } } } }} 页首和页尾需要的图片资源统一放在 public 中，定义好组件，将它拼接成需要的布局（layout）组件，并将中间的 body 通过 children 透传进来。 123456789101112131415161718192021222324// ./components/layout/index.tsximport { FC } from &quot;react&quot;;import { IFooterProps, Footer } from &quot;../footer/index&quot;;import { INavBarProps, NavBar } from &quot;../navbar/index&quot;;import styles from &quot;./styles.module.scss&quot;;export interface ILayoutProps { navbarData: INavBarProps; footerData: IFooterProps;}export const Layout: FC&lt;ILayoutProps &amp; { children: JSX.Element }&gt; = ({ navbarData, footerData, children,}) =&gt; { return ( &lt;div className={styles.layout}&gt; &lt;NavBar {...navbarData} /&gt; &lt;main className={styles.main}&gt;{children}&lt;/main&gt; &lt;Footer {...footerData} /&gt; &lt;/div&gt; );}; 123456// ./components/layout/styles.module.scss.layout { .main { min-height: calc(100vh - 560px); }} 定义好 layout，只需要把 layout 塞进入口文件就可以， Nextjs 的入口文件是 pages 下的 _app.tsx，如下定义： 123456789101112131415// .pages/_app.tsximport &quot;../styles/globals.css&quot;;import type { AppProps } from &quot;next/app&quot;;import { Layout, ILayoutProps } from &quot;@/components/layout&quot;;const MyApp = (data: AppProps &amp; ILayoutProps) =&gt; { const { Component, pageProps, navbarData, footerData } = data; return ( &lt;Layout navbarData={navbarData} footerData={footerData}&gt; &lt;Component {...pageProps} /&gt; &lt;/Layout&gt; );};export default MyApp; 这样就已经可以了，可以启动项目看看效果： 可以看到，已经有固定的页首和页尾了，不过因为还没注入数据的关系，所以很多地方都是空的，下面将对应的数据按定义的类型注入进来。 数据注入 在 Nextjs 中提供了相关的函数来实现数据注入，分别是 getStaticProps、getServerSideProps 和 getInitialProps。 getStaticProps： getStaticProps多用于静态页面的渲染，它只会在生产中执行，而不会在运行的时候再次调用，这意味着它只能用于不常编辑的部分，每次调整都需要重新构建部署，官网信息的时效性比较敏感，所以可能不会高频率使用。 getServerSideProps：getServerSideProps 只会执行在服务器端，不会在客户端执行。因为这个特性，所以客户端的脚本打包会较小，相关数据不会有在客户端暴露的问题，相对更隐蔽安全，不过逻辑集中在服务器端处理，会加重服务器的负担，服务器成本也会更高。 使用服务器端渲染的初衷，还是将处理的数据直接包含在 HTML 文本中，提高 SEO，至于客户端的逻辑并不需要都放在服务器端执行，所以最好不要用来作为服务器端方法注入。 getInitialProps：初始化的时候，如果是服务器端路由，那么数据的注入会在服务器端执行，对 SEO 友好，在实际的页面操作中，相关的逻辑会在 客户端 执行，从而减轻了服务器端的负担。 所以综合成本来考虑，后期的数据注入主要会采用 getInitialProps 来进行。 数据的注入都是针对页面的，也就是 pages 目录下的，对组件进行数据注入是不支持的，所以应在页面中注入对应数据后再透传给页面组件。 因为 _app.tsx 是所有页面的入口页面，所以别的页面的参数也需要透传下来，而不能直接覆盖，可以用内置的 App 对象来获取对应组件本身的 pageProps，不要直接覆盖了，对于非入口页面的普通页面，直接加上业务逻辑就可以： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// ./pages/_app.tsximport &quot;../styles/globals.css&quot;;import type { AppProps, AppContext } from &quot;next/app&quot;;import App from &quot;next/app&quot;;import { Layout, ILayoutProps } from &quot;@/components/layout&quot;;import code from &quot;@/public/code.png&quot;;const MyApp = (data: AppProps &amp; ILayoutProps) =&gt; { const { Component, pageProps, navbarData, footerData } = data; return ( &lt;div&gt; &lt;Layout navbarData={navbarData} footerData={footerData}&gt; &lt;Component {...pageProps} /&gt; &lt;/Layout&gt; &lt;/div&gt; );};MyApp.getInitialProps = async (context: AppContext) =&gt; { const pageProps = await App.getInitialProps(context); return { ...pageProps, navbarData: {}, footerData: { title: &quot;Demo&quot;, linkList: [ { title: &quot;技术栈&quot;, list: [ { label: &quot;react&quot;, }, { label: &quot;typescript&quot;, }, { label: &quot;ssr&quot;, }, { label: &quot;nodejs&quot;, }, ], }, { title: &quot;了解更多&quot;, list: [ { label: &quot;掘金&quot;, link: &quot;https://juejin.cn/user/2714061017452557&quot;, }, { label: &quot;知乎&quot;, link: &quot;https://www.zhihu.com/people/zmAboutFront&quot;, }, { label: &quot;csdn&quot;, }, ], }, { title: &quot;联系我&quot;, list: [{ label: &quot;微信&quot; }, { label: &quot;QQ&quot; }], }, ], copyRight: &quot;Copyright © 2022 xxx. 保留所有权利&quot;, siteNumber: &quot;粤ICP备XXXXXXXX号-X&quot;, publicNumber: &quot;粤公网安备 xxxxxxxxxxxxxx号&quot;, }, };};export default MyApp; 再刷新页面试试，可以看到一个简易的有 layout 的首页就创建好了。 路由匹配Nextjs 的路由不同于一般使用的路由，它没有对应的文件去配置对应的路由，而是通过文件系统自动检索对应的路由，会根据相对 pages 的目录路径来生成对应的路由，比如： 12// ./pages/home/index.tsx =&gt; /home// ./pages/demo/[id].tsx =&gt; /demo/:id 这里创建一个 article 目录来试验一下对应的文件路由，针对文章路由，需要给它加一个 articleId 参数来区分不同文章： 1234567891011121314151617181920212223// ./pages/article/[articleId].tsximport type { NextPage } from &quot;next&quot;;interface IProps { articleId: number;}const Article: NextPage&lt;IProps&gt; = ({ articleId }) =&gt; { return ( &lt;div&gt; &lt;h1&gt;文章{articleId}&lt;/h1&gt; &lt;/div&gt; );};Article.getInitialProps = (context) =&gt; { const { articleId } = context.query; return { articleId: Number(articleId), };};export default Article; 在注入的时候获取当前的 articleId 来用于页面显示，刷新一下页面，然后打开 http://localhost:3000/article/1 试试： 可以看到已经可以了，这里可以顺便把首页默认的 index.tsx 简单改造一下，把链接指到定义的文章路由。 服务器端渲染的路由包含客户端路由和服务器端路由，如果采用 router hook 跳转将采用客户端路由，如果需要使用服务器端渲染，需要使用 a 标签或是 window.open 等原生方式，这里采用服务器端路由进行跳转，提高 SEO 的检索效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// ./pages/index.tsximport type { NextPage } from &quot;next&quot;;import styles from &quot;./index.module.scss&quot;;interface IProps { title: string; description: string; list: { label: string; info: string; link: string; }[];}const Home: NextPage&lt;IProps&gt; = ({ title, description, list }) =&gt; { return ( &lt;div className={styles.container}&gt; &lt;main className={styles.main}&gt; &lt;h1 className={styles.title}&gt;{title}&lt;/h1&gt; &lt;p className={styles.description}&gt;{description}&lt;/p&gt; &lt;div className={styles.grid}&gt; {list?.map((item, index) =&gt; { return ( &lt;div key={index} className={styles.card} onClick={(): void =&gt; { window.open( item.link, &quot;blank&quot;, &quot;noopener=yes,noreferrer=yes&quot; ); }} &gt; &lt;h2&gt;{item.label} &amp;rarr;&lt;/h2&gt; &lt;p&gt;{item.info}&lt;/p&gt; &lt;/div&gt; ); })} &lt;/div&gt; &lt;/main&gt; &lt;/div&gt; );};Home.getInitialProps = (context) =&gt; { return { title: &quot;Hello SSR!&quot;, description: &quot;A Demo for u&quot;, list: [ { label: &quot;文章1&quot;, info: &quot;A test for article1&quot;, link: &quot;http://localhost:3000/article/1&quot;, }, { label: &quot;文章2&quot;, info: &quot;A test for article2&quot;, link: &quot;http://localhost:3000/article/2&quot;, }, { label: &quot;文章3&quot;, info: &quot;A test for article3&quot;, link: &quot;http://localhost:3000/article/3&quot;, }, { label: &quot;文章4&quot;, info: &quot;A test for article4&quot;, link: &quot;http://localhost:3000/article/4&quot;, }, { label: &quot;文章5&quot;, info: &quot;A test for article5&quot;, link: &quot;http://localhost:3000/article/5&quot;, }, { label: &quot;文章6&quot;, info: &quot;A test for article6&quot;, link: &quot;http://localhost:3000/article/6&quot;, }, ], };};export default Home; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111// ./pages/index.module.scss.container { padding: 0 2rem;}.main { min-height: 100vh; padding: 4rem 0; flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center;}.footer { display: flex; flex: 1; padding: 2rem 0; border-top: 1px solid #eaeaea; justify-content: center; align-items: center;}.footer a { display: flex; justify-content: center; align-items: center; flex-grow: 1;}.title a { color: #0070f3; text-decoration: none;}.title a:hover,.title a:focus,.title a:active { text-decoration: underline;}.title { margin: 0; line-height: 1.15; font-size: 4rem;}.title,.description { text-align: center;}.description { margin: 4rem 0; line-height: 1.5; font-size: 1.5rem;}.code { background: #fafafa; border-radius: 5px; padding: 0.75rem; font-size: 1.1rem; font-family: Menlo, Monaco, Lucida Console, Liberation Mono, DejaVu Sans Mono, Bitstream Vera Sans Mono, Courier New, monospace;}.grid { display: flex; align-items: center; justify-content: center; flex-wrap: wrap; max-width: 800px;}.card { margin: 1rem; padding: 1.5rem; text-align: left; color: inherit; text-decoration: none; border: 1px solid #eaeaea; border-radius: 10px; transition: color 0.15s ease, border-color 0.15s ease; max-width: 300px; cursor: pointer;}.card:hover,.card:focus,.card:active { color: #0070f3; border-color: #0070f3;}.card h2 { margin: 0 0 1rem 0; font-size: 1.5rem;}.card p { margin: 0; font-size: 1.25rem; line-height: 1.5;}.logo { height: 1em; margin-left: 0.5rem;} 这里使用 window.open打开一个新页面来指向上文创建的文章页，noopener=yes,noreferrer=yes是为了跳转的安全性，这个可以隐藏跳转的 window.opener 与 Document.referrer，在跨站点跳转中，通常加这个参数来保证跳转信息的不泄露，现在就可以重新访问 http://localhost:3000/ 看看效果。 现在点击其中的文章模块就可以跳到对应的文章页。 header 修改Nextjs 提供了开箱即用的能力，只需要直接用 next/head 暴露出来的标签来修改 header 就可以了，这里在 _app.tsx 加一个默认的 title。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// ./pages/_app.tsximport &quot;../styles/globals.css&quot;;import type { AppProps, AppContext } from &quot;next/app&quot;;import App from &quot;next/app&quot;;import { Layout, ILayoutProps } from &quot;@/components/layout&quot;;import code from &quot;@/public/code.png&quot;;import Head from &quot;next/head&quot;;const MyApp = (data: AppProps &amp; ILayoutProps) =&gt; { const { Component, pageProps, navbarData, footerData } = data; return ( &lt;div&gt; &lt;Head&gt; &lt;title&gt;A Demo for u&lt;/title&gt; &lt;meta name=&quot;description&quot; content=&quot;A Demo for u&quot; /&gt; &lt;link rel=&quot;icon&quot; href=&quot;/favicon.ico&quot; /&gt; &lt;/Head&gt; &lt;Layout navbarData={navbarData} footerData={footerData}&gt; &lt;Component {...pageProps} /&gt; &lt;/Layout&gt; &lt;/div&gt; );};MyApp.getInitialProps = async (context: AppContext) =&gt; { const pageProps = await App.getInitialProps(context); return { ...pageProps, navbarData: {}, footerData: { title: &quot;Demo&quot;, linkList: [ { title: &quot;技术栈&quot;, list: [ { label: &quot;react&quot;, }, { label: &quot;typescript&quot;, }, { label: &quot;ssr&quot;, }, { label: &quot;nodejs&quot;, }, ], }, { title: &quot;了解更多&quot;, list: [ { label: &quot;掘金&quot;, link: &quot;https://juejin.cn/user/2714061017452557&quot;, }, { label: &quot;知乎&quot;, link: &quot;https://www.zhihu.com/people/zmAboutFront&quot;, }, { label: &quot;csdn&quot;, }, ], }, { title: &quot;联系我&quot;, list: [{ label: &quot;微信&quot; }, { label: &quot;QQ&quot; }], }, ], copyRight: &quot;Copyright © 2022 xxx. 保留所有权利&quot;, siteNumber: &quot;粤ICP备XXXXXXXX号-X&quot;, publicNumber: &quot;粤公网安备 xxxxxxxxxxxxxx号&quot;, }, };};export default MyApp; 再刷新，可以看到默认的 title 已经加上了。","link":"/2022/11/01/ssr/react/next/2.nextjs%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0%E5%AE%8C%E6%95%B4%E9%A1%B5%E9%9D%A2%E9%93%BE%E8%B7%AF/"},{"title":"AST","text":"前几节课我们从环境配置，到基础页面、路由、接口层，全链路讲解了一个简单的服务器端页面是如何去开发的。我们还学习了 Nextjs的通用能力以及最新的 headless-CMS Strapi是怎么轻量灵活地搭建一个官网运营后台系统的，相信大家对于官网开发整体的链路已经有了比较深的认识。 从这一节课开始，我们将结合具体的需求场景，case by case 去实现几个常见的 C 端需求，来帮助大家应对迭代中的一些复杂场景。 这节课我们就来学习官网中最常见的需求 – 主题化的实现。不管是抖音前端技术团队官网，还是字节最新开源的 UI 组件库 Semi，都有不同风格的官网体系展示，以 Semi 为例，它的官网有包含默认的样式： 也有暗黑色调的展示： 甚至还可以自定义主题，提供不同的酷炫展示： 那么针对这种效果，我们应该怎么去实现呢？难道对每个主题都定义一套样式？ 基础色调的变量抽离通过观察我们可以发现，主题化的功能对于 DOM 的结构变化不大，往往都是针对色调进行切换。顺着这个思路，如果我们定义两套变量，是不是就完成了对两套主题的配置？根据不同的主题，我们可以在 html 标签上来固定两个属性来区分，方案确定了，我们来尝试做做看。 在全局样式中定义两套我们之前使用到的色调，包括字体和背景等颜色，把我们之前定义的组件样式抽出来放在这里就可以，保证所有的色调都通过变量的方式来引用。后面我们会通过在 html 中加上 data-theme 属性来区分当前应该使用哪套样式。 1234567891011121314151617181920212223// ./pages/global.scsshtml[data-theme=&quot;dark&quot;] { --primary-color: #ffffff; // 主要的字体颜色 --primary-background-color: rgba(14, 14, 14, 1); // 主要的背景色 --footer-background-color: rgba(36, 36, 36, 1); // footer组件的背景色 --navbar-background-color: rgba(0, 0, 0, 0.5); // navbar组件的背景色 --secondary-color: rgba( 255, 255, 255, 0.5 ); // 次一级，色值没那么显眼的字体颜色 --link-color: #34a8eb; // 链接 hover 上去的颜色}html[data-theme=&quot;light&quot;] { --primary-color: #333333; --primary-background-color: rgba(255, 255, 255, 1); --footer-background-color: #f4f5f5; --navbar-background-color: rgba(255, 255, 255, 0.5); --secondary-color: #666666; --link-color: #0070f3;} 然后我们需要把这个文件在入口文件引用一下。 123// ./pages/_app.tsximport &quot;./global.scss&quot;;// ... 接下来就是把这些定义的变量去替换原来我们样式中给的固定色值了，以 footer 组件举例，改造之后样式文件如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// ./components/footer/styles.modules.scss.footer { padding: 70px 145px; background-color: var(--footer-background-color); .topArea { display: flex; justify-content: space-between; .footerTitle { font-weight: 500; font-size: 36px; line-height: 36px; color: var(--primary-color); margin: 0; } .linkListArea { display: flex; .linkArea { display: flex; flex-direction: column; margin-left: 160px; .title { font-weight: 500; font-size: 14px; line-height: 20px; color: var(--primary-color); margin-bottom: 40px; } .links { display: flex; flex-direction: column; font-weight: 400; font-size: 14px; line-height: 20px; .link { color: var(--primary-color); cursor: pointer; margin-bottom: 24px; } .disabled { color: var(--secondary-color); cursor: not-allowed; margin-bottom: 24px; } } } } } .bottomArea { display: flex; justify-content: space-between; .codeArea { display: flex; flex-direction: column; .text { color: var(--secondary-color); } } .numArea { color: var(--secondary-color); display: flex; flex-direction: column; align-items: flex-end; font-weight: 400; font-size: 14px; line-height: 20px; span { margin-bottom: 12px; } .publicLogo { display: flex; .logo { margin-right: 4px; } } } }} 剩下的改造工作同学们可以结合上面和代码仓库的示例完成，这里就不贴代码了，只需要把之前我们定义的样式换成对应的 var(...)变量就好。 图片的主题化配置然后对于图片的主题化，有两种方式，一种是针对一般固定不变的图片，我们采用同样定义的方式。 123456789101112131415161718192021222324252627282930313233343536373839// ./pages/global.scsshtml[data-theme=&quot;dark&quot;] { --primary-color: #ffffff; --primary-background-color: rgba(14, 14, 14, 1); --footer-background-color: rgba(36, 36, 36, 1); --navbar-background-color: rgba(0, 0, 0, 0.5); --secondary-color: rgba(255, 255, 255, 0.5); --link-color: #34a8eb; --navbar-icon: url(&quot;../public/logo_dark.png&quot;); --theme-icon: url(&quot;../public/theme_dark.png&quot;);}html[data-theme=&quot;light&quot;] { --primary-color: #333333; --primary-background-color: rgba(255, 255, 255, 1); --footer-background-color: #f4f5f5; --navbar-background-color: rgba(255, 255, 255, 0.5); --secondary-color: #666666; --link-color: #0070f3; --navbar-icon: url(&quot;../public/logo_light.png&quot;); --theme-icon: url(&quot;../public/theme_light.png&quot;);}html,body { padding: 0; margin: 0; font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;}a { color: inherit; text-decoration: none;}* { box-sizing: border-box;} 另一种是配置中的图片，可能会频繁变化，这种我们只需要在 Strapi 中再加一个字段存不同主题的图片，然后在页面逻辑中，我们根据不同的主题去切换就可以。到这里主题化资源的前置工作就完成了，现在我们需要思考主题数据注入的时机和方式。 主题 Context 的数据注入样式和静态资源的方案确定了，我们来思考下一个问题，针对当前的主题，肯定有个地方需要进行缓存，我们应该使用哪种客户端缓存机制呢？主题化的功能往往是因为用户更喜欢这种色调，那我们用localStorage 要更合适，因为相比 sessionStorage只能保存当前会话的特点，localStorage 可以长期保留，除非用户主动清除，这样我们可以保留用户的习惯，让他下一次访问的时候也可以保证是之前的主题。 那么应该怎么去注入这个缓存呢，如果我们随心所欲地去进行缓存注入操作，那我们页面中可能会分散各种缓存的逻辑，不符合单一职责原则，也不利于统一的维护和相关事件的绑定，所以我们需要在一处地方聚集主题相关的逻辑，然后再分别注入给每个页面对应的编辑方法。 这里需要用到 React 的 useContext，可能很多同学平时业务中不会去用这个hook，它具有接受上下文，并将上下文进行注入的能力，这么说大家可能还不太能理解，但是如果提到 redux大家应该就明白了，它们具备相同的能力，并且在 hook 发布后，redux 的 v6 版本也改造为了基于 React 的 Context去实现数据的统一管理。 那我们现在来实现一个 context 进行主题的注入。 1234567891011121314151617181920212223242526272829303132333435363738394041// ./stores/theme.tsximport React, { useState, useEffect, createContext } from &quot;react&quot;;import { Themes } from &quot;@/constants/enum&quot;;interface IThemeContextProps { theme: Themes; setTheme: (theme: Themes) =&gt; void;}interface IProps { children: JSX.Element;}export const ThemeContext = createContext&lt;IThemeContextProps&gt;( {} as IThemeContextProps);export const ThemeContextProvider = ({ children }: IProps): JSX.Element =&gt; { const [theme, setTheme] = useState&lt;Themes&gt;(Themes.light); useEffect(() =&gt; { const item = (localStorage.getItem(&quot;theme&quot;) as Themes) || Themes.light; setTheme(item); document.getElementsByTagName(&quot;html&quot;)[0].dataset.theme = item; }, []); return ( &lt;ThemeContext.Provider value={{ theme, setTheme: (currentTheme) =&gt; { setTheme(currentTheme); localStorage.setItem(&quot;theme&quot;, currentTheme); document.getElementsByTagName(&quot;html&quot;)[0].dataset.theme = currentTheme; }, }} &gt; {children} &lt;/ThemeContext.Provider&gt; );}; 其中 ThemeContext 是暴露出的变量，在全局注入后，每个路由页面都可以通过它来获取我们定义的 theme 和 setTheme进行相关的业务操作，ThemeContextProvider 则是注入器，用于给需要的 DOM 进行上下文的注入。现在我们在全局页面注入我们写的context。 12345678910111213141516171819202122232425262728293031323334353637383940414243// ./pages/_app.tsximport type { AppProps, AppContext } from &quot;next/app&quot;;import App from &quot;next/app&quot;;import { Layout, ILayoutProps } from &quot;@/components/layout&quot;;import Head from &quot;next/head&quot;;import axios from &quot;axios&quot;;import { LOCALDOMAIN } from &quot;@/utils&quot;;import { ThemeContextProvider } from &quot;@/stores/theme&quot;;import &quot;./global.scss&quot;;const MyApp = (data: AppProps &amp; ILayoutProps) =&gt; { const { Component, pageProps, navbarData, footerData } = data; return ( &lt;div&gt; &lt;Head&gt; &lt;title&gt;A Demo for 《深入浅出SSR官网开发指南》&lt;/title&gt; &lt;meta name=&quot;description&quot; content=&quot;A Demo for 《深入浅出SSR官网开发指南》&quot; /&gt; &lt;link rel=&quot;icon&quot; href=&quot;/favicon.ico&quot; /&gt; &lt;/Head&gt; &lt;ThemeContextProvider&gt; &lt;Layout navbarData={navbarData} footerData={footerData}&gt; &lt;Component {...pageProps} /&gt; &lt;/Layout&gt; &lt;/ThemeContextProvider&gt; &lt;/div&gt; );};MyApp.getInitialProps = async (context: AppContext) =&gt; { const pageProps = await App.getInitialProps(context); const { data = {} } = await axios.get(`${LOCALDOMAIN}/api/layout`); return { ...pageProps, ...data, };};export default MyApp; 这个完成后主题化的大体功能就完成了，我们在 navbar 加一个主题化切换的入口。 1234567891011121314151617181920212223242526272829// ./components/navbar/index.tsximport { FC, useContext } from &quot;react&quot;;import styles from &quot;./styles.module.scss&quot;;import { ThemeContext } from &quot;@/stores/theme&quot;;import { Themes } from &quot;@/constants/enum&quot;;export interface INavBarProps {}export const NavBar: FC&lt;INavBarProps&gt; = ({}) =&gt; { const { setTheme } = useContext(ThemeContext); return ( &lt;div className={styles.navBar}&gt; &lt;a href=&quot;http://localhost:3000/&quot;&gt; &lt;div className={styles.logo_icon}&gt;&lt;/div&gt; &lt;/a&gt; &lt;div className={styles.theme_icon} onClick={(): void =&gt; { if (localStorage.getItem(&quot;theme&quot;) === Themes.light) { setTheme(Themes.dark); } else { setTheme(Themes.light); } }} &gt;&lt;/div&gt; &lt;/div&gt; );}; 然后我们启动项目试试（除 demo 仓库，同学们还要记得启动一下 cms 仓库，后续为方便，我们统一称启动项目)。可以看到已经可以实现主题化的功能了。 多进程场景下的主题同步上面我们实现了一个基本主题化功能，现在来思考一个问题，我们知道浏览器是多进程的，每个开启的页面都对应到一个进程，这样可以有效地避免页面之间的数据共享及一个报错页面带崩所有页面的情况。 那么针对我们这个场景，现在的实现，如果用户开了多个页面来访问我们的站点，其中一个页面的主题切换，另一个页面是感知不到的，这样一个浏览器下会有多个主题的页面，其实对用户体验上来说是不太好的。出于追求极致考虑，我们可以优化一下这个问题，其实也很简单，只需要监听浏览器的缓存修改事件，然后再次执行初始化的操作就好了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// ./stores/theme.tsximport React, { useState, useEffect, createContext } from &quot;react&quot;;import { Themes } from &quot;@/constants/enum&quot;;interface IThemeContextProps { theme: Themes; setTheme: (theme: Themes) =&gt; void;}interface IProps { children: JSX.Element;}export const ThemeContext = createContext&lt;IThemeContextProps&gt;( {} as IThemeContextProps);export const ThemeContextProvider = ({ children }: IProps): JSX.Element =&gt; { const [theme, setTheme] = useState&lt;Themes&gt;(Themes.light); // 监听本地缓存来同步不同页面间的主题 useEffect(() =&gt; { const checkTheme = (): void =&gt; { const item = (localStorage.getItem(&quot;theme&quot;) as Themes) || Themes.light; setTheme(item); document.getElementsByTagName(&quot;html&quot;)[0].dataset.theme = item; }; checkTheme(); window.addEventListener(&quot;storage&quot;, checkTheme); return (): void =&gt; { window.removeEventListener(&quot;storage&quot;, checkTheme); }; }, []); return ( &lt;ThemeContext.Provider value={{ theme, setTheme: (currentTheme) =&gt; { setTheme(currentTheme); localStorage.setItem(&quot;theme&quot;, currentTheme); document.getElementsByTagName(&quot;html&quot;)[0].dataset.theme = currentTheme; }, }} &gt; {children} &lt;/ThemeContext.Provider&gt; );}; 这时候我们尝试打开两个页面，修改其中一个，发现另一个也会同步更新为一样的主题了。 闪烁场景的优化到这里主题化其实就已经实现了，不过还有一个小问题，因为我们在服务器端是获取不到当前的主题的，我们通过 useEffect钩子来获取主题进行样式的渲染，这样其实会有一个主题切换的过程，在低网速或是快速切换场景下会有比较明显的闪烁，我们可以在钩子处设置断点查看（当前缓存是黑色主题）。 可以看到走到钩子的时候，是还没办法进行对应主题样式渲染的，那我们应该怎么解决这个问题呢？我们只需要在 HTML 中引入对应的script，确保可以在交互之前进行主题的初始化就行了，Nextjs 有提供这个能力，我们在 pages 目录下创建_document.tsx，然后引入对应的内部脚本。 1234567891011121314151617181920// ./pages/_document.tsximport { Html, Head, Main, NextScript } from &quot;next/document&quot;;import Script from &quot;next/script&quot;;export default function Document() { return ( &lt;Html&gt; &lt;Head /&gt; &lt;body&gt; &lt;Main /&gt; &lt;NextScript /&gt; &lt;Script id=&quot;theme-script&quot; strategy=&quot;beforeInteractive&quot;&gt; {`const item = localStorage.getItem('theme') || 'light'; localStorage.setItem('theme', item); document.getElementsByTagName('html')[0].dataset.theme = item;`} &lt;/Script&gt; &lt;/body&gt; &lt;/Html&gt; );} 其中 id 是用于 Nextjs 检索， 而 beforeInteractive 表明这个脚本的执行策略是在交互之前，会被默认放到 head 中，现在我们再来试试效果，发现走到钩子的时候已经可以正常去初始化了。 切换主题的时候，我们发现中间的内容会先展示，这个是因为中间的部分还是静态数据，只需要换用 strapi 接管，通过接口请求就可以了，后续章节我们会对首页有较大的调整，那时会统一配置，这里可以暂时先用静态数据。到这里我们主题化的功能就实现完成了。 小彩蛋如果访问 http://localhost:3000, 和http://127.0.0.1:3000, 我们会发现主题是不能共享的，因为这两者虽然是同一个服务，但并不是同一域名，localstorage 之间是不会互相共享的，所以会有独立的主题。 后续学习大家注意一下这个问题，可以使用 http://127.0.0.1:3000 进行本地访问，后续 Strapi 配置的链接字段将包含完整 ip 和 端口。 小结这节课是常见需求进阶篇的第一节课，这节课我们学习了怎么实现一个主题化的功能，我们通过变量定义的方式去定义我们之前固定的相关色调和静态资源，然后通过缓存的方式去存储当前的主题，并向 html 标签中注入 data-theme 进行相关标识，来进行主题样式的对应。 同时我们还学习了 useContext 的用法，它与 redux 等状态管理库的能力类似，是它们的底层实现方式，通过 useContext 定义注入器，我们对主题相关的代码进行了统一维护，满足了代码封装的单一职责原则。 相信一节课学习下来，同学们的收获还是很多的，因为篇幅的关系，一些代码细节我们没有逐字逐句去解释，同学们可以结合代码仓库进行调试，去理解整条链路是怎么实现的。 官网等 C 端应用中，常常会有一些复杂的动画来提高用户的交互体验，为了精准还原样式稿的设计，对于动画的实现，我们往往需要逐帧去对当前的动画状态进行描述。所以下一节课我们将来学习如何对复杂帧动画进行调试和实现。","link":"/2023/02/01/ssr/react/next/5.%E6%A0%B7%E5%BC%8F%E6%B3%A8%E5%85%A5,%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%B8%BB%E4%BD%93%E5%8C%96%E5%8A%9F%E8%83%BD/"},{"title":"AST","text":"在 C端的官网页面中，我们常常可以看到一些花哨的动画。好的动画可以给网页增色很多，给用户身临其境的体验，在技术成本允许的情况，适当在网页中加一下动画可以在页面加载或是交互的时候分散用户注意力并取悦用户。不仅如此，动画还可以用来提供独特的体验，甚至可以突出品牌的趣味性。 比如字节官网，首页有一些类似重力感应的球体动画。 又比如抖音前端技术团队官网，首屏也有一组复杂的首页加载动画。 可以说，一个 C 端开发者，熟悉动画的实现方式，并且具备逐帧调试的能力是很重要的。对于一些简单的动画大家应该都比较熟悉，但是对于需要逐帧去绘制的组合动画，应该怎么实现呢？ 动画的基础知识首先我们先了解一下什么是帧动画呢？ 定格动画，又名逐帧动画，是一种动画技术，其原理即将每帧不同的图像连续播放，从而产生动画效果。 简单来说，就是每帧下会有不同的状态和图像，从而组合在一起的复杂动画场景。对于 2D 的 Web 动画场景，我们常用四种方式来绘制动画： CSS Transtion：transition 只有起始状态和终点状态的概念，往往只能针对具体 dom 区域的相关属性变化进行简单动画场景绘制，不适用于帧动画场景。 CSS Animation：可以是多个状态，具备很强的灵活性，同时引入了帧的概念，并且支持主动触发，常用于复杂帧动画的绘制。 JavaScript：可以覆盖任何场景，但是绘制成本较大，针对较复杂场景，需要频繁操作 dom，同时会受到其他线程代码的影响，导致动画缺帧，建议只在动画极其复杂且高度定制、css 实现很困难的情况下才考虑这种方案。 Canvas：成本较高，且绘制内容的绑定事件都需要自己处理，加上因为依赖像素，当画布较大的时候，动画效果不佳。 所以我们这里使用 Animation 动画来实现帧动画，如果不熟悉它基本属性和能力的同学，建议阅读 MDN 相应的官方文档 来熟悉。因为比较基础，加上官方文档的内容相对更全面且具备实时性，我们这里就不重复搬运讲解基础概念和属性了，下面我们直接就实际的例子来实战讲解整个帧动画的开发过程。 实现一个帧动画的 Demo我们以 抖音前端技术团队官网 的首页加载动画为例，看看这个动画下究竟发生了什么？首先我们打开 控制台的 network，使用 performance 来录制首页加载的过程，为了能更清晰查看，我们适当降低 CPU 的性能，调整为 4 x slowdown。 我们点击控制台左上角的 ⚪，然后刷新页面，可以得到下面的逐帧列表： 从下面的加载图中我们可以判断出。这个动画总的执行时长为 1.36 s，然后上面的列表中有具体页面加载过程的帧动画变化图，通过按帧查看，咱们可以大概看出这个动画的执行顺序是这样的。 按照从小序列到大序列的顺序，每个元素分别执行了从下往上的平移操作，以及一个透明度从 0 到 1的过程，加上我们上面看到每个动画的时长分析都是1.3s，所以只是对每个元素推迟了不同的动画平移时间，但是它们享有相同的动画时长，针对这个场景我们应该怎么去实现呢？ 针对现在的首页，我们也可以把 dom 元素简单拆分为 8 个区域，我们可以把总动画时长定成 1s，其中 1s 的时间可以分为 9 个时间帧，每个区域从对应序列的时间帧开始执行相同的动画效果，最后把所有的帧连起来就是一个完整的帧动画，大致时间帧变化类似下图。 这样通过延迟执行的方式，我们就可以得到一种每个区域逐步滑入的视觉感知效果，现在我们开始着手实现，首先我们改造一下首页 Dom 的类，专门定义一个动画类来存放动画相关的样式，避免对基础样式造成污染。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// ./pages/index.tsximport type { NextPage } from &quot;next&quot;;import styles from &quot;./index.module.scss&quot;;import cName from &quot;classnames&quot;;// ...const Home: NextPage&lt;IProps&gt; = ({ title, description, list }) =&gt; { return ( &lt;div className={styles.container}&gt; &lt;main className={cName([styles.main, styles.withAnimation])} ref={mainRef} &gt; &lt;h1 className={styles.title}&gt;{title}&lt;/h1&gt; &lt;p className={styles.description}&gt;{description}&lt;/p&gt; &lt;div className={styles.grid}&gt; {list?.map((item, index) =&gt; { return ( &lt;div key={index} className={styles.card} onClick={(): void =&gt; { window.open( item.link, &quot;blank&quot;, &quot;noopener=yes,noreferrer=yes&quot; ); }} &gt; &lt;h2&gt;{item.label} &amp;rarr;&lt;/h2&gt; &lt;p&gt;{item.info}&lt;/p&gt; &lt;/div&gt; ); })} &lt;/div&gt; &lt;/main&gt; &lt;/div&gt; );};// ...export default Home; 然后我们开始定义对应的样式进行绑定，我们以 fadeInDown1 举例，@keyframes 指向动画的逐帧状态，其中 0% 和 11 %大家可以看到都是一样的内容，这时候区域处于 y 轴 40px 的位置，然后末尾状态是无区域状态和 1透明度，这个动画的效果会使得动画从整体时间的 11% 开始执行，到 100 % 完成最终的变化。 这个 11% 是从哪里来的呢？上面我们提到，我们为每个动画延迟一个帧频率执行，8 个区域，共 9 帧，所以 1 帧的占比为 11%的总动画时长，参考下面的动画，每个动画的起始时间（第二个状态值）都比上一个高出 1 帧的比例，这样就可以将整体帧动画串联起来了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182// ./pages/index.module.scss// ....withAnimation { .title { animation: fadeInDown1 1s; } .description { animation: fadeInDown2 1s; } .card:nth-of-type(1) { animation: fadeInDown3 1s; } .card:nth-of-type(2) { animation: fadeInDown4 1s; } .card:nth-of-type(3) { animation: fadeInDown5 1s; } .card:nth-of-type(4) { animation: fadeInDown6 1s; } .card:nth-of-type(5) { animation: fadeInDown7 1s; } .card:nth-of-type(6) { animation: fadeInDown8 1s; }}// ..@keyframes fadeInDown1 { 0% { transform: translate3d(0, 40px, 0); opacity: 0; } 11% { transform: translate3d(0, 40px, 0); opacity: 0; } 100% { -webkit-transform: none; transform: none; opacity: 1; }}@keyframes fadeInDown2 { 0% { transform: translate3d(0, 40px, 0); opacity: 0; } 22% { transform: translate3d(0, 40px, 0); opacity: 0; } 100% { -webkit-transform: none; transform: none; opacity: 1; }}@keyframes fadeInDown3 { 0% { transform: translate3d(0, 40px, 0); opacity: 0; } 33% { transform: translate3d(0, 40px, 0); opacity: 0; } 100% { -webkit-transform: none; transform: none; opacity: 1; }}@keyframes fadeInDown4 { 0% { transform: translate3d(0, 40px, 0); opacity: 0; } 44% { transform: translate3d(0, 40px, 0); opacity: 0; } 100% { -webkit-transform: none; transform: none; opacity: 1; }}@keyframes fadeInDown5 { 0% { transform: translate3d(0, 40px, 0); opacity: 0; } 55% { transform: translate3d(0, 40px, 0); opacity: 0; } 100% { -webkit-transform: none; transform: none; opacity: 1; }}@keyframes fadeInDown6 { 0% { transform: translate3d(0, 40px, 0); opacity: 0; } 66% { transform: translate3d(0, 40px, 0); opacity: 0; } 100% { -webkit-transform: none; transform: none; opacity: 1; }}@keyframes fadeInDown7 { 0% { transform: translate3d(0, 40px, 0); opacity: 0; } 77% { transform: translate3d(0, 40px, 0); opacity: 0; } 100% { -webkit-transform: none; transform: none; opacity: 1; }}@keyframes fadeInDown8 { 0% { transform: translate3d(0, 40px, 0); opacity: 0; } 88% { transform: translate3d(0, 40px, 0); opacity: 0; } 100% { -webkit-transform: none; transform: none; opacity: 1; }} 然后我们查看一下效果，可以看到动画效果已经实现了，其他类型的帧动画也是采用类似的做法， 将帧动画按帧数区分，每一帧下需要哪些区域进行操作，它们当时帧数下的状态又是怎样的 。确定好这个，我们只需要对每个区域，编写它们下面对应每一帧的样式，就可以实现我们预期的帧动画效果了。 怎么主动触发动画重新播放？那么如果我们需要主动触发这个动画效果应该怎么办呢，比如在切换主题的时候，我们希望能再执行一次加载动画，我们可以通过requestAnimationFrame来实现，它会返回一个回调，强制浏览器在重绘前调用指定的函数来进行动画的更新，我们使用这个来改造一下首页，加一个 useEffect 的钩子。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// ./pages/index.tsximport type { NextPage } from &quot;next&quot;;import styles from &quot;./index.module.scss&quot;;import cName from &quot;classnames&quot;;import { useContext, useEffect, useRef, useState } from &quot;react&quot;;import { ThemeContext } from &quot;@/stores/theme&quot;;// ...const Home: NextPage&lt;IProps&gt; = ({ title, description, list }) =&gt; { const mainRef = useRef&lt;HTMLDivElement&gt;(null); const { theme } = useContext(ThemeContext); useEffect(() =&gt; { mainRef.current?.classList.remove(styles.withAnimation); window.requestAnimationFrame(() =&gt; { mainRef.current?.classList.add(styles.withAnimation); }); }, [theme]); return ( &lt;div className={styles.container}&gt; &lt;main className={cName([styles.main, styles.withAnimation])} ref={mainRef} &gt; &lt;h1 className={styles.title}&gt;{title}&lt;/h1&gt; &lt;p className={styles.description}&gt;{description}&lt;/p&gt; &lt;div className={styles.grid}&gt; {list?.map((item, index) =&gt; { return ( &lt;div key={index} className={styles.card} onClick={(): void =&gt; { window.open( item.link, &quot;blank&quot;, &quot;noopener=yes,noreferrer=yes&quot; ); }} &gt; &lt;h2&gt;{item.label} &amp;rarr;&lt;/h2&gt; &lt;p&gt;{item.info}&lt;/p&gt; &lt;/div&gt; ); })} &lt;/div&gt; &lt;/main&gt; &lt;/div&gt; );};// ...export default Home; 在每次 theme 发生变化的时候，主动移除对应的动画类，再通过requestAnimationFrame对动画类进重新绑定，达到主动触发动画刷新的效果，现在我们来看一下最终成品。 小结这节课我们学习了怎么去实现一个相对复杂的帧动画，并尝试去使用 performance去慢放分析一个帧动画的细节进行还原，从成本、实现效果多方面考虑，我们通常会采用 CSS Animation的方式去实现相对复杂的帧动画，实现的关键在于分析出每帧的变化，根据区域去逐帧绘制，然后将所有的帧连起来，就可以实现一个完整的帧动画。 通常帧动画都会有重复绘制的需求，针对这类场景，我们可以使用requestAnimationFrame调起浏览器去执行我们预期的回调，将对应的动画类进行移除和重复添加，这样就可以在重绘的过程中再次执行一次我们的动画效果。 到这里我们官网的内容其实已经比较充实了，但是现在，我们只针对 16 英寸进行了样式适配，如果通过手机和 ipad 端访问，部分样式可能存在问题，下一节课，我会以首页作为案例，详细给大家介绍怎么全面覆盖主流多媒体设备。","link":"/2023/02/01/ssr/react/next/6.animation,%E5%A4%8D%E6%9D%82%E5%B8%A7%E5%8A%A8%E7%94%BB%E7%9A%84%E9%80%90%E5%B8%A7%E8%B0%83%E8%AF%95/"},{"title":"slot","text":"slot 插槽如何实现 Vue 提供了一个 &lt;slot&gt; 插槽的内置特殊元素，用来实现为子组件传递一些模板片段，然后由子组件完成对这些模版的渲染工作。一个简单的例子，这里有一个父组件，写入了一段插槽模版内容： 1234&lt;ChildComponent&gt; &lt;!-- 插槽内容 --&gt; hello world&lt;/ChildComponent&gt; 在子组件 &lt;ChildComponent&gt; 中则通过 &lt;slot&gt; 元素来实现对插槽内容的出口渲染： 1234&lt;div&gt; &lt;!-- 插槽出口 --&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/div&gt; &lt;slot&gt; 元素是一个插槽出口 (slot outlet)，标示了父元素提供的插槽内容 (slot content) 将在哪里被渲染。 插槽内容是如何被渲染到指定出口的。 插槽内容渲染一个组件如果携带一些插槽内容，那么这个组件在渲染的时候会产生变化（有哪些）。常规的 &lt;slot&gt; 插槽内容用法： 12345&lt;ChildComponent&gt; &lt;template #header&gt;header&lt;/template&gt; &lt;template #content&gt;content&lt;/template&gt; &lt;template #footer&gt;footer&lt;/template&gt;&lt;/ChildComponent&gt; 经过编译器转换后，生成的渲染函数如下： 123456789101112131415161718192021import { createTextVNode as _createTextVNode, resolveComponent as _resolveComponent, withCtx as _withCtx, openBlock as _openBlock, createBlock as _createBlock,} from &quot;vue&quot;;export function render(_ctx, _cache, $props, $setup, $data, $options) { const _component_ChildComponent = _resolveComponent(&quot;ChildComponent&quot;); return ( _openBlock(), _createBlock(_component_ChildComponent, null, { header: _withCtx(() =&gt; [_createTextVNode(&quot;header&quot;)]), content: _withCtx(() =&gt; [_createTextVNode(&quot;content&quot;)]), footer: _withCtx(() =&gt; [_createTextVNode(&quot;footer&quot;)]), _: 1 /* STABLE */, }) );} 可以看到，createBlock 的第三个参数 children 相对于普通父子节点来说，由一个数组变成一个对象的形式，这个对象包含了以插槽内容名称命名的函数，以及一个 _ 属性，这个属性的含义是 slotFlag。 createBlock 这个函数的实现，前面的章节中，createBlock 函数本质就是调用了 createVNode 函数创建 vnode 节点。创建 vnode 的时候产生的一些变化： 1234567891011121314151617181920function _createVNode( type, props, children, patchFlag, dynamicProps = null, isBlockNode = false) { // ... if (isVNode(type)) { // clone vnode const cloned = cloneVNode(type, props, true /* mergeRef: true */); if (children) { // 标准化子节点 normalizeChildren(cloned, children); } return cloned; } // ...} createVNode 函数在执行的时候，针对 vnode 节点如果存在子节点的话，会调用 normalizeChildren 函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445export function normalizeChildren(vnode, children) { let type = 0 const { shapeFlag } = vnode if (children == null) { children = null } else if (isArray(children)) { // 子节点是数组的情况 type = ShapeFlags.ARRAY_CHILDREN } else if (typeof children === 'object') { // 针对 children 是对象的处理内容 // 对于 ELEMENT 或者 TELEPORT slot 的处理 if (shapeFlag &amp; (ShapeFlags.ELEMENT | ShapeFlags.TELEPORT)) { const slot = (children as any).default if (slot) { slot._c &amp;&amp; (slot._d = false) normalizeChildren(vnode, slot()) slot._c &amp;&amp; (slot._d = true) } return } else { // 标记子节点类型为 SLOTS_CHILDREN type = ShapeFlags.SLOTS_CHILDREN const slotFlag = (children as RawSlots)._ if (!slotFlag &amp;&amp; !(InternalObjectKey in children!)) { // 如果 slots 还没有被标准化，添加上下文实例 ;(children as RawSlots)._ctx = currentRenderingInstance } else if (slotFlag === SlotFlags.FORWARDED &amp;&amp; currentRenderingInstance) { // 处理 slotFlag 为 FORWARDED 的情况 // 处理 STABLE slot if ( (currentRenderingInstance.slots as RawSlots)._ === SlotFlags.STABLE ) { ;(children as RawSlots)._ = SlotFlags.STABLE } else { // 添加 DYNAMIC slot ;(children as RawSlots)._ = SlotFlags.DYNAMIC vnode.patchFlag |= PatchFlags.DYNAMIC_SLOTS } } } } // ... vnode.children = children vnode.shapeFlag |= type} 如果传入的子节点类型是个 Object 的情况下，会为 vnode.shapeFlag 属性添加 SLOTS_CHILDREN 类型。那这个 shapeFlag 在哪里会被用到了？再回到之前的组件挂载过程中的 setupComponent 函数中： 1234567891011export function setupComponent(instance) { // 1. 处理 props // 取出存在 vnode 里面的 props const { props, children } = instance.vnode; initProps(instance, props); // 2. 处理 slots initSlots(instance, children); // 3. 调用 setup 并处理 setupResult setupStatefulComponent(instance);} 查看如何处理 slots 的： 1234567891011121314151617181920export const initSlots = (instance, children) =&gt; { // shapeFlag 有 SLOTS_CHILDREN 类型 if (instance.vnode.shapeFlag &amp; ShapeFlags.SLOTS_CHILDREN) { // 对于示例中，slotFlag 类型是 STABLE const type = (children as RawSlots)._ if (type) { // 用户可以使用 this.$slots 来获取 slots 对象的浅拷贝内部实例上的 slots // 所以这里应该避免 proxy 对象污染 // 为 instance slots 属性赋值 children instance.slots = toRaw(children) // 标记不可枚举 def(children, '_', type) } // ... } else { instance.slots = {} // ... } def(instance.slots, InternalObjectKey, 1)} 针对上面的示例，首先 slots 渲染的 slotFlag 类型为 STABLE，所以这里的 initSlot 所做的操作就是为 instance.slots 赋值为 toRaw(children)。 到这里，可以认为，对于一个组件中如果包含 slot 内容，那么这个组件实例在被渲染的时候，这些内容将会被添加到当前组件实例的 instance.slots 属性上： 123456789101112131415161718192021// ChildComponent 组件实例{ type: { name: &quot;ChildComponent&quot;, render: render(_ctx, _cache) { ... }, // ... }, slots: { header: _withCtx(() =&gt; [ _createTextVNode(&quot;header&quot;) ]), content: _withCtx(() =&gt; [ _createTextVNode(&quot;content&quot;) ]), footer: _withCtx(() =&gt; [ _createTextVNode(&quot;footer&quot;) ]), }, vnode: {...} // ...} 注意，slots 是被挂载到了子组件实例 ChildComponent 中，而非父组件中。 插槽出口渲染插槽除了有内容外，还需要制定对象的出口，上述示例中对应的出口内容： 12345&lt;div&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;slot name=&quot;content&quot;&gt;&lt;/slot&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;&lt;/div&gt; 上面的模版会被编译器编译成如下渲染函数： 12345678910111213141516import { renderSlot as _renderSlot, openBlock as _openBlock, createElementBlock as _createElementBlock,} from &quot;vue&quot;;export function render(_ctx, _cache, $props, $setup, $data, $options) { return ( _openBlock(), _createElementBlock(&quot;div&quot;, null, [ _renderSlot(_ctx.$slots, &quot;header&quot;), _renderSlot(_ctx.$slots, &quot;content&quot;), _renderSlot(_ctx.$slots, &quot;footer&quot;), ]) );} 带有 &lt;slot&gt; 内容的元素，会被 renderSlot 函数进行包裹： 123456789101112131415161718192021222324export function renderSlot(slots, name, props, fallback, noSlotted) { // ... // 根据 name 获取 slot 内容 let slot = slots[name] openBlock() const validSlotContent = slot &amp;&amp; ensureValidVNode(slot(props)) // 创建 slot vnode const rendered = createBlock( Fragment, { key: props.key || (validSlotContent &amp;&amp; (validSlotContent as any).key) || `_${name}` }, validSlotContent || (fallback ? fallback() : []), validSlotContent &amp;&amp; (slots as RawSlots)._ === SlotFlags.STABLE ? PatchFlags.STABLE_FRAGMENT : PatchFlags.BAIL ) // ... // 返回 slot vnode return rendered} renderSlot 函数核心功能就是根据 slot 的 name 属性去子组件实例上的 slots 中查找对应的执行函数，然后创建一个以 slot 为子节点的 Fragment 类型的 vnode 节点。 上述 slot 容器中的内容是通过 withCtx(...) 函数进行封装执行的，函数实现： 123456789101112131415161718192021export function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) { // ... const renderFnWithContext: ContextualRenderFn = (...args: any[]) =&gt; { if (renderFnWithContext._d) { setBlockTracking(-1); } // 暂存子组件实例 const prevInstance = setCurrentRenderingInstance(ctx); let res; try { // 运行创建 vnode 的函数 res = fn(...args); } finally { // 重置回子组件实例 setCurrentRenderingInstance(prevInstance); } return res; }; // ... return renderFnWithContext;} withCtx 函数巧妙的利用了闭包的特性，在运行父组件的时候，通过 withCtx 保存了父组件的实例到 currentRenderingInstance 变量上，然后在子组件执行 renderFnWithContext 函数时，先恢复父组件的实例上下文，再执行生成 vnode 函数，执行完成后，再重置回子组件的实例。这样做的好处是在做 &lt;slot&gt; 渲染内容的时候，让 slot 的内容可以访问到父组件的实例，因为 slot 内容本身也是在父组件中定义的，只是被渲染到了指定的子组件中而已。 Dynamic Slotsdynamic slots 是用于判断 slot 内容是否需要更新。 Vue 3 中，对于动态的插槽名、条件判断、循环等场景的 &lt;slot&gt;，则会被标记为 dynamic slots，拿动态的插槽名举例： 123&lt;child-component&gt; &lt;template #[dynamicSlotName]&gt;header&lt;/template&gt;&lt;/child-component&gt; 则会被渲染成： 123456789101112131415161718192021222324import { createTextVNode as _createTextVNode, resolveComponent as _resolveComponent, withCtx as _withCtx, openBlock as _openBlock, createBlock as _createBlock,} from &quot;vue&quot;;export function render(_ctx, _cache, $props, $setup, $data, $options) { const _component_child_component = _resolveComponent(&quot;child-component&quot;); return ( _openBlock(), _createBlock( _component_child_component, null, { [_ctx.dynamicSlotName]: _withCtx(() =&gt; [_createTextVNode(&quot;header&quot;)]), _: 2 /* DYNAMIC */, }, 1024 /* DYNAMIC_SLOTS */ ) );} 对于动态的插槽名，组件渲染函数会为 patchFlag 标记为 DYNAMIC_SLOTS。在执行组件更新时，则会根据这个标记来判断当前组件是否需要更新： 1234567891011121314151617const updateComponent = (n1, n2, vnode) =&gt; { if (shouldUpdateComponent(n1, n2, optimized)) { // ... // 执行更新逻辑 }};function shouldUpdateComponent(prevVNode, nextVNode, optimized) { // ... const { props: nextProps, children: nextChildren, patchFlag } = nextVNode; // patchFlag 是 DYNAMIC_SLOTS 的情况，shouldUpdateComponent 返回 true if (optimized &amp;&amp; patchFlag &gt;= 0) { if (patchFlag &amp; PatchFlags.DYNAMIC_SLOTS) { return true; } }} 总结&lt;slot&gt; 内置元素的实现原理，本质上就是父组件在渲染的时候，如果遇到了 &lt;slot&gt; 内容，则会暂时将其缓存到组件实例上，然后在组件实例化的过程中，从父组件中取出对应的 slots 按照名称进行渲染到指定位置。 同时配合 PatchFlags 属性，可以做到只有在 DYNAMIC_SLOTS 的情况下，才去更新含有 slot 的组件，减少了不必要的渲染性能负担。","link":"/2023/08/05/vue/%E5%85%B6%E4%BB%96/%E7%89%B9%E6%AE%8A%E5%85%83%E7%B4%A0/slot/"},{"title":"AST","text":"上一节课我们学习了怎么对官网项目进行多媒体适配，我们通过 CSS media，注入设备信息以及服务器端请求获取三种方式实现了不同场景下的多媒体适配。因为 SSR 的特殊性，我们需要针对不同的场景选用合适的适配方法，来达到更理想的效果。 这节课我将来给大家介绍官网中最常见的两个需求，一个是文章页分页，另一个是国际化多语言。 官网作为一个品牌形象的载体，肯定需要大量的文章或是信息，来进行文化价值观的传输，文章的内容一多，我们自然需要为它实现对应的分页。至于国际化多语言，我们的官网不一定是给一个国家的人看的，可能公司或是团队的业务是针对多个地区的，语言不应该成为价值观传输的阻碍，所以如果是多地区业务线的公司，实现多语言也是很必要的，那么这两个功能我们应该怎么去实现呢？ 在08 | 数据可视化：基于 Strapi 实现后台数据的灵活配置 我们通过配置 Strapi 实现了 layout 部分的数据注入，使用了它的 find 接口进行 cdn 层的数据灵活配置，这节课我们将来重新认识我们的老朋友 Strapi，使用它来实现官网常见的文章页分页和国际化多语言的功能。 文章页分页样式的实现我们之前在首页有配置一个静态的六个文章块，不过没有分页，所以我们首先来实现一下静态样式，分页的组件我们可以使用 semi-design来实现，这是字节跳动抖音前端技术团队推出的一款样式组件库，设计上和易用性上都经过各种大型项目的考验，我们平时业务开发主要也是用它，还是很推荐大家使用的，我们先来装一下依赖。 1npm install @douyinfe/semi-ui --save 然后我们给首页文章块下面加一个分页。 1234567// ./pages/index.tsx;import { Pagination } from &quot;@douyinfe/semi-ui&quot;;// ...&lt;div className={styles.paginationArea}&gt; &lt;Pagination total={articles?.total} pageSize={6} /&gt;&lt;/div&gt;;// ... 这时候我们发现控制台会有一个编译报错。 这个报错的原因是因为 Nextjs 希望我们可以自主导入依赖中的样式，而不是随着依赖直接导入样式，避免稀里糊涂对全局样式造成影响，Semi的依赖默认是在入口文件统一导入的，针对这种情况，Semi 提供了 semi-next 插件来对入口文件样式进行去除，然后我们再自行导入就可。 1npm i @douyinfe/semi-next 安装好 semi-next 后，我们到 nextjs 的配置文件，用 semi-next 包裹一层配置文件，进行默认导入样式的去除。 12345678910111213141516171819// ./next.config.jsconst path = require(&quot;path&quot;);const semi = require(&quot;@douyinfe/semi-next&quot;).default({});module.exports = semi({ reactStrictMode: true, swcMinify: true, webpack: (config) =&gt; { config.resolve.alias = { ...config.resolve.alias, &quot;@&quot;: path.resolve(__dirname), }; return config; }, images: { domains: [&quot;127.0.0.1&quot;], },}); 接下来，我们在全局样式中手动导入 Semi 的样式，发现报错就没有了。 12// ./pages/global.scss@import &quot;~@douyinfe/semi-ui/dist/css/semi.min.css&quot;; 现在我们可以打开 http://127.0.0.1:3000 来看一下分页的效果。 因为我们有做主题化，所以 Semi 的样式不能直接在我们页面中用。我们需要针对分页组件覆盖一下主题化的样式，样式覆盖是通过 global样式去做，通常组件库的样式都会采用普通类的方式，而不是模块化样式，我们都可以在页面中通过 global去全局覆盖对应类下的样式，达到组件样式自定义。这一块的样式，之前我们是直接复用了脚手架初始化的样式，层级上也比较乱，我们顺便一起梳理一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265@mixin initStatus { transform: translate3d(0, 2.5rem, 0); opacity: 0;}@mixin finalStatus { -webkit-transform: none; transform: none; opacity: 1;}.container { padding: 0 2rem; color: var(--primary-color); .main { min-height: 100vh; padding: 4rem 0; flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; .title a { color: var(--link-color); text-decoration: none; } .title a:hover, .title a:focus, .title a:active { text-decoration: underline; } .title { margin: 0; line-height: 1.15; font-size: 4rem; } .title, .description { text-align: center; } .description { margin: 4rem 0; line-height: 1.5; font-size: 1.5rem; } .grid { display: flex; align-items: center; justify-content: center; flex-wrap: wrap; max-width: 50rem; transition: 2s; .card { margin: 1rem; padding: 1.5rem; text-align: left; color: inherit; text-decoration: none; border: 0.0625rem solid var(--footer-background-color); border-radius: 0.625rem; transition: color 0.15s ease, border-color 0.15s ease; max-width: 18.75rem; cursor: pointer; } .card:hover, .card:focus, .card:active { color: var(--link-color); border-color: var(--link-color); } .card h2 { margin: 0 0 1rem 0; font-size: 1.5rem; } .card p { margin: 0; font-size: 1.25rem; line-height: 1.5; } } .paginationArea { width: 43.125rem; display: flex; justify-content: flex-end; padding: 20px 0; :global { .semi-page-item { color: var(--primary-color); opacity: 0.7; } .semi-page-item:hover { background-color: var(--semi-page-hover-background-color); } .semi-page-item-active { color: var(--semi-page-active-color); background-color: var(--semi-page-active-background-color); } .semi-page-item-active:hover { color: var(--semi-page-active-color); background-color: var(--semi-page-active-background-color); } } } } .withAnimation { .title { animation: fadeInDown1 1s; } .description { animation: fadeInDown2 1s; } .card:nth-of-type(1) { animation: fadeInDown3 1s; } .card:nth-of-type(2) { animation: fadeInDown4 1s; } .card:nth-of-type(3) { animation: fadeInDown5 1s; } .card:nth-of-type(4) { animation: fadeInDown6 1s; } .card:nth-of-type(5) { animation: fadeInDown7 1s; } .card:nth-of-type(6) { animation: fadeInDown8 1s; } } @keyframes fadeInDown1 { 0% { @include initStatus; } 11% { @include initStatus; } 100% { @include finalStatus; } } @keyframes fadeInDown2 { 0% { @include initStatus; } 22% { @include initStatus; } 100% { @include finalStatus; } } @keyframes fadeInDown3 { 0% { @include initStatus; } 33% { @include initStatus; } 100% { @include finalStatus; } } @keyframes fadeInDown4 { 0% { @include initStatus; } 44% { @include initStatus; } 100% { @include finalStatus; } } @keyframes fadeInDown5 { 0% { @include initStatus; } 55% { @include initStatus; } 100% { @include finalStatus; } } @keyframes fadeInDown6 { 0% { @include initStatus; } 66% { @include initStatus; } 100% { @include finalStatus; } } @keyframes fadeInDown7 { 0% { @include initStatus; } 77% { @include initStatus; } 100% { @include finalStatus; } } @keyframes fadeInDown8 { 0% { @include initStatus; } 88% { @include initStatus; } 100% { @include finalStatus; } }} 然后我们来看看调整后的效果，还是很理想的。 接下来我们对之前的文章页也写一些简单的样式，再提供一下标题、作者、描述这些字段，代码这边就不讲解了，都是一些基础的样式代码，同学们可以下来自己看一看，效果是这样的。 接口层的实现样式咱们已经搞定了，接下来我们来为文章页分页定义一下接口。我们需要参照 08 | 数据可视化：基于 Strapi 实现后台数据的灵活配置 和 09 | BFF 数据流转：Nextjs 中的页面数据流转开发实战的做法， 把它配置到 Strapi 上，现在首页和文章页的数据结构是这样的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// ./pages/index.tsx{ title: &quot;Hello SSR!&quot;, description: &quot;A Demo for 《SSR 实战：官网开发指南》&quot;, articles: { list: [ { label: &quot;文章1&quot;, info: &quot;A test for article1&quot;, link: &quot;http://localhost:3000/article/1&quot;, }, { label: &quot;文章2&quot;, info: &quot;A test for article2&quot;, link: &quot;http://localhost:3000/article/2&quot;, }, { label: &quot;文章3&quot;, info: &quot;A test for article3&quot;, link: &quot;http://localhost:3000/article/3&quot;, }, { label: &quot;文章4&quot;, info: &quot;A test for article4&quot;, link: &quot;http://localhost:3000/article/4&quot;, }, { label: &quot;文章5&quot;, info: &quot;A test for article5&quot;, link: &quot;http://localhost:3000/article/5&quot;, }, { label: &quot;文章6&quot;, info: &quot;A test for article6&quot;, link: &quot;http://localhost:3000/article/6&quot;, }, ], total: 12, }, } // ./pages/article/[articleId].tsx { title: `文章${articleId}`, author: &quot;zhenmin&quot;, description: `a description for 文章${articleId}`, createTime: &quot;2022/8/16&quot;, content: &quot;文章内容&quot;, } 针对这个数据结构，我们设计三个结构体，ArticleInfo、ArticleIntroduction 和 Home，其中 Home就是首页那两个基础文案，ArticleIntroduction 是文章相关的简介，link 我们指向 ArticleInfo 对应元素的 id即可。 这里文章内容我们单独放在 ArticleInfo，之所以这么做，是因为考虑到文章内容往往很多，如果放在 ArticleIntroduction 中进行分页，cdn 拉取的时间随着文章的增多，可能会越来越长。 首先我们来配置一下对应的结构体，启动一下 CMS 的项目，为了便于讲解，大家可以直接打开教学仓库的 master 分支查看，我有为大家保存缓存，所以拉取最新代码打开是可以直接看到我们的配置的。 其中大部分配置大家直接看就好了，在08 | 数据可视化：基于 Strapi 实现后台数据的灵活配置我们大多有介绍，值得一提的是， ArticleInfo 中的 content 使用的是富文本，可以配置标题、加粗、图片等，并返回对应的markdown 文本，非常适合文章页的数据源，有了结构体，接下来我们要做的就是对对应的结构体配置数据，我们切换到 ContentManager 目录下。 我们已经有配置一些数据，其中富文本区域的配置我们需要着重关注一下，大家可以打开第一篇文章，《时政新闻眼…》，这篇文章是我到新闻上随便找的一篇，其中包含了文本、标题和图片，我们看看它的配置是咋样的。 这个其实和我们常用的一些文本编辑器还是很像的，点击 preview mode 处可以看到效果，我们按照平时写笔记的习惯，用markdown语言去配置文章就可以了，这里需要注意的是，图片导入后它默认会插入相对当前域名的相对路径，我们需要手动补上域名，因为我们站点的域名未必和现在是相同的，可能会出现资源404 的情况，这个文章我们预览一下效果看看。 看上去很简陋，不过没关系，只要标签相关正确就可，样式我们可以后续再定义美化。接下来我们按照之前的配置，给这些结构体开一下 find、findone 等配置，不记得的同学可以查阅08 | 数据可视化：基于 Strapi 实现后台数据的灵活配置 中 Api 权限配置及上线的模块。 配置好了，以后我们随便开一个模块看看。 好像有 time 等相关数据，08 | 数据可视化：基于 Strapi 实现后台数据的灵活配置我们也有提过这个场景，我们需要参照上次，把对应用不上的数据清掉，这里我们以 home 为例。 12345678910111213141516171819&quot;use strict&quot;;const { removeTime, removeAttrsAndId } = require(&quot;../../../utils/index.js&quot;);/** * home controller */const { createCoreController } = require(&quot;@strapi/strapi&quot;).factories;module.exports = createCoreController(&quot;api::home.home&quot;, ({ strapi }) =&gt; ({ async find(ctx) { ctx.query = { ...ctx.query, populate: &quot;deep&quot;, }; const { data } = await super.find(ctx); return removeAttrsAndId(removeTime(data[0])); },})); 然后我们对其他模块进行相同的处理，具体代码同学们可以在 CMS 仓库查看，这里就不贴出来了。 除此之外，我们还需要额外对 ArticleIntroduce 做一个分页的操作，Strapi 中针对分页的操作提供了pagination[page] 和 pagination[pageSize]两个参数，类似下面的效果。 1/api/articles?pagination[page]=1&amp;pagination[pageSize]=10 // 按10个/页分页，返回第一页的数据 这两个参数太长了，也不好记，我们定义两个我们自己的参数，pageNo, pageSize，然后咱们在它的基础上魔改一下就可以，具体代码如下： 1234567891011121314151617181920212223242526&quot;use strict&quot;;const { removeTime, removeAttrsAndId } = require(&quot;../../../utils/index.js&quot;);/** * article-introduction controller */const { createCoreController } = require(&quot;@strapi/strapi&quot;).factories;module.exports = createCoreController( &quot;api::article-introduction.article-introduction&quot;, ({ strapi }) =&gt; ({ async find(ctx) { const { pageNo, pageSize, ...params } = ctx.query; if (pageNo &amp;&amp; pageSize) { ctx.query = { ...params, &quot;pagination[page]&quot;: Number(pageNo), &quot;pagination[pageSize]&quot;: Number(pageSize), }; } const { data, meta } = await super.find(ctx); return { data: removeAttrsAndId(removeTime(data)), meta }; }, })); 然后大家可以访问一下三个接口试试，应该都有符合我们预期的数据了，接下来我们开始编写我们 BFF 层的代码，三个结构体分别对应三个接口层，home 的最简单，我们透传即可。 12345678910111213141516171819202122// ./pages/api/home.tsimport type { NextApiRequest, NextApiResponse } from &quot;next&quot;;import axios from &quot;axios&quot;;import { CMSDOMAIN } from &quot;@/utils&quot;;interface IHomeProps { title: string; description: string;}const getHomeData = (req: NextApiRequest, res: NextApiResponse&lt;IHomeProps&gt;) =&gt; { axios.get(`${CMSDOMAIN}/api/homes`).then((result) =&gt; { const { title, description } = result.data || {}; res.status(200).json({ title, description, }); });};export default getHomeData; 接下来是文章简介的接口，它可以接受分页的两个入参进行对应的分页。 123456789101112131415161718192021222324252627282930313233343536373839// ./pages/api/articleIntro.tsimport type { NextApiRequest, NextApiResponse } from &quot;next&quot;;import axios from &quot;axios&quot;;import { CMSDOMAIN } from &quot;@/utils&quot;;export interface IArticleIntro { label: string; info: string; articleId: number;}interface IArticleIntroProps { list: Array&lt;{ label: string; info: string; articleId: number }&gt;; total: number;}const getArticleIntroData = ( req: NextApiRequest, res: NextApiResponse&lt;IArticleIntroProps&gt;) =&gt; { const { pageNo, pageSize } = req.body; axios .get(`${CMSDOMAIN}/api/article-introductions`, { params: { pageNo, pageSize, }, }) .then((result) =&gt; { const { data, meta } = result.data || {}; res.status(200).json({ list: Object.values(data), total: meta.pagination.total, }); });};export default getArticleIntroData; 其中 list 我们为什么需要用 Object.values 包一层 data 呢，细心的同学可能已经发现了，针对没有 relation 的多个元素， Strapi 是通过 object 类型返回给我们的，所以我们需要处理一层转成我们需要的数组格式。 最后一个接口是文章详情的接口，那个接口包含一个 id 的入参，可以支持对数据进行单查，我们直接调用 Strapi 的 findOne 接口实现就好。 123456789101112131415161718// ./pages/api/articleInfo.tsimport type { NextApiRequest, NextApiResponse } from &quot;next&quot;;import axios from &quot;axios&quot;;import { CMSDOMAIN } from &quot;@/utils&quot;;import { IArticleProps } from &quot;../article/[articleId]&quot;;const getArticleInfoData = ( req: NextApiRequest, res: NextApiResponse&lt;IArticleProps&gt;) =&gt; { const { articleId } = req.query; axios.get(`${CMSDOMAIN}/api/article-infos/${articleId}`).then((result) =&gt; { const data = result.data || {}; res.status(200).json(data); });};export default getArticleInfoData; 到这里我们 BFF 层就定义好了，接下来我们改造一下首页，接入一下接口替换我们原先的静态数据。 123456789101112131415161718192021222324252627// ./pages/index.tsx// ...Home.getInitialProps = async (context) =&gt; { const { data: homeData } = await axios.get(`${LOCALDOMAIN}/api/home`); const { data: articleData } = await axios.post( `${LOCALDOMAIN}/api/articleIntro`, { pageNo: 1, pageSize: 6, } ); return { title: homeData.title, description: homeData.description, articles: { list: articleData.list.map((item: IArticleIntro) =&gt; { return { label: item.label, info: item.info, link: `${LOCALDOMAIN}/article/${item.articleId}`, }; }), total: articleData.total, }, };}; 然后我们看看效果，数据已经注入进去了，不过样式有点糟糕，我们优化一下。 1234567891011121314151617181920212223242526// ./pages/index.module.scss//...grid { display: flex; align-items: flex-start; justify-content: flex-start; flex-wrap: wrap; max-width: 62.5rem; transition: 2s; min-height: 36.25rem; .card { margin: 1rem; padding: 1.5rem; text-align: left; color: inherit; text-decoration: none; border: 0.0625rem solid var(--footer-background-color); border-radius: 0.625rem; transition: color 0.15s ease, border-color 0.15s ease; max-width: 18.75rem; cursor: pointer; width: 18.75rem; height: 13.875rem; } //...} 现在就好多了，不过这时候还没完，我们需要把客户端的分页事件绑定一下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// ./pages/index.tsximport type { NextPage } from &quot;next&quot;;import styles from &quot;./index.module.scss&quot;;import cName from &quot;classnames&quot;;import { useContext, useEffect, useRef, useState } from &quot;react&quot;;import { ThemeContext } from &quot;@/stores/theme&quot;;import { Pagination } from &quot;@douyinfe/semi-ui&quot;;import axios from &quot;axios&quot;;import { LOCALDOMAIN } from &quot;@/utils&quot;;import { IArticleIntro } from &quot;./api/articleIntro&quot;;interface IProps { title: string; description: string; articles: { list: { label: string; info: string; link: string; }[]; total: number; };}const Home: NextPage&lt;IProps&gt; = ({ title, description, articles }) =&gt; { const [content, setContent] = useState(articles); const mainRef = useRef&lt;HTMLDivElement&gt;(null); const { theme } = useContext(ThemeContext); useEffect(() =&gt; { mainRef.current?.classList.remove(styles.withAnimation); window.requestAnimationFrame(() =&gt; { mainRef.current?.classList.add(styles.withAnimation); }); }, [theme]); return ( &lt;div className={styles.container}&gt; &lt;main className={cName([styles.main, styles.withAnimation])} ref={mainRef} &gt; &lt;h1 className={styles.title}&gt;{title}&lt;/h1&gt; &lt;p className={styles.description}&gt;{description}&lt;/p&gt; &lt;div className={styles.grid}&gt; {content?.list?.map((item, index) =&gt; { return ( &lt;div key={index} className={styles.card} onClick={(): void =&gt; { window.open( item.link, &quot;blank&quot;, &quot;noopener=yes,noreferrer=yes&quot; ); }} &gt; &lt;h2&gt;{item.label} &amp;rarr;&lt;/h2&gt; &lt;p&gt;{item.info}&lt;/p&gt; &lt;/div&gt; ); })} &lt;div className={styles.paginationArea}&gt; &lt;Pagination total={content?.total} pageSize={6} onPageChange={(pageNo) =&gt; { axios .post(`${LOCALDOMAIN}/api/articleIntro`, { pageNo, pageSize: 6, }) .then(({ data }) =&gt; { setContent({ list: data.list.map((item: IArticleIntro) =&gt; { return { label: item.label, info: item.info, link: `${LOCALDOMAIN}/article/${item.articleId}`, }; }), total: data.total, }); }); }} /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/main&gt; &lt;/div&gt; );};// ... 然后我们访问一下 http://127.0.0.1:3000，需要注意的是，这里不能直接访问 localhost，因为我们接口并没有设置 localhost 的域，会出现跨域的情况，我们可以参考 09 | BFF 数据流转：Nextjs 中的页面数据流转开发实战 中间件章节的做法，引入 cros 的中间件，把 localhost 配置 origin 即可，感兴趣的同学可以下来自己尝试一下 现在我们来看一下效果，效果还是可以的 接下来我们给对应的文章页面绑定一下接口数据。 12345678910// ./pages/article/[articleId].tsxArticle.getInitialProps = async (context) =&gt; { const { articleId } = context.query; const { data } = await axios.get(`${LOCALDOMAIN}/api/articleInfo`, { params: { articleId, }, }); return data;}; 来看看效果。 现在已经完成数据的注入了，不过这个和我们预想的还不太一样，因为现在还是 markdown 的文本，没有显示出对应的标题，咱们需要把它换成 HTML。 Markdown 转 HTML 我们可以使用 showdown，这是一个免费的开源转换 markdown 为 HTML 的库，首先我们来装一下对应的依赖。 1npm install showdown --save 然后我们对页面的 content 进行一下转换。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// ./pages/article/[articleId].tsximport { LOCALDOMAIN } from &quot;@/utils&quot;;import axios from &quot;axios&quot;;import type { NextPage } from &quot;next&quot;;import styles from &quot;./styles.module.scss&quot;;const showdown = require(&quot;showdown&quot;);export interface IArticleProps { title: string; author: string; description: string; createTime: string; content: string;}const Article: NextPage&lt;IArticleProps&gt; = ({ title, author, description, createTime, content,}) =&gt; { const converter = new showdown.Converter(); return ( &lt;div className={styles.article}&gt; &lt;h1 className={styles.title}&gt;{title}&lt;/h1&gt; &lt;div className={styles.info}&gt; 作者：{author} | 创建时间: {createTime} &lt;/div&gt; &lt;div className={styles.description}&gt;{description}&lt;/div&gt; &lt;div&gt;{converter.makeHtml(content)}&lt;/div&gt; &lt;/div&gt; );};Article.getInitialProps = async (context) =&gt; { const { articleId } = context.query; const { data } = await axios.get(`${LOCALDOMAIN}/api/articleInfo`, { params: { articleId, }, }); return data;};export default Article; 可以看到，现在已经转成我们需要的 HTML 文本了，但是新的问题来了，我们应该怎样把 HTML 文本渲染成我们需要的 dom呢，我们可以使用 dangerouslySetInnerHTML， 之所以这个属性包含一个 dangerous，原因和 eval相似，因为它可以在客户端手动执行一段代码（Dom)，在执行为用户输入的内容时，是会有一定风险的，我们这个是来自我们自己的底层 CDN，所以数据相关有安全保证，对于外部输入的场景，同学们在使用的时候需要衡量一下。 12// ./pages/article/[articleId].tsx&lt;div dangerouslySetInnerHTML={{ __html: converter.makeHtml(content) }} /&gt; 可以看到现在已经可以渲染成我们需要的元素了，不过样式太丑了，因为配置的时候富文本是可以随意配置的，这样会导致整体样式五花八门，我们需要进行一下统一的相关限制。 123456789101112131415// ./pages/article/[articleId].tsx&lt;div dangerouslySetInnerHTML={{ __html: converter.makeHtml(content) }} className={styles.content} /&gt;// ./pages/article/styles.module.scss.content { margin-bottom: 5rem; font-size: 16px; line-height: 32px; img { width: 50rem; } } 这样效果就好多了，后面如果官网有文章迭代的需求，也只需要让运营同学到 Strapi 平台配置一下对应的富文本发布就好了。 首页和文章页的多媒体适配在12 | 多媒体适配: 官网的设备样式兼容方案 ，我给同学们留了多媒体适配的作业，不知道大家做了吗，没做也没关系，现在我们改造完首页和文章页，一起来实现这部分。首先我们针对首页进行一下简单适配。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// ./pages/index.module.scss@import &quot;./media.scss&quot;;// ...@include media-ipad { .container { .main { .grid { width: 95%; margin: auto; justify-content: center; } } }}@include media-mobile { .container { .main { .title { font-size: 1.75rem; line-height: 2.4375rem; } .description { font-size: 0.875rem; line-height: 1.5rem; margin: 2rem 0; } .grid { width: 95%; margin: auto; justify-content: center; .card { height: 10rem; h2 { font-size: 1.125rem; line-height: 1.5625rem; } p { font-size: 0.75rem; line-height: 1.625rem; } } } } }} 我们来看一下效果。 文章页咱们也适配一下。 1234567891011121314151617181920212223242526272829303132// ./pages/article/styles.module.scss@import &quot;../media.scss&quot;;// ...@include media-ipad { .article { width: 80%; .content { img { width: 100%; } } }}@include media-mobile { .article { width: 80%; .title { font-size: 1.75rem; line-height: 2.4375rem; } .content { h2 { font-size: 1.125rem; line-height: 1.5625rem; } img { width: 100%; } } }} 我们看看效果。 到这里，我们文章页分页的内容就已经全部实现了 国际化分页的功能实现了，国际化的功能我们应该怎么实现呢？每个页面不同语言展示不同的文案内容，难道我们要为每种语言写一套页面吗？那开发国际化平台的同学可能已经准备提桶跑路了… 有没有什么更灵活快捷的方式吗？其实这个方法我们在前几节课就已经有所涉猎了，在讲解方法之前，我想请大家将国际化、主题化和多媒体适配的注入联系起来看看，它们有什么共同之处吗？ 没错，它们都是每个页面共同的部分，每个页面都有相同的语言，主题化和多媒体适配，那我们是不是也可以针对语言来定义一套注入器（Context)，通过缓存的方式统一管理，然后进行全局的注入。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// ./stores/language.tsximport React, { useState, useEffect, createContext } from &quot;react&quot;;import { Language } from &quot;@/constants/enum&quot;;interface ILanguageContextProps { language: Language; setLanguage: (language: Language) =&gt; void;}interface IProps { children: JSX.Element;}export const LanguageContext = createContext&lt;ILanguageContextProps&gt;( {} as ILanguageContextProps);export const LanguageContextProvider = ({ children }: IProps): JSX.Element =&gt; { const [language, setLanguage] = useState&lt;Language&gt;(Language.ch); useEffect(() =&gt; { const checkLanguage = (): void =&gt; { const item = (localStorage.getItem(&quot;language&quot;) as Language) || Language.ch; setLanguage(item); }; checkLanguage(); window.addEventListener(&quot;storage&quot;, checkLanguage); return (): void =&gt; { window.removeEventListener(&quot;storage&quot;, checkLanguage); }; }, []); return ( &lt;LanguageContext.Provider value={{ language, setLanguage: (currentLanguage) =&gt; { setLanguage(currentLanguage); localStorage.setItem(&quot;language&quot;, currentLanguage); }, }} &gt; {children} &lt;/LanguageContext.Provider&gt; );}; 那么注入完成，我们怎么对每个文案进行多个语言的翻译呢？我们只需要在 Strapi 配置对应语言的文案即可，比如中文的 title 字段我们叫做 titlech，英文的 title 字段我们叫做 titleen，前缀相同，结尾文案与我们定义的类型相同，我们就可以在页面中直接采取 title${language}的方式调用了。 同时这样实现有个好处，不仅仅是单纯的对文案进行翻译，在不同的地区需要展示的文化信息是不尽相同的，以字节官网为例，中文和英文并不是单纯的机翻。 针对不同地区的同学，需要针对他们的文化去定制化的宣传，多站在对方的角度上去思考问题， 多元兼容 ，才是国际化的真正意义。 这样在相互的合作中，往往才会有更多的理解和默契~ 具体 Strapi 的配置和 BFF 层这边就当作一个课后小作业，这边就不实现了，思路参考上面即可。同学们可以课后自己试一试。 小结这节课我们学习了文章页分页和国际化多语言的实现，使用了 Strapi 的 findOne和分页能力，我们可以用很低的成本的进行文章的配置和分页，后续的网站维护，运营同学也只需要使用对应的富文本编辑器，就可以随时随地配置更新需要的文案到官网上。还支持有预览的能力，完全可以做到所见即所得。 同时我们还对首页和文章页进行了移动端和 ipad 端的适配，让它可以在多端进行访问！ 对于国际化多语言的实现，我们用到了前几章反复使用的注入器方案，将对应的语言页面注入到每个页面，然后再结合 Strapi的配置，我们就可以实现对不同地区的语言进行灵活配置的能力，后续如果需要新增对某个语言的支持，也只需要在 Strapi上配置对应的文案就好了，不需要改动代码，配置能力拉满，太酷了~ 平时我们需求中可能经常会用到弹窗，官网经常会有一些自定义的动画，通过样式很难去覆盖动画的，所以下一节课，我们就来学习，如何来实现一个有自定义动画效果的弹窗组件。","link":"/2023/02/01/ssr/react/next/8.strapi,%E6%96%87%E7%AB%A0%E5%88%86%E9%A1%B5&%E5%9B%BD%E9%99%85%E5%8C%96/"},{"title":"双向绑定","text":"双向绑定如何实现 所谓数据的双向绑定可以体现为以下两部分： 数据流向 DOM 的绑定：数据的更新最终映射到对应的视图更新。 DOM 流向数据的绑定：操作 DOM 的变化引起数据的更新。 响应式原理，其实是数据流向 DOM 的过程。 在 Vuejs 中，经常通过 v-model 指令来实现数据的 “双向绑定”。 v-model 指令既可以作用在普通表单元素，也可以作用在一些组件上。 表单元素在使用 Vuejs 编写表单类的 UI 控件时，经常会使用 v-model 指令来为 &lt;input&gt;、&lt;select&gt;、&lt;textarea&gt; 进行数据的双向绑定。 使用 Vue 提供的官方模版转换工具来尝试一下在 &lt;input&gt;、&lt;select&gt;、&lt;textarea&gt; 输入类型的表单中使用 v-model 指令会被编译成什么样子： 模版： 123&lt;input v-model=&quot;value1&quot; /&gt;&lt;textarea v-model=&quot;value2&quot; /&gt;&lt;select v-model=&quot;value3&quot; /&gt; 编译结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import { vModelText as _vModelText, createElementVNode as _createElementVNode, withDirectives as _withDirectives, vModelSelect as _vModelSelect, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock,} from &quot;vue&quot;;const _hoisted_1 = [&quot;onUpdate:modelValue&quot;];const _hoisted_2 = [&quot;onUpdate:modelValue&quot;];const _hoisted_3 = [&quot;onUpdate:modelValue&quot;];export function render(_ctx, _cache, $props, $setup, $data, $options) { return ( _openBlock(), _createElementBlock( _Fragment, null, [ _withDirectives( _createElementVNode( &quot;input&quot;, { &quot;onUpdate:modelValue&quot;: ($event) =&gt; (_ctx.value1 = $event), }, null, 8 /* PROPS */, _hoisted_1 ), [[_vModelText, _ctx.value1]] ), _withDirectives( _createElementVNode( &quot;textarea&quot;, { &quot;onUpdate:modelValue&quot;: ($event) =&gt; (_ctx.value2 = $event), }, null, 8 /* PROPS */, _hoisted_2 ), [[_vModelText, _ctx.value2]] ), _withDirectives( _createElementVNode( &quot;select&quot;, { &quot;onUpdate:modelValue&quot;: ($event) =&gt; (_ctx.value3 = $event), }, null, 8 /* PROPS */, _hoisted_3 ), [[_vModelSelect, _ctx.value3]] ), ], 64 /* STABLE_FRAGMENT */ ) );} 通过 v-model 绑定的元素，在转成渲染函数的时候，最外层都被套上了一个 withDirectives 函数，这个函数传入了两个变量，一个通过 createElementVNode 创建的 vnode 节点，另一个是一个数组类型的参 directives， withDirectives 实现： 12345678910111213141516171819202122232425262728293031323334353637export function withDirectives(vnode, directives) { const internalInstance = currentRenderingInstance; if (internalInstance === null) { return vnode; } const instance = getExposeProxy(internalInstance) || internalInstance.proxy; // 获取指令集 const bindings = vnode.dirs || (vnode.dirs = []); // 遍历 directives for (let i = 0; i &lt; directives.length; i++) { let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i]; // 如果存在指令 if (dir) { // 指令是个函数，构造 mounted、updated 钩子 if (isFunction(dir)) { dir = { mounted: dir, updated: dir, }; } // 存在 deep 属性，遍历访问每个属性 if (dir.deep) { traverse(value); } // bindings 中添加构造好的指令元素 bindings.push({ dir, instance, value, oldValue: void 0, arg, modifiers, }); } } return vnode;} withDirectives 函数主要就是为 vnode 节点上添加 dirs 属性，对于示例中的 &lt;input&gt; 节点而言，生成的 dir 内容大致为（ select 节点类似）： 1{ dir: vModelText, value: _ctx.value1, ... } 其中 vModelText 是一个对象，内置了 v-model 指令相关的生命周期的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657export const vModelText = { // created 生命周期 created(el, { modifiers: { lazy, trim, number } }, vnode) { // 获取 props 上 onUpdate:modelValue 函数 el._assign = getModelAssigner(vnode); const castToNumber = number || (vnode.props &amp;&amp; vnode.props.type === &quot;number&quot;); // 注册 input/change 事件 addEventListener(el, lazy ? &quot;change&quot; : &quot;input&quot;, (e) =&gt; { // ... let domValue = el.value; // .trim 修饰符 if (trim) { domValue = domValue.trim(); } if (castToNumber) { domValue = looseToNumber(domValue); } // 执行 onUpdate:modelValue 函数 el._assign(domValue); }); if (trim) { addEventListener(el, &quot;change&quot;, () =&gt; { el.value = el.value.trim(); }); } // ... }, mounted(el, { value }) { // 赋值 el.value = value == null ? &quot;&quot; : value; }, beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) { // 更新 el._assign el._assign = getModelAssigner(vnode); if (el.composing) return; if (document.activeElement === el &amp;&amp; el.type !== &quot;range&quot;) { if (lazy) { return; } if (trim &amp;&amp; el.value.trim() === value) { return; } if ( (number || el.type === &quot;number&quot;) &amp;&amp; looseToNumber(el.value) === value ) { return; } } // 更新值 const newValue = value == null ? &quot;&quot; : value; if (el.value !== newValue) { el.value = newValue; } },}; vModelText 内置了 created、mounted、beforeUpdate 钩子函数。 在 created 的时候，会从 pops 上获取 onUpdate:modelValue 函数，这个函数也就是在遇到 v-model 指令后，Vue 的编译器自动转换生成的。然后再监听对应 DOM 上的 change 或者 input 事件，事件触发时再回调执行 onUpdate:modelValue 函数。 在 mounted 的时候，会将当前的值 value 赋值给 el.value。 指令生命周期的触发v-model 注册的指令节点，会生成一个带有 dirs 的属性，属性中会包含类似于 vModelText 这样的对象，这个对象内部包含了一些生命周期函数，指令相关的代码实现： 1234567891011121314151617181920212223242526272829303132const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; { // ... const { type, props, shapeFlag, transition, dirs } = vnode if (dirs) { // 执行 created 钩子函数 invokeDirectiveHook(vnode, null, parentComponent, 'created') } // ... if (props) { // 处理 props，比如 class、style、event 等属性 } if (dirs) { // 执行 beforeMount 钩子函数 invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount') } // 挂载 dom hostInsert(el, container, anchor) if ( (vnodeHook = props &amp;&amp; props.onVnodeMounted) || needCallTransitionHooks || dirs ) { queuePostRenderEffect(() =&gt; { vnodeHook &amp;&amp; invokeVNodeHook(vnodeHook, parentComponent, vnode) needCallTransitionHooks &amp;&amp; transition!.enter(el) // 执行 mounted 钩子函数 dirs &amp;&amp; invokeDirectiveHook(vnode, null, parentComponent, 'mounted') }, parentSuspense) }} 指令相关的钩子函数在进行 vnode 初始化挂载的时候，会在挂载的各个阶段被分别调用，从而完成生命周期函数的执行过程。 组件v-model 在组件中一些常规的使用方式： 123&lt;Component v-model=&quot;value1&quot; /&gt;&lt;Component v-model:title=&quot;bookTitle&quot; /&gt;&lt;Component v-model:first-name=&quot;first&quot; v-model:last-name=&quot;last&quot; /&gt; 在组件上，v-model 不仅仅可以使用 modelValue 作为 prop，以 update:modelValue 作为对应的事件，还支持了给 v-model 一个自定义参数来更改这些名字。因为有了自定义参数的功能，所以也就支持了一个组件多个 v-model 绑定的功能。 通过 Vue 3 Template Explorer 将上述模版转出来的渲染函数的表达形式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import { resolveComponent as _resolveComponent, createVNode as _createVNode, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock,} from &quot;vue&quot;;export function render(_ctx, _cache, $props, $setup, $data, $options) { const _component_Component = _resolveComponent(&quot;Component&quot;); return ( _openBlock(), _createElementBlock( _Fragment, null, [ _createVNode( _component_Component, { modelValue: _ctx.value1, &quot;onUpdate:modelValue&quot;: ($event) =&gt; (_ctx.value1 = $event), }, null, 8 /* PROPS */, [&quot;modelValue&quot;, &quot;onUpdate:modelValue&quot;] ), _createVNode( _component_Component, { title: _ctx.bookTitle, &quot;onUpdate:title&quot;: ($event) =&gt; (_ctx.bookTitle = $event), }, null, 8 /* PROPS */, [&quot;title&quot;, &quot;onUpdate:title&quot;] ), _createVNode( _component_Component, { &quot;first-name&quot;: _ctx.first, &quot;onUpdate:firstName&quot;: ($event) =&gt; (_ctx.first = $event), &quot;last-name&quot;: _ctx.last, &quot;onUpdate:lastName&quot;: ($event) =&gt; (_ctx.last = $event), }, null, 8 /* PROPS */, [&quot;first-name&quot;, &quot;onUpdate:firstName&quot;, &quot;last-name&quot;, &quot;onUpdate:lastName&quot;] ), ], 64 /* STABLE_FRAGMENT */ ) );} 编译器在处理组件带有 v-model 指令的时候，会将其根据相关参数进行解析，最后组成一个 props 传入组件中。拿一个 v-model:title = 'bookTitle' 举例，生成的 props 大致是这样的： 1234{ title: value, &quot;onUpdate:title&quot;: $event =&gt; _ctx.bookTitle = $event} 所以这也解释了为什么组件内部需要定义一个 props 用来承接 title 的值；定义一个 emit，在 title 值变化的时候，用来触发 onUpdate:title，并传入更新后的值。 12345678910111213&lt;!-- Component.vue --&gt;&lt;script setup&gt; defineProps([&quot;title&quot;]); defineEmits([&quot;update:title&quot;]);&lt;/script&gt;&lt;template&gt; &lt;input type=&quot;text&quot; :value=&quot;title&quot; @input=&quot;$emit('update:title', $event.target.value)&quot; /&gt;&lt;/template&gt; $emit 是怎样触发 onUpdate:title 函数的执行的。 $emit 函数的实现： 1234567891011121314151617181920212223export function emit(instance, event, ...rawArgs) { if (instance.isUnmounted) return; const props = instance.vnode.props || EMPTY_OBJ; let args = rawArgs; // 定义事件名称 let handlerName; // update:xxx =&gt; onUpdate:xxx let handler = props[(handlerName = toHandlerKey(event))] || props[(handlerName = toHandlerKey(camelize(event)))]; // 找到了 handler 触发调用 if (handler) { callWithAsyncErrorHandling( handler, instance, ErrorCodes.COMPONENT_EVENT_HANDLER, args ); } // ...} 其中第一个参数是当前组件实例，$emit 自动绑定了当前组件，event 为事件名称，rawArgs 就是传入的一些参数。就是将传入的 event 名称转成 onUpdate:xxx 的写法，然后在 props 上找对应的函数，也就是传入的那个事件函数。找到了后就通过 callWithAsyncErrorHandling 方法进行调用，完成事件的执行。 总结v-model 不管是在表单元素还是在组件元素上都会被编译器转成一个 props 对象，在表单元素上是这样的： 123{ &quot;onUpdate:modelValue&quot;: $event =&gt; _ctx.bookTitle = $event} 而在组件时则会编译成： 1234{ title: value, &quot;onUpdate:title&quot;: $event =&gt; _ctx.bookTitle = $event} 那么，所谓的双向数据绑定的 DOM 操作触发数据的更新就可以理解为： 在表单元素上，事件名 modelValue 是默认的，通过 vModelText 函数在内部实现了一个监听 DOM 变更的事件 change/input 来实现对数据值的更新操作。 在组件元素上，则是通过组件内部自定义值接受和事件派发机制完成对数据的更新操作。","link":"/2023/08/05/vue/%E5%85%B6%E4%BB%96/%E7%89%B9%E6%AE%8A%E5%85%83%E7%B4%A0/%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"},{"title":"AST","text":"上一节课我们学习了怎么实现复杂的帧动画，通过对比我们使用 Animation 对动画进行了逐帧实现，并且我们还了解了怎么去主动触发我们实现的帧动画，使得我们页面的动画效果具备更高的灵活性，到这里其实我们官网大部分的功能就已经实现了。 但是之前我们的页面只绘制了 pc 端的样式，通常官网需要支持 pc、 ipad、 移动端等多种设备的访问，所以这一节课我们就来学习怎么对多媒体设备的样式进行兼容适配。 Px 转 Rem在进行适配之前，我们需要先了解一下 rem 和 px，有过 c 端开发经验的同学对这两个单位应该都不陌生。px是相对屏幕分辨率的像素单位，通常对于纯 b 端业务，或是只需要适配少部分手机设备，且分辨率对页面影响不大的，我们通常使用 px进行样式的开发。至于 rem，是相对 HTML 根元素字体大小而确定的相对单位，对于多媒体的适配，我们常用 rem 进行开发。 所以我们需要对之前的样式进行一下替换，将 px 单位替换为 rem，这个过程我们通过 cssrem 的 vscode 插件来协助完成，可以参照下图安装，默认的的根字体为 16px，需要更新的同学可以右键插件，选择扩展配置调整即可。 安装完成后，我们移步到样式问题，输入 16px，可以看到会有对应 rem 提示，我们将所有的 px 单位替换即可。 CSS 多媒体设备适配CSS 的多媒体设备适配大家应该不陌生，通过编写不同的媒体设备样式来进行适配就可，这种常用于 dom 结构变化不大，可以复用 dom 的基础上，调整样式就能适配的场景。为加强复用，我们可以定义几个常用的设备场景。 12345678910111213141516171819202122232425262728// ./pages/media.scss// 极小分辨率移动端设备@mixin media-mini-mobile { @media screen and (max-width: 25.875rem) { @content; }}// 介于极小分辨率和正常分辨率之间的移动端设备@mixin media-between-mini-and-normal-mobile { @media screen and (min-width: 25.876rem) and (max-width: 47.9375rem) { @content; }}// 移动端设备@mixin media-mobile { @media screen and (max-width: 47.9375rem) { @content; }}// ipad@mixin media-ipad { @media screen and (min-width: 47.9375rem) and (max-width: 75rem) { @content; }} 在大部分场景，我们可以直接引入这些定义进行适配。 123@include media-ipad { // ...} 大家也可以采用自定义分辨率的方式适配，我们以 footer 组件举例，改造一下它之前的样式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152// ./components/footer/styles.module.scss@import &quot;../../pages/media.scss&quot;;.footer { font-size: 16px; padding: 4.375rem 9.0625rem; background-color: var(--footer-background-color); .topArea { display: flex; justify-content: space-between; flex-wrap: wrap; .footerTitle { font-weight: 500; font-size: 2.25rem; line-height: 2.25rem; color: var(--primary-color); margin: 0; } .linkListArea { display: flex; .linkArea { display: flex; flex-direction: column; margin-left: 10rem; .title { font-weight: 500; font-size: 0.875rem; line-height: 1.25rem; color: var(--primary-color); margin-bottom: 2.5rem; word-break: keep-all; } .links { display: flex; flex-direction: column; font-weight: 400; font-size: 0.875rem; line-height: 1.25rem; word-break: keep-all; .link { color: var(--primary-color); cursor: pointer; margin-bottom: 1.5rem; } .disabled { color: var(--secondary-color); cursor: not-allowed; margin-bottom: 1.5rem; } } } .linkArea:first-of-type { margin-left: 0; } } } .bottomArea { display: flex; justify-content: space-between; .codeArea { display: flex; flex-direction: column; .text { color: var(--secondary-color); } } .numArea { color: var(--secondary-color); display: flex; flex-direction: column; align-items: flex-end; font-weight: 400; font-size: 0.875rem; line-height: 1.25rem; span { margin-bottom: 0.75rem; } .publicLogo { display: flex; .logo { margin-right: 0.25rem; } } } }}@media screen and (min-width: 48.6875rem) and (max-width: 54.125rem) { .footer { .topArea { .footerTitle { margin-bottom: 1.25rem; } } }}@media screen and (max-width: 48.6875rem) { .footer { .topArea { display: flex; flex-direction: column; align-items: center; .footerTitle { margin-bottom: 2.5rem; } .linkListArea { display: flex; flex-direction: column; text-align: center; .linkArea { margin-left: 0; } } } .bottomArea { display: flex; flex-direction: column; align-items: center; .codeArea { display: flex; flex-direction: column; align-items: center; .text { text-align: center; margin: 20px 0; } } .numArea { align-items: center; text-align: center; } } }}// @include media-ipad {// } 我们分别绘制了两种分辨率下的场景，这些会作为扩展样式引入，当页面处理到解析 CSS 树的时候，会一并扩展到渲染树中渲染，我们来看一下效果。当然我们也可以通过 network 选中设备的方式查看，那个是更加真实的模拟方式，包括请求头在内的都会同步为对应设备，类似这种拖动的查看方式，是为了排查是否有边界的分辨率遗漏，可以覆盖全部的场景。 对于剩下的区域，同学们可以课下自己模仿练习试试，只需要拖动控制台没有显示异常的区域大致就算完成了。 客户端 Context 注入设备信息对于页面的样式适配，CSS media 已经可以覆盖绝大部分的场景，但是小部分的场景仍然无法覆盖，比如在一些媒体设备下，不再采用原本的dom结构，换用别的交互形式，就没办法直接用样式覆盖了，而是需要通过在客户端判断当前的设备，选用不同的交互，比如抖音前端技术团队官网的菜单，在低分辨率场景就会采用右侧弹出的方式来显示。 那么针对这种场景，我们应该怎么在客户端判断当前的设备呢？ 在10 | 样式注入：如何实现一个主题化功能？ 我们有介绍 useContext 的用法，为了避免逻辑的分散，所以我们定义了主题的 context 在全局进行注入，这里我们同样可以定义一个 context，用于判断当前的设备，然后注入给每个页面。判断设备的方式其实也很简单，通过页宽来判断就可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// ./stores/userAgent.tsximport React, { useState, useEffect, createContext } from &quot;react&quot;;import { Environment } from &quot;@/constants/enum&quot;;// export enum Environment {// pc = &quot;pc&quot;,// ipad = &quot;ipad&quot;,// mobile = &quot;mobile&quot;,// none = &quot;none&quot;,// }interface IUserAgentContextProps { userAgent: Environment;}interface IProps { children: JSX.Element;}export const UserAgentContext = createContext&lt;IUserAgentContextProps&gt;( {} as IUserAgentContextProps);export const UserAgentProvider = ({ children }: IProps): JSX.Element =&gt; { const [userAgent, setUserAgent] = useState&lt;Environment&gt;(Environment.none); // 服务器渲染初始化渲染未必是预期效果，none缓冲切换视觉) // 监听本地缓存来同步不同页面间的主题（当前页面无法监听到，直接在顶部栏进行了类的切换) useEffect(() =&gt; { const checkUserAgent = (): void =&gt; { const width = document.body.offsetWidth; // 用宽度去判断，是为了适配不改机型，仅拉扯屏幕宽度的情况 if (width &lt; 768) { // 手机端 setUserAgent(Environment.mobile); } else if (width &gt;= 768 &amp;&amp; width &lt; 1200) { // ipad端 setUserAgent(Environment.ipad); } else if (width &gt;= 1200) { // pc端 setUserAgent(Environment.pc); } else { setUserAgent(Environment.none); // 增加none类型来缓冲默认类型样式切换时的视觉突变 } }; checkUserAgent(); window.addEventListener(&quot;resize&quot;, checkUserAgent); // 监听屏幕宽度变化，及时适配当前页面样式 return (): void =&gt; { window.removeEventListener(&quot;resize&quot;, checkUserAgent); }; }, [typeof document !== &quot;undefined&quot; &amp;&amp; document.body.offsetWidth]); return ( &lt;UserAgentContext.Provider value={{ userAgent }}&gt; {children} &lt;/UserAgentContext.Provider&gt; );}; 这里有两个需要讲解的点： Environment.none：设置一个空态，是为了避免未取到页宽时，错误赋值非当前页面的设备分辨率的值，导致可能会出现分辨率样式的短暂切换造成的视觉冲突。 typeof document !== &quot;undefined&quot; &amp;&amp; document.body.offsetWidth： 在05 | 架构实现（三）：如何支持 SSR 对数据的请求？ 中实现注水脱水的时候我们也有遇到过类似的问题，因为除钩子方法里（比如 useEffect）以外的逻辑，都是会在服务器端执行的，在服务器端是没有 BOM 的注入的，所以我们需要对 BOM 的调用进行判空。 然后我们把这个 context 同样注入到入口文件。 12345678910// ./pages/_app.tsx// ...&lt;ThemeContextProvider&gt; &lt;UserAgentProvider&gt; &lt;Layout navbarData={navbarData} footerData={footerData}&gt; &lt;Component {...pageProps} /&gt; &lt;/Layout&gt; &lt;/UserAgentProvider&gt;&lt;/ThemeContextProvider&gt;// ... 我们在 navbar 组件简单调用试试。 123456789101112131415161718192021222324252627282930313233343536373839404142// ./components/navbar/index.tsximport { FC, useContext } from &quot;react&quot;;import styles from &quot;./styles.module.scss&quot;;import { ThemeContext } from &quot;@/stores/theme&quot;;import { UserAgentContext } from &quot;@/stores/userAgent&quot;;import { Themes, Environment } from &quot;@/constants/enum&quot;;export interface INavBarProps {}export const NavBar: FC&lt;INavBarProps&gt; = ({}) =&gt; { const { setTheme } = useContext(ThemeContext); const { userAgent } = useContext(UserAgentContext); return ( &lt;div className={styles.navBar}&gt; &lt;a href=&quot;http://localhost:3000/&quot;&gt; &lt;div className={styles.logoIcon}&gt;&lt;/div&gt; &lt;/a&gt; &lt;div className={styles.themeArea}&gt; {userAgent === Environment.pc &amp;&amp; ( &lt;span className={styles.text}&gt;当前是pc端样式&lt;/span&gt; )} {userAgent === Environment.ipad &amp;&amp; ( &lt;span className={styles.text}&gt;当前是Ipad端样式&lt;/span&gt; )} {userAgent === Environment.mobile &amp;&amp; ( &lt;span className={styles.text}&gt;当前是移动端样式&lt;/span&gt; )} &lt;div className={styles.themeIcon} onClick={(): void =&gt; { if (localStorage.getItem(&quot;theme&quot;) === Themes.light) { setTheme(Themes.dark); } else { setTheme(Themes.light); } }} &gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; );}; 我们来看看效果。 因为我们还监听了页宽变化的事件，所以这个是可以随着页宽变化实时更新的，上面的录屏也有这部分效果，大家可以翻至上页查看。 在服务器端判定设备信息客户端判定设备其实存在一个小问题是，因为 HTML文本的生成是在服务器端生成的，客户端判断设备信息会存在一个初始态到实际设备数据短暂切换的问题，而且如果不同设备展示的内容不同，还有可能会影响到实际的SEO ，那么有没有办法可以在服务器端判断当前的访问设备呢？ 也是有的，虽然服务器端拿不到当前访问的客户端页宽等数据，但是客户端在服务器端请求的时候，请求头中有一个 user-agent请求头，可以用来判断当前的设备是 pc 端还是移动端，通过这个来判断，我们就可以在 HTML 文本返回前，就拿到实际的设备 DOM。 我们首先来定义一下判断设备的通用方法。 1234567// ./utils/index.tsxexport const getIsMobile = (context: AppContext) =&gt; { const { headers = {} } = context.ctx.req || {}; return /mobile|android|iphone|ipad|phone/i.test( (headers[&quot;user-agent&quot;] || &quot;&quot;).toLowerCase() );}; 然后我们在入口文件的注入函数里，额外注入一个设备信息，如果是移动端，我们就给标题加一个“（移动端）”， 如果是 pc 端，我们就加一个 “（pc 端）”。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// ./pages/_app.tsximport type { AppProps, AppContext } from &quot;next/app&quot;;import App from &quot;next/app&quot;;import { Layout, ILayoutProps } from &quot;@/components/layout&quot;;import Head from &quot;next/head&quot;;import axios from &quot;axios&quot;;import { getIsMobile, LOCALDOMAIN } from &quot;@/utils&quot;;import { ThemeContextProvider } from &quot;@/stores/theme&quot;;import { UserAgentProvider } from &quot;@/stores/userAgent&quot;;import &quot;./global.scss&quot;;const MyApp = (data: AppProps &amp; ILayoutProps &amp; { isMobile: boolean }) =&gt; { const { Component, pageProps, navbarData, footerData, isMobile } = data; return ( &lt;div&gt; &lt;Head&gt; &lt;title&gt;{`A Demo for 《深入浅出SSR官网开发指南》(${ isMobile ? &quot;移动端&quot; : &quot;pc端&quot; })`}&lt;/title&gt; &lt;meta name=&quot;description&quot; content={`A Demo for 《深入浅出SSR官网开发指南》(${ isMobile ? &quot;移动端&quot; : &quot;pc端&quot; })`} /&gt; &lt;link rel=&quot;icon&quot; href=&quot;/favicon.ico&quot; /&gt; &lt;/Head&gt; &lt;ThemeContextProvider&gt; &lt;UserAgentProvider&gt; &lt;Layout navbarData={navbarData} footerData={footerData}&gt; &lt;Component {...pageProps} /&gt; &lt;/Layout&gt; &lt;/UserAgentProvider&gt; &lt;/ThemeContextProvider&gt; &lt;/div&gt; );};MyApp.getInitialProps = async (context: AppContext) =&gt; { const pageProps = await App.getInitialProps(context); const { data = {} } = await axios.get(`${LOCALDOMAIN}/api/layout`); return { ...pageProps, ...data, isMobile: getIsMobile(context), };};export default MyApp; 然后我们来看看效果，可以看到返回的 HTML 文本里已经包含设备信息的判断了。 一个小彩蛋同学们好 ~ 小册的名称与编辑同学确定，最终改为《SSR实战：官网开发指南》，中间名称有多次调整，之前写的课程文案中部分首页截图文案可能为《深入浅出 SSR 官网开发指南》或是《官网开发：SSR应用实战指南》，考虑到需要还原当时场景重新截图比较费时=。=，这边就不统一替换了。从下一节课开始，相关的首页截图会统一调整为《SSR实战：官网开发指南》。感谢同学们的理解~ 12345678910111213141516171819202122232425262728293031323334353637383940// ./pages/index.tsx// ...Home.getInitialProps = (context) =&gt; { return { title: &quot;Hello SSR!&quot;, description: &quot;A Demo for 《SSR 实战：官网开发指南》&quot;, // rename 小册，谢谢大家~ list: [ { label: &quot;文章1&quot;, info: &quot;A test for article1&quot;, link: &quot;http://localhost:3000/article/1&quot;, }, { label: &quot;文章2&quot;, info: &quot;A test for article2&quot;, link: &quot;http://localhost:3000/article/2&quot;, }, { label: &quot;文章3&quot;, info: &quot;A test for article3&quot;, link: &quot;http://localhost:3000/article/3&quot;, }, { label: &quot;文章4&quot;, info: &quot;A test for article4&quot;, link: &quot;http://localhost:3000/article/4&quot;, }, { label: &quot;文章5&quot;, info: &quot;A test for article5&quot;, link: &quot;http://localhost:3000/article/5&quot;, }, { label: &quot;文章6&quot;, info: &quot;A test for article6&quot;, link: &quot;http://localhost:3000/article/6&quot;, }, ], };}; 小结这节课我们学习了怎么对 SSR 页面进行多媒体适配，对于大部分场景，我们都通过 css media 的方式来进行样式的适配，我们就footer 组件举例，为它覆盖了 ipad， mobile等场景的样式，对于剩下的组件和页面，我们作为课后的一个小作业留给同学试验，大家可以通过调整它们的字体大小，间宽，让不同设备下的访问更好看一些。 同时因为 SSR 的特点，常见的 css media 适配的方式并不能满足我们的所有需求。针对可以复用dom，只需要调整样式的场景，我们可以采用 css media 的方式；针对 dom需要根据设备定制的场景，我们则需要通过客户端注入的方式，通过脚本逻辑来进行结构的适配；如果是不同设备下展示的内容不同，或者区域有较大的变化，出于交互和SEO 的考虑，我们则需要通过客户端向服务器端发送的请求头来判断当前设备的类型，来确保服务器端返回的 HTML 文本是正确设备下所需要的。 在下一节课，我们将重识我们的老朋友 Strapi，在08 | 数据可视化：基于 Strapi 实现后台数据的灵活配置 中我们介绍了它的一些基础能力，但是实际它的能力还远不止此，下一节课我们将学习 Strapi 的一些进阶知识，来实现我们的文章页分页和国际化功能。","link":"/2023/02/01/ssr/react/next/7.%E5%A4%9A%E5%AA%92%E4%BD%93%E9%80%82%E9%85%8D%EF%BC%8C%E5%AE%98%E7%BD%91%E7%9A%84%E8%AE%BE%E5%A4%87%E6%A0%B7%E5%BC%8F%E5%85%BC%E5%AE%B9/"},{"title":"AST","text":"到现在我们已经学习了包括主题化、帧动画、多媒体适配、Strapi 进阶在内的知识，通过结合实际的业务需求场景，相信大家已经可以应对官网开发的大部分常见需求了。 通常在官网等项目开发中，都会使用组件库等来协助我们进行页面的静态开发，对于不符合业务场景的组件，我们可以使用样式覆盖的方式来为业务场景适配，比如前几节课我们使用的分页组件。但是这并不代表我们不再需要自己开发组件，针对需要自定义动画的组件，很难通过样式覆盖的方式去定义，这时候就需要我们自行开发。 弹窗组件就是这类组件中最典型的一种，因为不同的业务场景可能需要不同的渐入渐出动画，平常组件库的弹窗组件并不容易在原有基础上覆盖自定义动画。所以作为需求进阶篇的最后一节课，我们将来学习如何来开发一个自定义动画弹窗组件。 静态样式对于弹窗组件，很多同学的第一印象可能是它很容易，但是其中有不少的细节，我们这节课会更详细地讲解每行的代码和样式，同学们可以根据步骤和思路自己手写一下，然后对比和实际的方案有哪些不同。 首先我们先来写一下弹窗组件的静态样式，与平常组件不同，弹窗组件至少需要暴露一个 open 方法给外部进行调用，所以我们需要用到 forwardRef，它可以将 ref 中的方法暴露给外部进行相关的调用，例如 Semi 中我们常常使用的 form 组件就是通过这个来实现的。 我们创建一个 popup 组件，然后写一下它的静态样式，其中 IPopupRef 是弹窗暴露的 ref 类型，而 IProps是组件本身的类型，useImperativeHandle 是组件 ref 暴露给外部调用的方法定义，暴露回去的回调方法类型需要和 ref类型相同。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// ./components/popup/index.tsximport React, { forwardRef, useState, useImperativeHandle } from &quot;react&quot;;import styles from &quot;./styles.module.scss&quot;;import cName from &quot;classnames&quot;;export interface IPopupRef { open: () =&gt; void;}interface IProps { children: JSX.Element;}export const Popup = forwardRef&lt;IPopupRef, IProps&gt;(({ children }, ref) =&gt; { const [visible, setVisible] = useState(false); useImperativeHandle(ref, () =&gt; ({ open: (): void =&gt; { setVisible(true); }, })); const renderDom = visible ? ( &lt;div className={cName({ [styles.popup]: true, })} &gt; &lt;div className={styles.mask} /&gt; &lt;div className={styles.popupContent}&gt; &lt;div className={styles.closeBtn} onClick={(): void =&gt; { setVisible(false); }} /&gt; {children} &lt;/div&gt; &lt;/div&gt; ) : ( &lt;&gt;&lt;/&gt; ); return renderDom;}); 然后我们为它写一下静态的样式，相关的全局主题化变量我们也定义一下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// ./components/popup/styles.module.scss@import &quot;../../pages/media.scss&quot;;.popup { width: 100%; height: 100vh; display: flex; justify-content: center; align-items: center; position: fixed; top: 0; left: 0; z-index: 10000; .mask { width: inherit; height: inherit; position: fixed; background-color: #000; opacity: 0.5; top: 0; left: 0; z-index: 10; } .popupContent { position: relative; border-radius: 0.25rem; display: flex; flex-direction: column; align-items: center; justify-content: center; background-color: var(--popup-content-background-color); z-index: 20; min-width: 25rem; min-height: 25rem; .closeBtn { width: 2.125rem; height: 2.125rem; background-color: inherit; background-image: var(--popup-close-icon); background-position: center; background-size: 1rem 1rem; background-repeat: no-repeat; position: absolute; top: 1.1875rem; right: 1.1875rem; cursor: pointer; z-index: 100; } .closeBtn:hover { background-color: var(--popup-close-hover-background-color); } }}@include media-mobile { .popup { .dialogContent { .closeBtn { width: 0.6875rem; height: 0.6875rem; top: 1.3125rem; right: 0.875rem; } } }}@include media-ipad { .dialog { .dialogContent { .titleArea { padding: 1.5rem 1.5625rem; } } }} 123456789101112// ./pages/global.scsshtml[data-theme=&quot;dark&quot;] { --popup-close-icon: url(&quot;../public/close.png&quot;); --popup-close-hover-background-color: #353535; --popup-content-background-color: #1f1f1f;}html[data-theme=&quot;light&quot;] { --popup-close-icon: url(&quot;../public/close_light.png&quot;); --popup-close-hover-background-color: #f5f5f5; --popup-content-background-color: #f4f5f5;} 到这里基础样式就定义好了，我们可以在 navbar 加一个入口试试看。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// ./components/navbar/index.tsximport { FC, useContext, useRef } from &quot;react&quot;;import styles from &quot;./styles.module.scss&quot;;import { ThemeContext } from &quot;@/stores/theme&quot;;import { UserAgentContext } from &quot;@/stores/userAgent&quot;;import { Themes, Environment } from &quot;@/constants/enum&quot;;import { Popup, IPopupRef } from &quot;../popup&quot;;export interface INavBarProps {}export const NavBar: FC&lt;INavBarProps&gt; = ({}) =&gt; { const { setTheme } = useContext(ThemeContext); const { userAgent } = useContext(UserAgentContext); const popupRef = useRef&lt;IPopupRef&gt;(null); return ( &lt;div className={styles.navBar}&gt; &lt;a href=&quot;http://localhost:3000/&quot;&gt; &lt;div className={styles.logoIcon}&gt;&lt;/div&gt; &lt;/a&gt; &lt;div className={styles.themeArea}&gt; &lt;div className={styles.popupText} onClick={(): void =&gt; { popupRef.current?.open(); }} &gt; 弹窗示范 &lt;/div&gt; {userAgent === Environment.pc &amp;&amp; ( &lt;span className={styles.text}&gt;当前是pc端样式&lt;/span&gt; )} {userAgent === Environment.ipad &amp;&amp; ( &lt;span className={styles.text}&gt;当前是Ipad端样式&lt;/span&gt; )} {userAgent === Environment.mobile &amp;&amp; ( &lt;span className={styles.text}&gt;当前是移动端样式&lt;/span&gt; )} &lt;div className={styles.themeIcon} onClick={(): void =&gt; { if (localStorage.getItem(&quot;theme&quot;) === Themes.light) { setTheme(Themes.dark); } else { setTheme(Themes.light); } }} &gt;&lt;/div&gt; &lt;/div&gt; &lt;Popup ref={popupRef}&gt; &lt;div&gt;这是一个弹窗&lt;/div&gt; &lt;/Popup&gt; &lt;/div&gt; );}; 我们来看看效果。 遮罩层的滚动穿透这时候存在一个问题，我们发现有遮罩层的时候，最外层仍然是可以滚动的，这个我们往往称作为滚动穿透的现象，其实也很好理解，最外层的区域（body) 仍然是可以产生滚动的，我们仅仅是给了 100vh 的遮罩层，所以并不能阻止滚动的产生。 解决方案也很简单，我们只需要在遮罩层的时候，在 body 手动加上一个类来限制它的高度即可 。 12345// ./components/popup/index.tsx// ...useEffect(() =&gt; { document.body.className = visible ? &quot;forbidScroll&quot; : &quot;&quot;; }, [visible]); 12345// ./pages/global.scss.forbidScroll { height: 100vh; overflow: hidden;} 现在可以发现已经不会再滚动了。 指定渲染位置同学们可以打开控制台的 Elements，通过选取元素选中我们的弹窗，可以看到渲染的位置是在对应组件调用的 dom 下的。 这样其实会存在一个问题，因为被嵌套在别的 dom 下， 包括样式、事件在内的很多情况，弹窗组件可能都会受到影响，通常作为一个通用的组件，我们是不希望弹窗的展现因为外界的情况而有所变化的，所以不应该把它渲染在父级区域下。 在 React 16，有提供一个 api， ReactDom.createPortal， 它提供了将子节点渲染到存在于父组件以外的 DOM节点的能力，通过这个 api， 我们可以将我们的弹窗组件渲染到 body 下，这样就可以有效解决这个问题，因为需要使用到 BOM的问题，所以需要进行判空，前面的课程我们也反复提及到了 SSR 的这个问题，大家注意一下。 12345// ./components/popup/index.tsx// ...return typeof document !== &quot;undefined&quot; ? ReactDom.createPortal(renderDom, document.body) : renderDom; 现在我们再来看一下控制台，可以看到已经渲染到最外层了。 动画的实现现在大部分的功能我们都有了，到最关键的地方了，我们应该怎么为弹窗实现动画呢？渐入渐出的动画关键在于类的切换，在切换过程中，我们需要对下一个状态的类进行异步切换，因为react state是对最终结果进行切换的，这样没办法起到类型变化的效果。现在我们来实现这个效果，动画的效果我们就实现一个普通的渐入渐出就可以了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// ./components/popup/index.tsximport React, { forwardRef, useState, useEffect, useImperativeHandle, useContext, useMemo,} from &quot;react&quot;;import styles from &quot;./styles.module.scss&quot;;import ReactDom from &quot;react-dom&quot;;import { UserAgentContext } from &quot;@/stores/userAgent&quot;;import { Environment } from &quot;@/constants/enum&quot;;import cName from &quot;classnames&quot;;export interface IPopupRef { open: () =&gt; void;}interface IProps { children: JSX.Element;}export const Popup = forwardRef&lt;IPopupRef, IProps&gt;(({ children }, ref) =&gt; { const [visible, setVisible] = useState(false); const [enter, setEnter] = useState(false); const [leave, setLeave] = useState(false); useEffect(() =&gt; { document.body.className = visible ? &quot;forbidScroll&quot; : &quot;&quot;; let timeout; if (visible) { setEnter(true); timeout = setTimeout((): void =&gt; { setEnter(false); }, 300); } else { setLeave(true); timeout = setTimeout((): void =&gt; { setLeave(false); }, 300); } return (): void =&gt; { timeout = null; }; }, [visible]); useImperativeHandle(ref, () =&gt; ({ open: (): void =&gt; { setEnter(true); setVisible(true); setTimeout((): void =&gt; { setEnter(false); }, 300); }, })); const renderDom = visible ? ( &lt;div className={cName({ [styles.popup]: true, [styles.enter]: enter, [styles.leave]: leave, })} &gt; &lt;div className={styles.mask} /&gt; &lt;div className={styles.popupContent}&gt; &lt;div className={styles.closeBtn} onClick={(): void =&gt; { setLeave(true); setTimeout((): void =&gt; { setLeave(false); }, 300); setVisible(false); }} /&gt; {children} &lt;/div&gt; &lt;/div&gt; ) : ( &lt;&gt;&lt;/&gt; ); return typeof document !== &quot;undefined&quot; ? ReactDom.createPortal(renderDom, document.body) : renderDom;}); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148// ./components/popup/styles.module.scss@import &quot;../../pages/media.scss&quot;;.popup { width: 100%; height: 100vh; display: flex; justify-content: center; align-items: center; position: fixed; top: 0; left: 0; z-index: 10000; .mask { width: inherit; height: inherit; position: fixed; background-color: #000; opacity: 0.5; top: 0; left: 0; z-index: 10; } .popupContent { position: relative; border-radius: 0.25rem; display: flex; flex-direction: column; align-items: center; justify-content: center; background-color: var(--popup-content-background-color); z-index: 20; min-width: 25rem; min-height: 25rem; .closeBtn { width: 2.125rem; height: 2.125rem; background-color: inherit; background-image: var(--popup-close-icon); background-position: center; background-size: 1rem 1rem; background-repeat: no-repeat; position: absolute; top: 1.1875rem; right: 1.1875rem; cursor: pointer; z-index: 100; } .closeBtn:hover { background-color: var(--popup-close-hover-background-color); } }}.enter { .mask { animation: maskFadeIn 0.2s; } .popupContent { animation: fadeIn 0.2s; }}.leave { .mask { animation: maskFadeOut 0.2s; opacity: 0; } .popupContent { animation: fadeOut 0.2s; transform: scale(0); }}@keyframes fadeIn { 0% { transform: scale(0); opacity: 0; } 100% { transform: scale(1); opacity: 1; }}@keyframes fadeOut { 0% { transform: scale(1); opacity: 1; } 100% { transform: scale(0); opacity: 0; }}@keyframes maskFadeIn { 0% { opacity: 0; } 100% { opacity: 0.5; }}@keyframes maskFadeOut { 0% { opacity: 0.5; } 100% { opacity: 0; }}@include media-mobile { .popup { .popupContent { min-width: 18.75rem; min-height: 18.75rem; .closeBtn { width: 0.6875rem; height: 0.6875rem; top: 1.3125rem; right: 0.875rem; } } }}@include media-ipad { .popup { .popupContent { .titleArea { padding: 1.5rem 1.5625rem; } } }} 我们来看看最终效果，可以看到已经可以了。 PC 端遮罩层滚动栏丢失问题的解决现在功能我们都已经实现了，但是还存在一个小问题，当我们弹窗的时候，滚动栏会消失，这就导致有个屏幕闪烁的效果，这个问题我们应该怎么解决呢？我们来参考一下京东 O2Lab 团队官网的方案。 可以看到，京东用了一个比较 hack 的方法，在弹窗的时候给右边腾出了一块区域来代替滚动栏，从而减少这部分视觉差，我们也来实现一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// ./components/popup/index.tsximport React, { forwardRef, useState, useEffect, useImperativeHandle, useContext, useMemo,} from &quot;react&quot;;import styles from &quot;./styles.module.scss&quot;;import ReactDom from &quot;react-dom&quot;;import { UserAgentContext } from &quot;@/stores/userAgent&quot;;import { Environment } from &quot;@/constants/enum&quot;;import cName from &quot;classnames&quot;;export interface IPopupRef { open: () =&gt; void;}interface IProps { children: JSX.Element;}export const Popup = forwardRef&lt;IPopupRef, IProps&gt;(({ children }, ref) =&gt; { const [visible, setVisible] = useState(false); const [enter, setEnter] = useState(false); const [leave, setLeave] = useState(false); const { userAgent } = useContext(UserAgentContext); const maskClass = useMemo(() =&gt; { return userAgent === Environment.mobile ? &quot;forbidScroll&quot; : &quot;pcForbidScroll&quot;; }, [userAgent]); useEffect(() =&gt; { document.body.className = visible ? maskClass : &quot;&quot;; let timeout; if (visible) { setEnter(true); timeout = setTimeout((): void =&gt; { setEnter(false); }, 300); } else { setLeave(true); timeout = setTimeout((): void =&gt; { setLeave(false); }, 300); } return (): void =&gt; { timeout = null; }; }, [visible]); useImperativeHandle(ref, () =&gt; ({ open: (): void =&gt; { setEnter(true); setVisible(true); setTimeout((): void =&gt; { setEnter(false); }, 300); }, })); const renderDom = visible ? ( &lt;div className={cName({ [styles.popup]: true, [styles.enter]: enter, [styles.leave]: leave, })} &gt; &lt;div className={styles.mask} /&gt; &lt;div className={styles.popupContent}&gt; &lt;div className={styles.closeBtn} onClick={(): void =&gt; { setLeave(true); setTimeout((): void =&gt; { setLeave(false); }, 300); setVisible(false); }} /&gt; {children} &lt;/div&gt; &lt;/div&gt; ) : ( &lt;&gt;&lt;/&gt; ); return typeof document !== &quot;undefined&quot; ? ReactDom.createPortal(renderDom, document.body) : renderDom;}); 12345678910111213// ./pages/global.scss// 移动端遮罩层.forbidScroll { height: 100vh; overflow: hidden;}// pc端遮罩层.pcForbidScroll { width: calc(100% - 1rem); // 滚动栏假区域 height: 100vh; overflow: hidden;} 这边区分了移动端和 PC 端的遮罩层，因为移动端的遮罩层默认的宽度是很窄的，所以我们不需要对它进行区域空格。现在我们来看一下效果，可以看到现在效果已经不错了。 小结这节课是我们需求进阶篇的最后一节课，我们学习了怎么实现一个自定义的动画组件，除了基本的样式，我们还学习了什么是滚动穿透，通过增加全局类的方式解决了这个问题。 同时作为一个通用组件，弹窗组件往往不随父组件位置渲染，在 body 下渲染可以避免父级区域样式和事件的污染。至于动画的实现，渐入渐出我们采用类切换的方式，因为 react state 最后统一切换的关系，我们采用异步来切换最后一个状态类，达到动画的效果。 最后我们还遇到一个 PC 端遮罩层滚动栏丢失的问题，我们参考了京东的方案，为弹窗状态下的类空出了一部分区域，来解决弹窗时候视差的问题，不过，其实除了这个方案，还有更好的实现方式，京东的方案还是很 hack 的，不过这边我们卖个关子，在16 | 设备兼容：IOS 300ms delay &amp; 橡皮筋问题解决方案 我们再来学习这个方案，这个在兼容 IOS 相关问题时，会一并优化~ C 端站点中常常会用到一些大图，大图的资源请求时间长，站区域面积较大，在低网速情况下，请求时间过长，会导致页面长时间大区域留白，从下一节课开始，我们将开始性能优化篇的学习，我们来一起探讨一下如何针对大图低网速加载场景进行首屏优化。","link":"/2023/02/01/ssr/react/next/9.%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6,%E5%AE%9E%E7%8E%B0%E5%8A%A8%E7%94%BB%E5%BC%B9%E6%A1%86%E7%BB%84%E4%BB%B6/"}],"tags":[],"categories":[{"name":"README","slug":"README","link":"/categories/README/"},{"name":"android","slug":"android","link":"/categories/android/"},{"name":"engineering","slug":"engineering","link":"/categories/engineering/"},{"name":"react","slug":"react","link":"/categories/react/"},{"name":"原理","slug":"android/原理","link":"/categories/android/%E5%8E%9F%E7%90%86/"},{"name":"stencil","slug":"stencil","link":"/categories/stencil/"},{"name":"前言","slug":"stencil/前言","link":"/categories/stencil/%E5%89%8D%E8%A8%80/"},{"name":"webpack","slug":"webpack","link":"/categories/webpack/"},{"name":"base","slug":"webpack/base","link":"/categories/webpack/base/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"project","slug":"project","link":"/categories/project/"},{"name":"ssr","slug":"ssr","link":"/categories/ssr/"},{"name":"原理","slug":"stencil/原理","link":"/categories/stencil/%E5%8E%9F%E7%90%86/"},{"name":"基础使用","slug":"stencil/基础使用","link":"/categories/stencil/%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"基础","slug":"javascript/基础","link":"/categories/javascript/%E5%9F%BA%E7%A1%80/"},{"name":"依赖治理","slug":"project/依赖治理","link":"/categories/project/%E4%BE%9D%E8%B5%96%E6%B2%BB%E7%90%86/"},{"name":"原理","slug":"ssr/原理","link":"/categories/ssr/%E5%8E%9F%E7%90%86/"},{"name":"plugin","slug":"webpack/plugin","link":"/categories/webpack/plugin/"},{"name":"effect","slug":"vue/effect","link":"/categories/vue/effect/"},{"name":"compiler","slug":"vue/compiler","link":"/categories/vue/compiler/"},{"name":"loader","slug":"webpack/loader","link":"/categories/webpack/loader/"},{"name":"others","slug":"vue/others","link":"/categories/vue/others/"},{"name":"react","slug":"ssr/react","link":"/categories/ssr/react/"},{"name":"reactive","slug":"vue/reactive","link":"/categories/vue/reactive/"},{"name":"render","slug":"vue/render","link":"/categories/vue/render/"},{"name":"ref","slug":"vue/ref","link":"/categories/vue/ref/"},{"name":"内置组件","slug":"vue/others/内置组件","link":"/categories/vue/others/%E5%86%85%E7%BD%AE%E7%BB%84%E4%BB%B6/"},{"name":"next","slug":"ssr/react/next","link":"/categories/ssr/react/next/"},{"name":"特殊元素","slug":"vue/others/特殊元素","link":"/categories/vue/others/%E7%89%B9%E6%AE%8A%E5%85%83%E7%B4%A0/"}],"pages":[]}